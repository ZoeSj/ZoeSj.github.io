<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于MySQL]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%85%B3%E4%BA%8EMySQL%2F</url>
    <content type="text"><![CDATA[使用MySQL如何设计web数据库？使用关系数据库代替普通文件有哪些优点？关系数据库专门的内置机制是怎么处理并发访问的？什么是关系数据库？web数据库的设计和架构是什么？]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[question-about-Thinking-in-PHP-internals-Apache]]></title>
    <url>%2F2018%2F11%2F12%2Fquestion-about-Thinking-in-PHP-internals-Apache%2F</url>
    <content type="text"><![CDATA[Apache模块apache 是Apache软件基金会的一个开放源代码的web服务器，可以在大多数电脑操作系统中运行。什么是web服务器？什么是模块扩展？怎样实现模块扩展？有哪些常见的模块？什么是mod_auth?what’s mod_ssl?what’s mod_rewrite?什么是以Apache模块的方式与Apache集成？perl python tcl PHP 是怎样和Apache集成的？ PHP是怎样以mod_php5模块的形式集成？为什么是5不是4？mod_php5的作用是什么？如何让Apache启动的时候启动模块以接受PHP文件的请求？通过注册什么？什么是动态加载？功能扩展是啥？怎样给服务器发送信号HUP？HUP是什么？AP_SIG_GRACEFUL通知服务器重新载入模块。怎么通知的？AP_SIG_GRACEFUL是啥？什么是动态链接库？如何将模块编译成动态链接库？Apache是通过什么模块来对动态链接库进行处理的？Apache是如何加载模块的？module结构体中的magic字段是什么？怎么实现？如何体现？定义是什么？如何激活模块？整个流程是什么？什么是挂钩？启动挂钩是什么？请求挂钩又是啥？DSO module是什么？描述下Apache加载mod_php5模块的整个过程？如何理解下面这个： 如果我们定义了此前服务器接口的flush函数，则直接调用flush对应的函数，返回成功，否则返回失败。 对于我们当前的Apache模块，其实现为php_apache_sapi_flush函数，最终会调用Apache的ap_rflush，刷新apache的输出缓冲区。 当然，flush的操作有时也不会生效，因为当PHP执行flush函数时，其所有的行为完全依赖于Apache的行为，而自身却做不了什么， 比如启用了Apache的压缩功能，当没有达到预定的输出大小时，即使使用了flush函数，Apache也不会向客户端输出对应的内容。 apache的运行过程apache是如何启动的？以什么用户身份启动？整个过程处在什么进程线程环境中？这个阶段都做了哪些工作？Apache启动阶段执行了大量的初始化操作是为了什么？Apache运行阶段的主要工作是什么?使用的身份是什么？为什么要切换身份？怎样切换的？Apache对HTTP的请求分为几个阶段？细分可以是哪几个？Apache hook机制什么是Apache hook机制？定义如下： Apache允许模块(包括内部模块和外部模块，例如mod_php5.so，mod_perl.so等)将自定义的函数注入到请求处理循环中。 换句话说，模块可以在Apache的任何一个处理阶段中挂接(Hook)上自己的处理函数，从而参与Apache的请求处理过程。 mod_php5.so/ php5apache2.dll就是将所包含的自定义函数，通过Hook机制注入到Apache中，在Apache处理流程的各个阶段负责处理php请求。 关于Hook机制在Windows系统开发也经常遇到，在Windows开发既有系统级的钩子，又有应用级的钩子。 如何将自定义的函数注入到请求处理循环中？Apache常用对象关于httpd.h文件，了解多少？httpd.h文件里面包含的是什么？定义了什么？request_rec对象是啥？server_rec对象是啥？conn_rec对象是啥？结论对Apache还是比较疑惑Apache和Nginx的区别是什么，为什么搭建环境时有时是Apache 有时是Nginx，它们起的作用是什么？apache的不同版本对php有啥影响？参考资料：《The Apache Modules Book–Application Development with Apache》]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[algorithmic-二分法]]></title>
    <url>%2F2018%2F11%2F12%2Falgorithmic%2F</url>
    <content type="text"><![CDATA[二分查找一般而言，对于包含了n个元素的列表，用二分查找最多需要log2n步，而简单查找最多需要n步。 对数什么是对数？如何简单的说明这个概念？对数是幂运算的逆运算 什么是大o表示法？简单的python例子下面是书上的栗子，但是用python3运行会报错： 一个错是print函数不能打印，显示语法错误，应该修改成print(binary_search(my_list, 3)). 另一个错是mid = (low + high)/2这里会报list indices must be integers, not float。解决方案是修改成mid = (low + high)//2 12345678910111213141516171819def binary_search(list, item): low = 0 high = len(list)-1 while low&lt;=high: mid = (low+high)/2 guess = list[mid] if guess == item: return mid if guess &lt; item: low = mid+1 else: high = mid-1 return Nonemy_list = [1,3,5,7,9]print binary_search(my_list, 3)print binary_search(my_list, -1) 修改后可以运行的程序： 12345678910111213141516171819def binary_search(list, item): low = 0 high = len(list)-1 while low&lt;=high: mid = (low+high)//2 guess = list[mid] if guess == item: return mid if guess &lt; item: low = mid+1 else: high = mid-1 return Nonemy_list = [1,3,5,7,9]print(binary_search(my_list, 3))print(binary_search(my_list, -1)) 小练习假设有一个包含128个名字的有序列表，你要使用二分查找在其中查找一个名字，请问最多需要几步才能找到?7步128=2*2*2*2*2*2*2 上面列表的长度翻倍后，最多需要几步?8步]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>小概念</tag>
        <tag>每天涨个小姿势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[question_about_Thinking_in_PHP_internals（SAPI）]]></title>
    <url>%2F2018%2F11%2F12%2Fquestion-about-Thinking-in-PHP-internals%2F</url>
    <content type="text"><![CDATA[深入理解PHP内核关于PHP的源码目录结构，根目录下都放了哪些文件？这些文件有什么用？有哪些比较重要的文件值得看看？想写PHP扩展应该看看那个文件？源码编译的文件存放在哪里？这些文件是如何编译的？构建是什么？怎样构建脚本文件？ 检查环境的脚本是什么？编译的脚本后缀是什么？官方扩展目录是哪个？里面包含的内容是什么？扩展中的东西是怎样和PHP联合起来使用的？怎样进行调用？？为什么能调用？如何书写自己的扩展？扩展文件中的tests文件是干嘛的？里面是测试和调试的么？最核心的代码是放在哪里的？主要实现了什么？zend引擎目录里面都有些什么？这些机制的实现和测试都在这里么？PHP扩展与应用仓库是哪个文件？各种服务器抽象层的代码都安家在哪？这里面都有哪些抽象？？或者说哪些接口？PHP的线程安全是构建在哪个库上面的？这玩意是干嘛的？能封装嘛？封装它干嘛？PHP的测试脚本都在哪待着？怎样写测试文件？怎么进行自动化测试？测试有啥好处？有必要么？虽然我是macos系统，但是这要是在windows下，有哪个目录里面有对它的相关实现？fatal error是什么？为什么测试脚本会“不小心”触发它？PHP中有哪些将脚本隔离的方法？研究下$PHP_SRC/run-tests.php脚本的实现也是不错的选择，哪里不错？如何研究？PHP源码中的宏在哪？有哪些常见的》怎么理解这些宏？##和#有啥子区别？宏在实际中有哪些应用？比如对字符串进行封装，是怎么封装的？？宏定义中的do-while循环？do-while和宏定义有啥关系？多行宏又是什么？宏不是只是用#来标明的么？宏定义了是不是就直接在代码执行时按照宏定义的方式来？所以宏定义就是对相关的底层操作和参数进行定义？宏只是简单的代码替换？预处理（#line）又是啥?主要是干嘛的？全局变量宏又是啥？这系列宏的主要作用是什么？啥叫解决线程安全所写的全局变量包裹宏？什么是线性安全？？ifdef是什么？ZTS又是啥？PHP运行时的全局参数，这些参数都有啥意义？他们都在哪个里面？zend_bool代表什么？据说那些全局变量和php.ini文件的配置项是对应的，在PHP启动并读取php.ini文件时就会对这些字段进行赋值，而用户空间的ini_get()，ini_set()函数操作的一些配置也是对这个全局变量进行操作的，这两者是如何联系起来的？用户代码的执行脚本的编译，解析，执行，web服务器的配合，内存管理，语法实现这些过程都是什么，运行过程中发生了什么变化？PHP的整体结构是什么？PHP的生命周期是什么？PHP与其他容器（Apache）的交互式怎样进行的？什么是词法分析？什么是语法分析？上述分析是存在哪里？源码是什么？怎么执行的？有什么用？zend engine在PHP中的作用?SAPI接口是什么？什么是Opcodes？生命周期和zend引擎SAPI server application programming interfaceApache，Nginx这类web服务器是怎样和PHP脚本工作的？怎么测试PHP脚本？他们工作是为了什么？PHP解释器又是什么？web服务器应答？是应答什么？为什么回应答，并且将应答内容显示给浏览器，这期间是怎样运行的？标准输入输出又是什么？PHP解释器在哪？web服务器和命令行程序执行的脚本为何不一样？哪里不一样？SAPI接口有哪些？常见的有哪些？怎么工作的？和Apache是如何联系？二者有什么关系？模块初始化阶段（MINIT）主要做了什么？Apache启动以后，都做了什么？命令行程序执行流程是什么？什么是模块激活阶段？（RINIT）什么是PHP注册扩展模块？注册是什么意思？注册常量，定义模块使用的类，这些是每次执行PHP脚本都会发生的么？是怎样发生的？都如何实现的？什么是回调函数，如果实现这些回调函数？怎样创建一个执行环境？PHP每次运行中那些定义的变量和函数都存放在哪里？RINIT函数是什么？什么是单进程？CLI CGI又是什么？为什么在调用每个模块前，都有一个初始化的过程？脚本中定义的变量在初始化时被放在哪里？什么是内置模块？禁用函数是什么？不可调用么？那为什么还存在？什么是垃圾收集机制？如何重置？什么是多进程模式？PHP是怎样编译为Apache的一个模块来处理PHP请求的？Apache启动后怎样fork出多个子进程？Hiphop是啥？PHP的很多扩展是怎样和zend引擎耦合在一起？如何将PHP扩展和zendapi解耦？SAPI源码解读SAPI概述PHP源码的SAPI目录存放了哪些抽象层的代码？fastcgi和cgi有什么区别？为什么多了个fast？各个服务器抽象层直线遵守怎样的约定？_sapi_module_struct结构体变量是什么？怎么实现？函数指针的说明： startup 当SAPI初始化时，首先会调用该函数，如果服务器处理多个请求时，该函数只会调用一次，比如Apache的SAPI，它是以mod_php5的Apache模块的形式加载到Apache中的，在这个SAPI中，startup函数只会在父进程中创建一次，在其fork的子进程中不会调用。 activate 此函数会在每个请求开始时调用，会再次初始化每个请求前的数据结构 deactivate 此函数会在每个请求结束时调用，用来确保所有的数据，以及释放activate中初始化的数据结构。 shutdown 关闭函数，用来释放所有的SAPI的数据结构，内存等。 ub_write 不缓存的写操作（unbuffered write），用来将PHP的数据输出给客户端，如在CLI模式下，其最终是调用fwrite实现向标准输出输出内容，在Apache模块中，它最终是调用Apache提供的方法rwrite。 sapi_error 报告错误用，大多数的SAPI都是使用的PHP默认实现php_error flush 刷新输出，在CLI模式下通过使用c语言的库函数（？？）fflush实现，在php_mode5模式下，使用Apache提供的函数rflush实现。 read_cookie 在SAPI激活时，程序会调用此函数，并且将此函数获取的值赋值给SG(request_info).cookie_data.在CLI模式下，此函数会返回null。 read_post 此函数和read_cookie一样也是在SAPI激活（？？？？怎样激活？？？）时调用，它与请求的方法有关，当请求的方法是post时，程序会操作$_POST,$HTTP_RAW_POST_DATA等变量。 send_header 发送头部信息，此方法一般的SAPI都会定制，其所不同的是，有些的会调用服务器自带的（such Apache），有些是需要自己实现的（such fastcgi） 现在的sapi目录已经去除了很多。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五度-瓶颈]]></title>
    <url>%2F2018%2F11%2F11%2F%E4%BA%94%E5%BA%A6-%E7%93%B6%E9%A2%88%2F</url>
    <content type="text"><![CDATA[2018已经过去四分之三，筑基期的道友们修炼到元婴期了么？修炼过程中有木有遇到瓶颈啊？ 自从修仙以来，和道友们聊天的话题也会经常提及瓶颈，遇到瓶颈是一件很正常的事情，在很多仙侠大会上，常常有渡劫期的道友讲述他们如何渡过瓶颈的。 去年的这个时候，在一个叫“谷歌方法论”的宗师禅会上，听到一位渡劫期的宗师对瓶颈的论述，受益颇深. 忘了自我介绍，我叫哈希，从一个叫地球的地方穿越到这个大陆，那是一个月黑风高的晚上，伸手不见五指，我正在废寝忘食的找一个bug（巴格），找着找着，脑海中隐隐约约有个画面在跳动，电脑上的代码越来越模糊，扭曲成了一个长着四条腿，三个眼睛的奇怪虫子，它的声音传进了我的脑海中，“来啊，来啊~这个世界需要你，快来吧~~”，然后双眼一黑，就失去了意识. 醒来时发现自己在这个叫做五度的星球上。旁边有一只被打死的虫子，和昨晚看到的一样。救我的是一个身材瘦小的兄弟，他肩上扛着一个三角叉，嘴里叼着一个鸡腿，看我醒了，和我说，“小兄弟，你醒啦，是我救了你，你从哪来的啊？这里已经很久没有人类了，你看四周都是巴格”，“我？我从神州来的，这是哪里啊？是在地球上么？”“地球？那是什么球？这里是五度大陆”“…” 经过一番交流，哎，我，哈希，成功的被一只巴格引到这个星球上来了。据傅里叶（救我的这个小兄弟）说，这片大陆上，有很多超级巴格存在，它们无比的强大，而且有很厉害的探寻能力，专门寻找宇宙中各个星球生产巴格多的人，把他们吸引到这里，为这些无敌巴格生产更多的小巴格。 所以，我是因为巴格写的太多了，然后被一个无敌巴格发现，于是派了个小喽啰去地球引渡我过来，没想到引渡的小巴格被傅里叶打死了。 傅里叶看我知道真相后生无可恋的样子，安慰道：“没关系，大兄弟，这里虽然生产巴格的非常多，但是像化神期，渡劫期的大神依然有很多，你好好修炼，有朝一日，说不定能找到那个引渡你过来的无敌巴格，然后找回你本来星球的坐标，就可以回去啦，或者踏破虚空去其他地方。对了，我正要去参加一个叫做得到的宗教看点东西，你要一起去么？” “去！还有，我看起来很像大兄弟么？” “不像，像小兄弟。” 于是跟着傅里叶去了得到，在那里呆了一年，了解了很多。今天这个瓶颈也是当时在得到下一个叫谷歌方法论的门派里，听一位渡劫期前辈留下的影像，他的很多影像让我受益颇深。 和地球上差不多，五度大陆上有很多人类，还有其他物种，都是和平共处的，也有各种职业，像巴格卜莎师，巴格狩猎者，器皿师，药师，机械师，算法师，数据师，IT师，爪哇师，拍片师……. 虽然职业很多，但是每个职业都会在一定时期遇到各种各样的瓶颈，有很多筑基期和炼气期的修炼者，要求渡劫期的大神们在大陆上呼吁提高他们的地位，就此，渡劫期的一位前辈吴军出了一期关于瓶颈的影像。 他说遇到瓶颈是一件非常正常的事情，不必大惊小怪。这个现象存在于各行各业，不仅仅IT师，爪哇师，拍片师会遇到，其他职业也都很普遍。甚至像以前被称为铁饭碗的巴格卜莎行业，也是每况愈下。这些问题并不是呼吁提高地位就可以的，也不是简单的努力就能解决问题，如果原因没找对，所谓的解决方法（跳槽或者改行）也是瞎添乱。 所以如何下手呢？这些人缺失啥？其实是一种新的认知，一种信息时代的思维方式（计算机思维）。 主要是对量级这个概念的认识，由于我们生存的环境，决定了对大数字是无感的。这也导致我们被限制了很多认知，我们思维方式没有跟上时代的发展，就很难在这个行业里突破瓶颈。从筑基期到炼气期，可能努力点，就能提升，但是从炼气期到元婴期，就没那么容易了，而且期间也很容易遇到各种修炼瓶颈，这个时候，就需要切换思维了，调整当前的认知。 当时这位渡劫期的前辈，还在影像中留下了一个问题： “未来十年，世界上什么东西增长最快？或者说五度大陆上什么地方变化最快？” 当时盘坐在影像前（影像在下面），思考了好久，什么东西增长最快呢？除了巴格。感觉应该是数据，自从来到了五度大陆，这里的数据变化可大了，而且对数据的处理转化和利用，令我瞠目结舌。 什么地方变化最快？我对五度大陆还不够了解，不知道。所以你们觉得呢？ 影像:快到年底了，可能是回顾一年工作收获的时候了，不知道你这一年在职业发展中是否满意。如果你获得了晋升，或者有明显进步，那么恭喜你。 如果你觉得没有达到年初的预想，甚至遇到了职业发展的天花板，也不用着急。我们提高了见识，找到正确做法以后，相信你明年会做得比现在更好。 遇到职业天花板是一件常见的事情，大家不用大惊小怪。很多 IT 从业人士向我抱怨，说他们在社会上被人看不起，被谑称为“码农”，希望我作为一个计算机行业成功的从业者、技术专家，在各种场合呼吁提高他们的地位。 应该讲，今天的世界离不开程序员，就如同我们离不开建筑工人一样，因此全社会应该尊敬他们。但是，很多程序员完成工作的水准，以及对自己的要求，还真有一点像是码农。 更让他们烦心的是，IT 行业的从业者，用不了10年就遇到职业天花板了，以至于无论他们怎么自我提升，如何努力学习新技术，都摆脱不了码农的处境。一些人虽然通过换工作当上了一线经理，管着几个人，但是事业也就到头了，大的事情做不了，小的事情做着烦。 刚才说的这种现象不仅在 IT 行业里很普遍，在其他很多行业中也是如此，包括过去被誉为金饭碗的银行业，现在可以说是每况愈下，很多人不要说提升了，保住饭碗都是问题。 这些人的问题，并非我们呼吁提高他们的地位就会有作用，也不是简单的努力就能解决问题。如果原因没找对，所谓的解决方法（比如跳槽和改行）无非是瞎添乱。 实际上，不仅员工们着急，很多老板在新形势下也不知道该怎么办了。今年好几家国内巨无霸公司的董事长和 CEO 找到我，都是同一个原因，眼看着自己的企业在信息时代可能落伍，但是从上到下都感觉“好无力啊”。 这些公司有的管理着几万亿的资产，有的一年有小一千亿的利润，但是四五家这样的企业市值加起来，还不如一家腾讯。他们想发展，但是不知从何入手。 这些人和企业所缺失的是什么？其实是一种新的认知，一种信息时代的思维方式，我把它叫做计算机思维。 为什么叫它计算机思维呢？这并不是说计算机有思维，而是因为这种思维方式是伴随着计算机出现的。简单地讲就是和常人思维完全不同的一种方式，它包括很多方面。 今天为了方便你理解这个概念以及认识它的重要性，我只介绍计算机思维的一个方面，就是对“大”和“小”的理解，或者说对量级这个概念的认识。 我们人类生活的环境，决定了我们对大数字是无感的。 著名物理学家伽莫夫（宇宙大爆炸理论以及核聚变理论的提出者）在他的科普书《从1到无穷大》中举了这样一个例子。两个原始部落的酋长比赛，看谁说的数字大。第一个酋长说了三，第二个酋长想了半天，然后说你赢了。 你今天听起来觉得这两个人真可笑，至少说出四，岂不就赢了？但是对这两位酋长来讲，所拥有的东西就很少超过三个，比三个多的东西他们就觉得没有必要数清楚了，就用许多来形容了。也就是说，他们生活的环境限制了他们的认知。 生活在今天的人就对大数的认知好了很多么？其实好不了多少。我们不妨再看两个例子： 第一个例子，会做 PPT 的人都知道要用图表，而不是用数字列表来说明问题，因为认知学家早就发现人对大数字是无感的。今天很多人数100，000，000这个数字，还是从后往前，个十百千万地数。 第二个例子是王健林在2016年半开玩笑地讲，“先定个小目标，比如说一个亿”，被全社会吐槽，因为即便是在今天的美国，也很少有人能一辈子挣一亿人民币(也就是1400万美元左右)，关于这一点我在上一季的《硅谷来信》第138封信中有详细分析。 但是，如果换一个角度思考这件事情，这也说明了人对“大”和“小”这两个概念的理解，其实受限于具体生活的环境。你习惯了某一个环境的度量，其实很难理解在量级上大得多的世界。对大部分人来讲，一亿等于财富自由，等于无穷大。 今天人的思维当然比1万年前的酋长们开阔了许多，但是相比计算机的思维就显得落后很多了，因为计算机从诞生开始，就是针对大数设计的。 1946年人类第一台电子计算机诞生时，每秒钟能进行5000次运算。虽然这个速度只有 iPhone 计算速度的一百万分之一左右，但是比人已经快得不得了了。 当时科学家们让它计算长程火炮炮弹的轨迹——这其实是发明电子计算机的原始目的，炮弹还没有落地，计算机就算出了轨迹，以至于在场的蒙巴顿元帅看得目瞪口呆，说，真快啊，简直是电的脑，“电脑”一词就是这么来的。 由于一开始就是针对海量数字设计的，因此计算机思维和人的思维是不同的，就如同我们和一万年前的酋长不同一样。比如说，我们觉得围棋的变化数量是数不清的，因为这个数量太大，以至于很多下围棋的人也说不清有多大。 当然，如果用数学方法分析一下，围棋的复杂性还是可以分析清楚的。棋盘上每一个点最终可以是黑子、白子或者空位三种情况，而棋盘有361个交叉点，因此围棋最多可以有3^361≈2x10^172这么多种情况。这个数当然非常非常大，大约是2后面跟了172个零。这么大的一个数字，人类对它是无感的。 不过，如果你去问物理学家，他们对这个数字会深有体会，他们会告诉你整个宇宙中不过才有10^80~10^82个基本粒子（质子、中子或者电子等等）。也就是说，如果把每一个基本粒子都变成一个完整的宇宙，再把这些宇宙中的基本粒子数一遍，数量也没有围棋棋盘上各种变化的总数大. 因此，这么多变化对人类来说就是无穷无尽。于是乎，我们人类就不把下围棋当作一种计算问题，而把这件事当成一种文化，或者更具体地讲是“棋道”。 但是，对于计算机来讲，围棋再复杂，2x10^172这个数字再大，它也是一个有限的问题。我们认为它不可计算，是因为人类脑子的计算能力也是有极限的，缺乏计算复杂问题的思路。但是在计算机看来，这个大问题是可以计算的。 当我们嘲笑那两个酋长只能数到3的时候，计算机可能也在嘲笑我们算不清围棋的步数。可以讲，认知决定了思维方式，当我们算不清的时候，我们就发明了所谓“围棋文化”这种思维方式。 相比计算机，人类对数字的认知也受限于我们作为生物进化的速度，这是人的思维和计算机的思维的另一个不同之处。 世界上最早的农业大约始于1万年前，人类大约从那个时代开始识数，人类最早的计算工具（在兽骨上刻上划痕计数）也始于那个年代。可以讲从酋长们认识3，到今天我们认识一个亿，经历了大约10000年的时间。平均每十年进步千分之八，不到1%。 那么计算机的进步速度有多快呢？我们知道摩尔定律让计算机毎十八个月性能翻一番，这大约相当于每五年涨十倍，或者每十年进步一百倍！ 到今年，iPhone 正好是第十年，iPhone 8的速度恰巧大约是当初乔布斯宣布的第一款 iPhone 的100倍左右。今天如果你保留了一部第一版的 iPhone，不妨试试随便装一个今天的 App，根本用不了的，因为当初的 iPhone 速度太慢了。 如果我们往未来看，今天如果要开发5年之后的 IT 产品，就必须假设在今天10倍资源的框架下进行设计。但是让今天很多搞 IT 的人考虑拥有了10倍的资源以后，怎样才能更好地服务大众，他们是缺乏这种想象力的。 我们过去感叹乔布斯像神一样，因为他拥有一个计算机的思维，能够想象几年后的世界。相比之下，当时嘲笑他的诺基亚前 CEO 奥利拉（Jorma Ollila）的思维还是常人的思维。不幸的是，奥利拉等人的局限性让诺基亚遇到了天花板。 我们常说今天是后信息时代，或者即将进入智能时代。很多 IT 从业者的思维方式并没有跟上这个时代，这是他们很难在这个行业里突破天花板的根本原因。 不仅一般员工如此，老板或者一些大公司也不例外，明天我就举几个例子来说明这一点。从那些例子中你可以看出，需要换脑筋的不只是 IT 人士，而是我们这个时代的所有人。 此影像来自得到的谷歌方法论 侵删]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[question_about_computer_system]]></title>
    <url>%2F2018%2F11%2F08%2Fquestion-about-computer-system%2F</url>
    <content type="text"><![CDATA[程序设计与计算机系统—深入理解计算机系统什么是数字的机器表示方式？对真值的有限近似值是什么？编译系统包括几个阶段（预处理器，编译器，汇编器，链接器）GUN是什么？GUN环境包括哪些功能？GNU又是什么？？一个函数调用的开销有多大？while循环比for循环更有效么？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，与将其放到一个通过引用传递过来的参数相比，运行速度要快很多呢？为什么只是简单的重新排列一下一个算数表达式中的括号就能让一个函数运行的更快？ 静态库和动态库的区别是什么？在命令行上排列库的顺序有什么影响？为什么有些链接错误知道运行时才会出现？静态变量和全局变量的区别是什么？静态和动态有什么区别？区别在哪？安全漏洞到底是啥？怎么造成的?如何避免？？怎样限制从不受信任的站点接收数据？数据和控制信息存储在程序栈上的方式有哪些？什么是正确的？？缓冲区在哪？？？数据信息放在磁盘上是怎样存放的？？shell是什么？为什么可以在这里执行目标文件？硬件系统组织包括哪些组织？？删除后的数据都去哪了？怎样被抹除的？怎样区分处理器的指令集结构和微体系结构？缓存的东西放在哪？什么是高速缓存？寄存器 处理器，存储器，主存 ，磁盘操作系统的功能，是怎样实现这些功能的？抽象是什么？为什么很多东西都说是抽象化？进程是什么？线程又是什么？协程是什么？？并发运行是什么？并行又是啥？什么是上下文切换？虚拟存储器又是什么鬼？单核处理器和多核处理器的区别和用途分别是什么？超线程又是什么鬼？什么是超标量处理器？有几种数字表示？都有哪些区别，分别用在什么场合？什么是补码？补什么的？为什么会产生溢出？这些溢出的数都去了哪里？最后为什么会得出一个吃惊的后果？很多计算机的安全漏洞是由于计算机算术运算的微妙细节引起的，是怎样引起的？会导致怎样的后果？库函数都放在哪里的？怎么调用他们？库函数是用什么写的？？ISO 是什么？为什么要安装她的标准来？C90是啥 C99是什么？gnu89是什么？ANSI又是什么？有哪些c语言版本？指针在C语言中扮演的角色？指针存放在哪里？它是怎样运行工作的？指针和数组有哪些不可告人的秘密？进制间的转换有哪些规则？较大数值的转换，是怎样进行的？电脑的32位和64位是怎么来的？是因为计算机的字长么？32位的计算机虚拟地址空间为多大？许多机器有处理单个字节或者其他长度字节的指令，这些指令是什么样的？都存放在哪里？什么是小端法？什么是大端法？哪些公司分别采用什么规则？最高有效位是什么？最低有效位是什么？不同的数据类型转换，主要转换的是什么？哪里进行了改变？是数据存储的位置 么？还是数据的大小以及编码方式什么的？？布尔代数是什么？在32位机器上声明位int类型的程序对象能被用来存储一个指针，为什么移植到64位机器会导致问题？跨越多字节的程序对象的地址是什么？在存储器中如何排列这些字节？什么是有效位？？为什么有时候小端法机器产生的数据被发送到大端法机器或者反方向发送时会发现，接收程序字里的字节成了反序的？这个问题是怎么出现的？出现的原因是什么？？格式串里，%表示啥，为什么要以%开头？有哪些典型的示例？c语言中的typedef和sizeof都是啥意思，代表了什么？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[孤独]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%AD%A4%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[很久前写的了，趁着闲暇转到现在的blog上，有时候看看以前写的文章，感觉又要重新爱上自己。不，是更爱了，我怎么这么棒！哈哈哈。 今天比昨天要冷，天气干燥的连过夜的开封虾片依然很脆，没有一丝丝发潮，凛冬将至。2017也要接近大圆满了，忙忙碌碌的作息之后，想静下来和自己聊聊。吾日三省吾身。孤独这个话题本身就有很大的争议，尤其是来到上海之后，一个城市带给我的这种感觉并没有随着人群的拥挤而淡去。衣着光鲜，画着精致的妆容，面对的人都带着完美的面具，大家散发着生人勿进的气息，有时候反而是小孩子清澈的眼神，清洁阿姨和蔼的笑容让冬天有些许暖意。偶尔看着投射在地铁玻璃上陌生的自己，面无表情，和大家一样盯着手上的发光体，失去了焦距。很多时候，大家分不清孤单和孤独，但是我喜欢孤独，享受孤独。孤单在我看来是一个量的感觉，而孤独是质。今年上半年看过蒋老师的孤独六讲，他的几个观点我很认可，成长的过程中，有段时间我很害怕孤单，老家的房子很大，空荡荡的房间里就我一个人，总是觉得到处都是人，但是因为从小家旁边的小伙伴并不多，于是开始习惯一个人，但是从不觉得孤独。反而是到了高中和大学，有段时间很孤独，孤单是因为一个人，孤独是因为一群人。中国的传统社会中，是很排斥特立独行的人，从小爷爷奶奶爸爸妈妈就告诉我，要低调，不要惹是生非，不要强出头，总之做到中庸之道就很好，不知道你们的父母小时候有没有也这么对你们说过。很显然，并不喜欢被束缚的我，只是想做自己的事情，但是迎面而来的是你必须要承受的孤独。似乎不管是什么时代，人们能根据发型和服饰就判定你是什么人，比如穿的很淑女，那么你一定是个乖乖女；比如抽烟，就一定是坏人；染了头发，不学好；在房间看书，好孩子；打游戏，坏孩子……突然又想起前段时间，在一个技术群里，居然看到这样一个观点，抽烟的女孩子肯定有故事，要么堕过胎，要么就是干过坏事，当时看到这种观点也是震惊。前段时间有人对我说，因为我喜欢发自拍，所以就和动物求偶之心一样，想要找男人了。这个时候，才发现虽然技术在进步，社会在向前走，但是人的思想却依然跟不上。以貌取人是人惯有的行为，一直以为随着成长，接触到的人也将会是同等的人，才发现很多时候，大家并不在一个次元。这个时候，很享受自己的孤独感。当你发现度过了自己最孤独的时候，就开始享受这种感觉了，会学着和孤独共处，其实这个时候是剖析自我，了解自我的最佳时候，明白想要的，才能知道存在的意义。处在城市中的人更容易滋生孤独感，随着发展，四面八方的文化开始在一个城市发展，不同的文化撞击，不同的灵魂抨击，大家开始卸下盔甲，戴上了面具，把自己套在了套子里。〔2〕想起我最欣赏的一类人，能够在这个容易安于现状的时代坚持着自己的梦想。有时候，走在路上，看着来来往往形形色色的人，忙忙碌碌不知所以然。活着是为了什么，我想我活着是为了存在过吧，无论是怎样的人生体验和理想，都带着最大的诚意去体验生活。有次朋友问我喜欢的人是什么样的，除了美貌之外，认真的思考了很久，最吸引我的应该是上进心了，能够在自己的领域去创业，去发展，去追寻，无论中间有多少人不赞同甚至质疑，但是自己知道自己想要做什么，并且为此去奋斗和努力的你，真的存在过。这个时候，其实是最容易产生孤独感，身边的人并不能理解你所做的，妈妈经常和我说的话就是，别太累了，她觉得我把自己过得太累了，但是我却觉得我不累，每天学习新的知识，离自己的梦想更进一步，每天都是活力满满。身边的朋友总是喜欢打趣，说介绍个男朋友，其实一个人真的不孤独，如果在一起的那个人不是能一起前进和聊得来的，两个人在一起不仅孤独还会寂寞，因为彼此不理解。我不知道你们对孤独是怎么理解的，我也就随便说说自己的观点。〔3〕高中的时候很喜欢老子和庄子，庄子的”独与天地精神往来”，老子的道非道。以前一个人独处的时候，经常会读一些书籍，每次读到一些引起共鸣的，总觉得像是跨越不同的时空去和这些灵魂对话，不禁想起三体中逻辑了，他是一个能够在孤独中发现真理的。想谈谈这个话题，其实是发现日子过得有点急躁了，也不知道是因为刚进社会想要快点成长，还是觉得自己太弱了，有危机感，总之，我能感觉到每天时间都不够用，但是却又找不到进步在哪里？开始有点疑惑。我想应该静下来看看前面的路，除除草，这样视野会开阔点。但是这个和孤独有什么关系呢？有很大的关系，因为在一系列各种各样的事情中，我好像原地不动，并且开始变得找不到那个存在了。已经很久没有享受到当初那个在孤独中遨游的我了，变得忙忙碌碌，可怕的是不知道做这些是否是我真正想要的。随心所欲的活着不是随便的活着，而是随着内心的那个理想而有所作为的活着。〔4〕我希望看到这里的你，如果感觉到孤独，不要排斥，学着去享受，就像歌词里有一句，“我唱的歌我自己来和” ，我的人生我来做主。坚持自己的路，如果累了，就停下来，除除草，看清那条路是自己要走的，一路走下去，我相信沿途的风景回事你想要的。〔5〕以上来自一个伪文艺少女的周六放空曲，随意浏览，一起放空。]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[擦肩而过]]></title>
    <url>%2F2018%2F11%2F07%2F%E6%93%A6%E8%82%A9%E8%80%8C%E8%BF%87%2F</url>
    <content type="text"><![CDATA[独角戏“当你认真谈过一段感情，最后却分手了，后来你会很难再去喜欢别人，你不想花时间也不想去了解。就好比你写一篇文章快写完了，但老师说你字潦草把作业撕了让你重新写一遍。虽然你记得开头和内容但你也懒得写了，因为一篇文章花光了你所有精力，只差一个结尾，你却要从头来过。”刚打开电脑，沈诺就收到闺蜜欢子发过来的这段话，附带的还有一个问句，“你啥时候会重新喜欢一个人呢？” 沈诺盯着屏幕陷入了沉思，重新喜欢一个人？脑海中闪过的那个人已经看不清轮廓了，不记得多久没联系了，从最初的欢喜雀跃到现在的慢慢放弃，不自觉地打开微信对话框，空白的聊天对白，孤零零的失落，感觉都是一个人的独角戏，所以喜欢一个人还是太累了，沈诺回过神来，对着发黑的电脑屏幕扯了扯嘴角，还是努力挣钱吧，毕竟毛爷爷才是真爱啊。 今天不知道是不是周一的缘故，各个部门忙的不可开交，沈诺也被各种事情占据着所有时间，连午饭都是面包充个饥。 “沈诺，老大叫你过去一趟”，沈诺正在整理一个文档，目光从屏幕移交到对面的小菇凉脸上，皮肤真好，果然还是小孩子水灵灵的，一边想着一边到了老大的办公室。 “沈诺，最近刚接手了一个新的活，部门打算再招一个实习生，你负责带着他跟进新的项目，你手头上的就交给方岳吧。” “这个顽皮猴项目一直是我在跟进的啊，方岳她都没有这方面的经验，做起来周期应该会延后吧？”沈诺内心翻涌了会，压了压，淡淡的开口道， “这个你不用担心，那个项目对接人和方岳是大学同学，两人关系很熟，你交接好，后面周期不会变得，这个新项目是总部很看重的，我希望你能重视起来。” ”你把资料发到我邮箱吧，我回去看看“沈诺收敛了眼皮，嗯，秋天到了，该买双新鞋了。 回到座位上，打开了邮箱，瞬间弹出了一堆标签，都是未读邮件，看都没看扔到了垃圾箱，打开了刚刚老大发过来的资料，看来去稻城的计划又得往后推了， 哎，揉了揉太阳穴，这样的日子什么时候才能结束啊。 “沈姐姐，你国庆打算去哪里玩啊？”可乐转过椅子问沈诺，“哎，本来打算去稻城走一走的，刚刚老大又交代了新任务，估计去不了了，你打算去哪呢，看你这么开心。”“我呀，我和我男朋友一个月前就订了去泰国的机票，国内人太多了，我们打算去泰国玩玩，听说那边的水果超级好吃。”看着可乐满眼的小星星，沈诺笑了笑，打趣道“可别被人妖拐走了啊，人妖可美了，到时你的小男友不要你了咋办”，“才不会呢，他敢……”。 “阿诺，我订了去曼谷的机票，下午的，你赶快收拾东西，我在你楼下等你”，刚起床的沈诺收到乔牧发来的微信，愣了愣，打了电话过去，“你是不是没睡醒啊？一大早就逗我”“没有啊，快起来收拾收拾吧，我吃完早饭就去接你了，你想吃啥，我买点带着……” “沈姐姐？沈姐姐？” “嗯？” “你在发什么呆呢，我想问下出国需要带什么啊，有没有要注意的地方啊？” “嗷，有的啊，你可以去知乎上搜一下，还是很齐全的呢……”……. 躺在床上，沈诺连手机都没碰就睡着了。 “沈诺，一诺千金，你觉得这个名字怎样？” “好听，你取得都好听，以后咱孩子就叫沈诺吧。” 沈诺睡的正香，恍惚间听到有人叫自己，不一会儿就一阵天旋地转，睡觉打扰别人可真是不礼貌，沈诺很生气，睁开了一双大眼睛，正准备呵斥的，忽然发现自己发不出声音了，一双眼睛四处转了转，什么鬼，为什么周边都是人，还有护士，我怎么来医院了？ 获取授权]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初心]]></title>
    <url>%2F2018%2F11%2F07%2Fchuxin%2F</url>
    <content type="text"><![CDATA[暑假已经过去一半了，上个暑假似乎有点遥远了，还记得以前最期待的就是每年的寒暑假，抛开烦人的暑假作业和日记，真的好惬意。初中暑假，居然和晶晶在家看了两个月小说，硬生生的把一家小书店看完了，闲暇之余去田野里摘黄瓜，骑着自行车去山谷里乘凉，似乎整个夏日的暑意都被自动屏蔽了。某年和晶晶骑着自行车从高高的公路上奔驰而下，也曾被森林园区的大狗追了一路，胆战心惊，还曾带着自行车淌过河水，去玩沙子，最喜欢的是在山林间横冲直撞，没有鸣笛的大卡车，没有红绿灯，没有奔驰的轿车，回荡在林间的除了小鸟就是我们的哈哈大笑。每年的暑假都计划着要出去旅游，后来都由于种种原因变成了在家补剧，还是和晶晶，暑假在家把家里存放着的几百张碟片看完了，还恶补了韩剧，大半夜的两个人窝在16度的房间里，盖着被子，看鬼片，吓得都不敢上厕所，还是咬牙看睡着了。已经很久没看恐怖片了，如今灯红酒绿的大都市，妖魔鬼怪外星人不是最可怕的。外面的天快暗下来了，最喜欢窝在软软的沙发上，拉上窗帘，备好零食，星点的灯光映在玻璃上，厨房里的煲锅咕噜咕噜的响，锅里排骨汤的味道忽悠的飘出来带着炖炖的香气，无论外面是冰冷的雨还是皎白的雪，屋内是静谧的温暖，看一部电影，听完新闻，洗个香香的澡，舒服的缩进被窝，做个美美的梦。年少的时候，总觉得长大离自己远得不得了，一毕业，忽然发现已经是孩童时代幻想的大人了。让座时，很少有嘴甜的小朋友说谢谢姐姐，都是谢谢阿姨（手动笑脸）。作为一个老阿姨，看到新出的小鲜肉，小奶狗，内心毫无波动，甚至还想吃点酸奶，当我发现这点的时候，被闺蜜说没了少女心。可是，我很喜欢嗯哼啊，我喜欢甜馨，小孩子们多可爱啊。这些才是小鲜肉，我不要少女心，我有童心。随着暑假的远去，工作开始变成重心，不能随意的请假逃课，兢兢业业的在岗位上发挥自己的绵薄之力。一步一步，越走越现实。在社会的棱角中打磨了离校时的踌躇满志，和老友谈起工作以及今后的生活，离了学校之后，压力也随之而来，需要买房买车，结婚，生子。。。如果想在一线城市生存下去，就更要打拼了，想站住脚，不是考试拿毕业证书那么简单。谈到生活，他说现在慢慢活成自己不想的样子，开始用一生为房为车奔波。其实我们也才毕业，人生刚开始，小时候以为长大了就可以做想做的事情了，可是现在想想，那时候想做的事慢慢的随时间流逝，有人说不忘初心，什么才是初心呢？很多时候，走一条路，总是走在路的半途，不知道起点在哪，不知道终点在哪，但是就这一条路，可能会有分叉口，也不知道分叉口的终点是哪，无论什么时候踏上这条路启程，启程的那个地方就是起点，停下来，就是终点。再出发，又是起点。二十几岁，没有十年，一路走下去，都是初心。]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Question about docker]]></title>
    <url>%2F2018%2F11%2F07%2FQuestion%2F</url>
    <content type="text"><![CDATA[虚拟化技术是什么？计算虚拟化或者服务器虚拟化是什么？虚拟化和云计算有什么区别？应用虚拟化和平台虚拟化又是啥？完全虚拟化，硬件辅助虚拟化，部分虚拟化，超虚拟化，操作系统级虚拟化，这些都是什么鬼？虚拟机到底是啥？ 虚拟机镜像是什么？计算机中的各种实体资源有哪些？怎样将它们抽象？单根多IO虚拟化？啥玩意云服务的东西都存放在哪里？断网了还能继续使用么？云上的环境是大家通用和共享的么？云计算是什么？容器虚拟化又是什么？Apache2.0协议是什么？Linux基金会是啥玩意封装是怎样封装的，装到哪里？分发是给谁分发，怎样发？部署怎么部署，部署到哪？需要哪些步骤？生命周期有哪些Linux容器技术是啥（Linux container，LXC）指令级模拟是啥？即时编译是什么？解释机制又是啥？准虚拟化（paravirtualization）是什么？什么是沙盒？沙盒原理是啥在云平台的应用都放哪？怎么运行？整个生命周期是怎样的？啥是分布式？镜像是什么？里面都有些啥？怎样打包镜像？是压缩么？内核级的虚拟化是啥？一台主机运行上千个docker容器，会影响主机本身的性能么？容器们消耗的是主机的啥Dockerfile配置文件怎样配置docker的？隔离主要隔得是啥？docker有哪些版本？操作系统有哪些版本？docker用go写的，怎么写的？cgroups是什么Linux namespaces是什么AUFS是啥Union FS是啥操作系统层面的虚拟化技术是什么？libcontainer是啥runc是什么containerd是啥？黑箱镜像是什么？啥是黑箱操作docker build的工作原理Docker Remote APIDebian是什么数据卷干嘛的？docker可以直接下载镜像，就可以直接应用，那么镜像里面都是什么？就像可以直接在github上git clone相关的项目，在本地直接运行么？？轻量级的沙箱？沙箱是干么的？容器和镜像是什么关系？容器里面包含什么东西？进程空间，用户空间，网络空间，这些空间是怎么区分的？都分配了多少？镜像启动的一个流程是什么，分别都打开了啥？镜像有多少层？每一层都有什么？docker仓库和注册服务器registry有什么区别？关于下载指令：apt-get yum wget brew url等的区别和用途？为什么是docker运行容器但是需要的是本地的镜像？而不是docker运行镜像？]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装python]]></title>
    <url>%2F2018%2F11%2F05%2Fcentos%E5%AE%89%E8%A3%85python%2F</url>
    <content type="text"><![CDATA[确认当前python版本12345[root@centos Python-3.6.1]# pythonPython 2.7.5 (default, Nov 6 2016, 00:28:07) [GCC 4.8.5 20150623 (Red Hat 4.8.5-11)] on linux2Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 以上输出Python 2.7.5表示当前版本，因为yum使用的是Python2.7因此不能删除，所以只能重新安装一个替换版本。输入以下命令查看目前系统使用的Python以及安装目录，接下来将要对该目录下的Python进行修改123456[root@centos ~]# which python/usr/bin/python[root@centos ~]# ll /usr/bin/python*lrwxrwxrwx. 1 root root 7 May 30 05:52 /usr/bin/python -&gt; python2lrwxrwxrwx. 1 root root 9 May 30 05:52 /usr/bin/python2 -&gt; python2.7-rwxr-xr-x. 1 root root 7136 Nov 6 2016 /usr/bin/python2.7 下载安装下载插件根据官网提示，在centos下安装python3版本需要提前安装如下插件：yum install gcc openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel sqlite-devel libffi-devel -y 下载python切换到/root/Downloads/目录,下载最新的3.7版本python[root@localhost Downloads]# wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0a1.tgz 解压安装包并迁移至/usr/local[root@localhost Downloads]# tar -zxvf Python-3.7.0a1.tgz[root@localhost Downloads]# mv Python-3.7.0a1 /usr/local[root@localhost Downloads]# cd /usr/local/ 创建Python3目录，以免覆盖Python2[root@localhost Downloads]# mkdir python3[root@localhost Downloads]# cd Python-3.7.0a1/[root@localhost Python-3.7.0a1]# ./configure –prefix=/usr/local/python3 确认无误后，执行编译[root@localhost Python-3.7.0a1]# make 确认无误后，执行编译安装[root@localhost Python-3.7.0a1]# make install 此时没有覆盖老版本，再将原来/usr/bin/python链接改为别的名字mv /usr/bin/python /usr/bin/old_python 再建立新版本python的链接ln -s /usr/local/python3/bin/python3 /usr/bin/python 查看版本，直接输入python -V解决升级Python后yum不能用的问题升级Python后运行yum会报错vi /user/bin/yum 编辑yum的执行文件，更改首行的/usr/bin/python 为上面重命名的名字或/usr/bin/目录下指向Python2.7的名字，之后再运行yum就正常了]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫漫]]></title>
    <url>%2F2018%2F11%2F02%2F%E6%BC%AB%E6%BC%AB%2F</url>
    <content type="text"><![CDATA[有朋友曾和我说：曾经千方百计想得到的东西到最后一定会以最不经意的方式来到你的身边，所以“慢慢来，不要急&quot;这几个字不是没有道理的。 可能因为毛多吧，所以毛手毛脚在自己身上表现的淋漓尽致，但是好在岁月总会改变很多，如果有心想要改变。 我一直提醒自己一件事情，千万不要自己感动了自己，大部分人看似的努力不过时愚蠢导致的，人难免天生有自怜的情绪，唯有时刻保持清醒，才能看清真正的价值在哪。 （待续）]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用hexo快速搭建个人blog]]></title>
    <url>%2F2018%2F11%2F02%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hexo%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAblog%2F</url>
    <content type="text"><![CDATA[环境准备我本地的环境：12node -vv7.6.0 1macOS 10.13.4 12npm -v4.1.2 hexo介绍Hexo是基于NodeJs的静态博客框架，简单、轻量，其生成的静态网页可以托管在Github和Heroku上。 • 超快速度 • 支持MarkDown • 一键部署 • 丰富的插件可以看我的blog 佳爷的后花媛 安装hexo1npm install hexo-cli -g 如果没有权限，需要加上sudo1sudo npm install hexo-cli -g 创建blog目录youridname.github.io123$ hexo init youridname.github.io$ cd youridname.github.io$ npm install 生成静态页面123$ hexo clean$ hexo g//g 即generate 运行12$ hexo s//s 即server 然后打开浏览器，输入地址 localhost:4000(默认端口是4000，如果被占用了，可以更改端口号) 即可看到效果 发一篇文章试试相关命令123$ hexo new test此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存.生成下，看看效果 1234$ hexo clean$ hexo g$ hexo s访问 localhost:4000 即可 直接方式在 source/_posts/下新建一个.md文件也可 配置网站的设置大部分都在_config.yml文件中，详细配置可以查看官方文档下面只列出简单常用配置 title -&gt; 网站标题 subtitle -&gt; 网站副标题 description -&gt; 网站描述 author -&gt; 您的名字 language -&gt; 网站使用的语言坑：进行配置时，需要在冒号:后加一个英文空格title: Droidlover 换一个好看的主题,Hexo 中有很多主题，可以在官网查看。推荐hexo-theme-next，我用的也是这个，可以去我的blog看看效果。 更换主题的步骤：下载主题资源12$ cd theme/$ git clone https://github.com/iissnan/hexo-theme-next themes/next 应用下载的主题在网站配置文件_config.yml中，配置theme12theme: nextnext是主题名称，具体的可查看主题的文档 主题其他配置可在/theme/{theme}/_config.yml 主题的配置文件下进行主题的配置。比如添加评论，看板娘，添加浏览人数……接下来，可以执行万能的调试命令看看效果123$ hexo clean$ hexo g$ hexo s git准备没有GitHub账号的创建一个账号，注册流程就略略略了。然后创建一个youridname.github.io的public仓库。这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，随便选主题，反正后面也要用hexo的主题。建好仓库可以访问下https://youridname.github.io。然后本地安装部署插件1sudo npm install hexo-cli -g 找到下载hexo的目录下_config.yml文件，配置deploy123456deploy: type: git repo: &lt;repository url&gt; branch: [branch]//branch为分支，默认为master,可以不配置//repo为仓库地址，在github上新建仓库后，可复制此地址 然后将项目部署到github上1hexo d 扩展blog这时候的blog里面有很多功能没打开，可以在设置文件中更改。相关功能如下：1 实用性优化 • 基本使用（_config.yml文件配置） • 添加RSS • 添加标签、分类等页面 • 设置网站icon • 添加侧边栏社交链接 • 添加侧边栏友情链接 • 底部显示建站时间和图标的修改 • 微信支付宝打赏功能 • 关闭网站动画效果 • 设置第三方JS库 • 添加评论系统 • 统计访客量以及文章阅读量 • 阅读次数统计（基于LanCloud） • 字数统计 • 增加版权信息 • 添加文章分享功能 • 文章排序优先级设置 • 添加站内搜索功能 • DaoVoice在线联系2 个性化优化 • 设置字体 • 设置代码高亮主题 • 左上角或右上角的Github样式 • 添加背景动画 • 添加顶部加载条 • 点击出现小爱心效果 • 修改文章链接文本样式 • 修改文章底部标签样式 • 文章末尾统一添加“文本结束”标记 • 修改作者头像并旋转 • 文章添加阴影效果 • 修改打赏部分字体动画 • 自定义鼠标样式 • 添加看板娘]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代_归纳_递归]]></title>
    <url>%2F2018%2F11%2F02%2F%E8%BF%AD%E4%BB%A3-%E5%BD%92%E7%BA%B3-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[docker相关]]></title>
    <url>%2F2018%2F10%2F31%2Fdocker%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[入门docker]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%85%A5%E9%97%A8docker%2F</url>
    <content type="text"><![CDATA[最近有朋友搞了个微信机器人，我之前用phpvbot也做个了，但是不好玩，看他做的比较好玩，就想拿过来看看怎么做的。他问我会不会docker，可以把repo给我，哎呀，我不会docker哎，不过可以看看这是什么。 安装docker关于docker安装，网上的教程实在太多了，不过我也是吃饱了撑着，先去腾讯云的在线cloudstdio里面开了个ubuntu的空间来安装docker，不过用ubuntu安装要注意版本。 后面我直接在mac上安装了，安装很方便，把这几个command cv下就可以了。12345brew cask install docker//安装docker --version//查看版本信息docker info //查看配置信息 开始挖坑了刚安装好，就想赶紧试试新玩意，结果连容器，镜像都没分清楚，尴尬，pull了一堆东西，运行也没停止，就删，各种问题，疯狂google。所以还是先看清楚再玩吧。 推荐一个入门的blog，感觉那个厨房和食物的比喻还是很贴切的，蛮逗。Docker入门这里面还简单介绍了docker的发展史，老实说，我一直把docker和dota联系在一起，只要提到docker我就想到dota，虽然两者半毛钱关系都没有。 关于容器，入门时有几个迷惑，它的空间是在哪里？都说是云服务，那么创建的环境是放在我本地的还是在线上的？会占用我电脑的内存么？Docker和虚拟机有什么区别？虚拟机占内存和性能，那么docker的优势在哪里？他能解决我什么问题，环境一致？是说我在本地运行的环境可以打包成一个镜像发布到docker容器中，其他人可以直接下载这个镜像运行，就不会出现环境不一致而导致的问题么？Docker会让我节省安装环境的时间么？Dockerhub上是压缩的镜像，主要压缩了什么？怎么会变得那么小？docker build 在哪工作的？ 带着各种各样的疑惑，开始小白之旅 。。。]]></content>
      <categories>
        <category>小概念</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言数据模型]]></title>
    <url>%2F2018%2F10%2F29%2FC%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[C语言数据模型计算输出所含字符数的C语言程序123456789#include&lt;stdio.h&gt;int main()&#123; int num;//声明变量的类型 num = 0;//初始化num为0 while (getchar() != EOF)//使用getchar一次读入一个输入字符 ++num; /* add 1 to num *///在每次字符读入后递增num变量，知道没有输入字符可供读入为止。EOF会提示文件已达末尾。 printf(“%d\n”,num);//将num的值以十进制整数之后加上换行符的形式打印出来&#125; C语言类型系统静态部分主要描述了数据可能拥有的值。类型系统包含整数这样的基本类型以及一些类型构成规则，利用这些规则可以用一直的类型逐步构建更加复杂的类型。 字符（char, signed char, unsigned char） 整数（int, short int, long int, unsigned） 浮点数（float, double, long double） 枚举（enum） 其中整数和浮点数是算术类型。 可以使用基本类型或使用这些规则构建好的其他类型。 数组类型数组可由字符，算术类型，指针，结构体，共用体或其他数组构成 结构体类型结构体是由称为成员或字段的变量构成的分组。在结构体中，不同的成员可以具有不同的类型，但是每个成员都必须具有某一个类型的元素。T1…Tn是类型，M1…Mn是成员名称 1234567struct S&#123; T1M1; T2M2; T3M3; …… TnMn;&#125; 共用体类型共用体类型允许一个变量在程序执行的不同时期具有不同的类型。声明： 1234567union &#123; T1M1; T2M2; T3M3; …… TnMn;&#125;x; 定义了变量x，可以存放类型为T1…Tn中任意一种的值，成员名称M1…Mn用来指示x的值现在应该是哪种类型。也就是说，x.Mi就表示x的值是类型Ti的值。 指针类型指针类型的变量包含在某个存储区域的地址，可以通过指针间接的访问另外一个变量。声明T *p;获取对象的地址用&amp;p = &amp;x将x的地址赋值给p。就是让p指向x，用在p前面的*会获取p指向的框的值。 C语言的typedef结构可用来创建类型名称的同义字。typedef &lt;类型描述符&gt; T 函数如果函数没有返回值，那么该函数类型就是void类型的。一般情况下，可以应用类型构成规则任意地构建类型，不过也存在一些限制，比如，不能构建“函数数组”，不过构建由指向函数的指针构成的数组是可以的。 动态部分对数据进行的操作 创建或销毁数据对象的操作对于数据的创建，C语言提供了几种简陋的机制，在函数被调用时，会创建对应每个局部参数的框，这些框都用来存放参数的值。 另一种数据创建机制就是使用程序库例程malloc（n），该例程可以返回一个指针，指向n个未使用的连续字符位置，这些存储空间可以被malloc的调用者用来存储数据，餐后就可以在这一存储区域中创建数据对象。 C语言有着类似的方法来销毁数据对象，当函数返回时，该函数调用的局部参数将不服村组，例程free会释放malloc创建的存储空间，特别要说的是，使用free（p）的效果是释放p指向的存储区域，若使用free去销毁不是通过调用malloc创建的对象，会造成灾难性后果。 访问或修改数据对象某些部分的操作C语言具有访问对象某些部分的机制，可以使用a[i]访问数组a的第i个元素，用x.m访问结构x的成员m,还可以用*p访问指针p指向的对象。在C语言中，修改（或者说是写）值主要是赋值运算符完成的，这让我们可以改变对象的值。 将若干数据对象的值组合起来，为某个数据对象生成新值的操作1.算术运算符2.逻辑运算符3.比较运算符4.位运算符5.赋值运算符6.强制转换运算符 解释C语言程序的标识符与名字（用于“框”或数据对象）之间的区别标识符是在程序中自定义的一些符号和名称。比如NULL，EOF，TRUE，FALSE。要跟关键字区分开来：关键字是C语言默认提供的符号，标识符是程序员自定义的。标识符有预定义标识符和已定义标识符。名字是自己定义的，是C语言标识符的一种 举例说出有多个名字的C语言数据对象如果熟悉C语言之外的编程语言，描述一下它的类型系统和操作]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机科学的基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态和静态]]></title>
    <url>%2F2018%2F10%2F29%2F%E5%8A%A8%E6%80%81%E5%92%8C%E9%9D%99%E6%80%81%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[元编程]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%85%83%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据模型]]></title>
    <url>%2F2018%2F10%2F26%2F%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[数据模型 对象可以采用的值，例如很多数据模型包含具有整数值的对象，数据模型的这个方面是静态的，它告诉我们对象能接受哪些值，编程语言数据模型的这一静态部分通常被称为类型系统。 数据的运算。例如执行加法这样的运算。模型的这一方面是动态的，它告诉我们改变值和创建新值得方式。 编程语言数据模型每种语言的数据类型各不相同。基本原则是：每个程序都可以访问我们用于表示存储区域的“框”。每个框都具有一个类型，比如int或者char。框中可以存储类型对应的值，通常将可以存储到这些框中的值称为数据对象。框的名称视作该程序的变量。 C语言中常见的静态数据类型：整数，浮点数，字符，数组，结构，指针…… 对数据可执行的操作：整数和浮点数的常规算术运算，数组或结构元素的存取操作以及指针的解指引。指针的解指引：找到指针所指向的元素 C语言中整数表可以用链表这种数据结构表示，表的元素被存储在链表的节点中，链表及其节点可用如下类型声明定义：12345typedef struct CELL *LIST;struct CELL&#123; int element; struct LIST next;&#125; 该声明定义了有着两个字段的自引用结构CELL，第一个字段是element，存放着表中元素的值，而且其类型是int。 每个CELL的第二个字段是next，存放着指向节点的指针。LIST类型其实是指向CELL的指针，因此，LIST类型的结构可以通过它们的next字段链接起来，构成了所谓的链表。 数据类型和数据结构表和链表是不同的概念。表示数学抽象（数据模型）链表是种数据结构，通常用于c语言以及相似语言中的数据结构，用来表示程序中的抽象表。有些编程语言不需要用数据结构表示抽象表，比如：表（a1,a2,…,an）在Lisp语言中可以直接表示为[a1,a2,……,an]，而在Prolog语言中也可以表示为类似形式。 系统软件中的数据模型操作系统的功能：管理和调度计算机的资源。像UNIX这样的操作系统，其数据类型具有文件，目录和进程这样的概念。 数据本身存储在文件中，在UNIX系统中，文件都是字符串和字符。 文件被组织成目录，目录就是文件和其他目录的集合。目录和文件形成了树形结构，而文件处在树叶的位置。 进程是指程序的独立执行，进程接受流程作为输入，并产生流作为输出。在UNIX中，进程可以通过管道连接，让下一个进程的输出作为下一个进程的输入，这种进程组合可看做有着自己输入输出的独立进程。 文本编辑器中数据模型文本编辑器的每种数据模型都结合了文本字符串的表示和对文本的编辑操作。这种数据模型通常会包含行的概念，行和多数文件一样，就是字符串，不过，与文件不同的是，行可能有着与其相关联的行号，行还可能被组织成更大的单元（比如段落），而且对行进行的操作通常适用于行内的任何位置，不会像多数常见的文件操作那样，只是对前部进行操作。 电子表格 视频游戏每个调用程序都必须遵守被调用程序的数据模型，见到的各种数据模型彼此间截然不同，无论是用来表示数据的原语，还是向用户提供的数据操作方式，全部不同。而且各数据模型都是通过数据结构和使用它们的程序，用某种编程语言实现的。 电路的数据模型—命题逻辑计算机是由称为门的基本元件组成的，每个门都有着一个或者多个输入以及一个输出，输入输出的值只能是0，1.门具有一个简单的功能，比如AND运算（与运算），就是如果所有输入都是1，那么输出就是1，而如果至少有一个输入为0 ，那么输出就是0。从某个抽象层来说，计算机设计就是选择如何连接门来执行计算机基本运算的过程。 解释数据模型静态方面和动态方面的差异静态基本是描述性的，但是动态会有相关的运算过程。比如想要做一碗糖醋排骨，去菜场买了糖，买了醋，买了排骨，这些事静态方面的，然后买回来做的过程是动态的，要把排骨腌制，要上火，烧，最后才会出现想要的。 描述最喜欢的视频游戏的数据模型，区分其模型的静态方面和动态方面。提示：静态部分不仅是指计分牌上不会移动的部分。例如：在《吃豆人》游戏里，静态部分不仅包括地图，还包括强化药丸和怪物等。最近在玩王者荣耀和荒野行动，里面人物的角色，地图，怪物，设备，草地，树木。。。。。。都是静态部分，但是各种技能就是动态部分了。 描述最喜欢的文本编辑器的数据模型sublime 描述电子表格程序的数据模型]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机科学的基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typing]]></title>
    <url>%2F2018%2F10%2F26%2FTyping%2F</url>
    <content type="text"><![CDATA[静态指程序执行之前，从代码中就可以知道一切，程序静态的部分包括变量，方法的名称和类型以及控制程序的结构等等。 动态指在程序执行之前有些地方是不知道的，程序动态的部分包括变量的值，执行时间和使用的内存等等。 类型类型的产生是由于：计算机可以处理的类型只有二进制，在计算机可以直接操作的汇编语言中，数据类型都是整数，其他类型的数据都用整数来表现，这种处理方法很低级，他要求人要理解，记忆用整数来表达所有类型数据的方法。负担比较大，所以编程语言就进化了。 静态类型FORTRAN（Formula Translator）世界上最初的编程语言诞生了，引入了变量和算式的类型，在程序中，变量只能用整数赋值，数组只能是浮点数的数组等，可以指定数据类型，这是静态数据类型的开始，这种队数据类型的定义称为类型定义。 静态类型最大的优点就是能在编译时发现类型不匹配的错误。而动态语言只能发现程序错误。 静态语言的缺点一个是若不指定类型就写不了程序，另外就是灵活性的问题，静态语言本身限制了给某个变量只能赋值某种类型的对象，这种限制可能成为妨碍将来变化的枷锁。 动态类型后来出现了Lisp编程语言（List Processor）。刚出现时，Lisp只支持列表（list）和原子（atom）两个数据类型。列表是可以由两个引用的节点（node）构成的单项列表，比如像（5 13）这样的数据。原子比较难说明，简单地说就是指list以外的数据类型，比如数值和字符串都是原子。Lisp的每个节点，历史上称为cons单元，可以引用其他的cons单元货原子。cons单元可以有两个引用，因为历史的原因，前面的称为car，后面的称为cdr。在Lisp中程序好数据如果不能用文字来表现的话会很麻烦。所以Lisp用字符串来表现名为S式的列表，S式是用以下规则把列表转换成字符串的。 cons单元中，car的值和cdr的值用点连接，再用括号括起来 cdr如果是列表的话，省略括号 末尾的cdr如果是nil，那么省略.nil。 Lisp的数据用列表，程序也用列表，所有的东西都用列表来表示，Lisp用S式表示的列表构造本身就是程序。12345(defun fact (n) (if (= n 0) 1 (* n (fact (- n 1)))))//计算阶乘 Lisp的列表中的各个cons单元是指向cons单元还是原子，事先是不知道的。列表中cons单元和原子混杂存在。从本质上就可以说是堕胎的数据结构。 动态语言最大的优点就是源代码变得很整洁。但是动态语言运行要比静态语言缓慢些。另外就是灵活性比静态语言好。但是最大的缺点即使不执行就检测不出错误。 Duck Typing表达动态类型灵活性的概念就是Duck Typing。If it walks like a duck and quacks like a duck ,it must be a duck.如果行为像鸭子，不管他是什么，就把他看做鸭子。根本不考虑一个对象属于什么类，只关心它有什么样的行为（它有哪些方法），这就是Duck Typing.静态语言的输出一般都限定了类型，如果想要输出其他类型的，就要重新写代码。但是动态语言不关心类型。 ` #使用stringIO类库require ‘stringio’ #生成stringIO对象out = StringIO() #和文件一样输出log_puts(out, “message”) #表示字符串结果puts out.string`s]]></content>
  </entry>
  <entry>
    <title><![CDATA[多重继承和面向对象]]></title>
    <url>%2F2018%2F10%2F26%2F%E6%9D%BE%E6%9C%AC%E7%9A%84%E7%A8%8B%E5%BA%8F%E4%B8%96%E7%95%8C%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[关于多重继承 单一继承：继承的类被限定为一个 多重继承：把单一继承自然地扩展，一个类可以继承多个类的功能。 LSP（Liscov Substutution Principle）：子类对象拥有父类所有属性，可以当做父类对象来处理 多重继续引发的问题： 类关系复杂化（处理好优先级） 继承功能名字重复 Ruby的Mix-in：第二个父类开始的类要满足一下条件 不能单独生成实例的抽象类 不能继承Mix-in以外的类 解决名字重复： 给父类定义优先级：重复的时候使用优先级高的父类属性。Common Lisp Object System（CLOS）提供的功能在继承数据类型时很有效。 把重复的名字替换掉：Eiffel使用的就是这种方法，在模块继承时用这种方法很有效，其缺点就是写程序时很复杂。 指定使用类的名字：C++用的就是这种方法，这也是继承模块时有效的方法，缺点是本来不需要指定类名的情况现在却要指定。 Ruby中多重继承举例：比较使用和不使用Mix-in的区别这里的LockingMixin可以对任意的类提供lock功能，在这里，给Printer类增加了lock功能，在spool方法中调用了lock方法。12345678910111213141516171819moudle LockingMixin def lock … end def unlock … endEndclass Printer&lt;Device include LockingMixin def spool(text) lock … unlock … endEnd 下面是没有Mix-in的程序，这里增加了实现lock功能的对象初始化，添加了Lock方法，还要定义很多方法的委托调用12345678910111213141516171819202122232425class Lock def lock … end def unlock … endendClass Printer&lt;Device def initialize @lock = lock.new end def lock @lock.lock end def unlock @lock.unlock end def spool(text) @lock.lock … @lock.unlock endend 面向对象面向对象的编程 数据抽象的研究 人工智能领域中的知识表现（框架模型） 仿真对象的管理方法（Simula） 并行计算模型（Actor） 结构化编程 面向对象编程是结构化编程的延伸。结构化编程基本上实现了控制流程的结构化，但是程序流程虽然结构化了，要处理的数据并没有被结构化。面向对象的设计方法是在结构化编程对控制流程实现了结构化，又加上了对数据的结构化。 对象的模板-类面向对象编程语言的共通： 不需要知道内部的详细处理就可以进行操作（封装，数据抽象） 根据不同的数据类型自动选择适当的方法（多态性） 大部分面向对象编程语言都有类和继承两个基本特性。类是对象的模板，通过类可以把同一类的对象管理起来。 抽象化不用考虑内部处理的黑盒化（降低程序复杂度的有效方法） 利用模块的手段-继承避免重复的方法就是继承 规格继承 从外部看到类的功能 实现继承 继承功能的实现方法]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[h文件和c文件的区别]]></title>
    <url>%2F2018%2F10%2F24%2Fh%E6%96%87%E4%BB%B6%E5%92%8Cc%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[好久没看C了，本来就忘得一干二净的，一脸懵逼的看着zend。 关于.c 和 .h 的区别 子程序不要定义在.h中。函数定义要放在.c中，而.h只做声明.否则多引用几次，就会发生函数重复定义的错误。 .h只做声明，编译后不产生代码 这样做目的是为了实现软件的模块化，使软件结构清晰，而且也便于别人使用你写的程序，纯粹用 C 语言语法的角度，你当然可以在 .h 中放任何东西，因为 #include 完全等价 于把 .h 文件 Ctrl-C Ctrl-V 到 .c 中,.h 中应该都是一些宏定义和变量、函数声明，告诉别人你的程序“能干什么、该怎么用”..c 中是所有变量和函数的定义，告诉计算机你的程序“该怎么实现” 当然，如果一个 .h 被多个 .c 包含,而且 .h 中有对象（变量或函数）的定义，就会发生重复定义的错误了.声明可以无穷多次，定义只能一次 一般来说，一个C文件应该是一个模块,如果你的程序仅仅有一个模块（仅仅一个C文件），就可以不用建立H文件了。否则你的模块肯定不是独立的，你的模块里面的实现要被别的模块调用。这个时候你最好生成一个头文件(H文件)，在头文件里面可以声明你的那些函数是公共的。当别的模块包含你的头文件后，就可以使用你的公共声明了。 一个C对应一个H，这样管理起来方便,比如你有一个”feed_dog.c”,那么就再添加一个”feed_dog.h”：123#ifndef _feed_dog_h#define _feed_dog_hextern void feed_dog(void);#endif 其实在H文件里写函数也无所谓，只是不符合习惯而已。只要按照以上的格式写，一个H文件添加多少次都无所谓， 只是一种约定,在编译器里面，.c和.h是没有区别的，.c和.h如何使用完全取决于程序员,不过为了你的程序以后还能看懂而且别人也能看懂,请遵守普遍的约定,这些约定前面的大虾们已经讲了很多了.这个就象汽车在马路上要靠右行使一样,是人为约定,汽车(编译器)本身并不知道自己是在靠左还是靠右行使.如果你喜欢,还可以用任意后缀命名源文件和头文件,但这样干可能会导致集成编译和调试环境罢工,你只好自己写makefile文件了. 为了生成一个最终的可执行文件，就需要一些目标文件，也就是需要C文件，而这些C文件中又需要一个main.函数作为可执行程序的入口，那么我们就从一个C文件入手，假定这个C文件内容如下： 123456#include &lt;stdio.h&gt; #include &quot;mytest.h&quot;int main(int argc,char **argv) &#123; test = 25; printf(&quot;test.................%d\n&quot;,test); &#125; 头文件内容如下：1int test; 现在以这个例子来讲解编译器的工作：1.预处理阶段：编译器以C文件作为一个单元，首先读这个C文件，发现第一句与第二句是包含一个头文件，就会在所有搜索路径中寻找这两个文件，找到之后，就会将相应头文件中再去处理宏，变量，函数声明，嵌套的头文件包含等，检测依赖关系，进行宏替换，看是否有重复定义与声明的情况发生，最后将那些文件中所有的东东全部扫描进这个当前的C文件中，形成一个中间“C文件”. 2.编译阶段，在上一步中相当于将那个头文件中的test变量扫描进了一个中间C文件，那么test变量就变成了这个文件中的一个全局变量，此时就将所有这个中间C文件的所有变量，函数分配空间，将各个函数编译成二进制码，按照特定目标文件格式生成目标文件，在这种格式的目标文件中进行各个全局变量，函数的符号描述，将这些二进制码按照一定的标准组织成一个目标文件. 3.连接阶段，将上一步成生的各个目标文件，根据一些参数，连接生成最终的可执行文件，主要的工作就是重定位各个目标文件的函数，变量等，相当于将个目标文件中的二进制码按一定的规范合到一个文件中. 再回到C文件与头文件各写什么内容的话题上：理论上来说C文件与头文件里的内容，只要是C语言所支持的，无论写什么都可以的，比如你在头文件中写函数体，只要在任何一个C文件包含此头文件就可以将这个函数编译成目标文件的一部分（编译是以C文件为单位的，如果不在任何C文件中包含此头文件的话，这段代码就形同虚设），你可以在C文件中进行函数声明，变量声明，结构体声明，这也不成问题！！！ 那为何一定要分成头文件与C文件呢？又为何一般都在头件中进行函数，变量声明，宏声明，结构体声明呢？而在C文件中去进行变量定义，函数实现呢？？原因如下： 1.如果在头文件中实现一个函数体，那么如果在多个C文件中引用它，而且又同时编译多个C文件，将其生成的目标文件连接成一个可执行文件，在每个引用此头文件的C文件所生成的目标文件中，都有一份这个函数的代码，如果这段函数又没有定义成局部函数，那么在连接时，就会发现多个相同的函数，就会报错 2.如果在头文件中定义全局变量，并且将此全局变量赋初值，那么在多个引用此头文件的C文件中同样存在相同变量名的拷贝，关键是此变量被赋了初值，所以编译器就会将此变量放入DATA段，最终在连接阶段，会在DATA段中存在多个相同的变量，它无法将这些变量统一成一个变量，也就是仅为此变量分配一个空间，而不是多份空间，假定这个变量在头文件没有赋初值，编译器就会将之放入BSS段，连接器会对BSS段的多个同名变量仅分配一个存储空间 3.如果在C文件中声明宏，结构体，函数等，那么我要在另一个C文件中引用相应的宏，结构体，就必须再做一次重复的工作，如果我改了一个C文件中的一个声明，那么又忘了改其它C文件中的声明，这不就出了大问题了，程序的逻辑就变成了你不可想象的了，如果把这些公共的东东放在一个头文件中，想用它的C文件就只需要引用一个就OK了！！！这样岂不方便，要改某个声明的时候，只需要动一下头文件就行了 4.在头文件中声明结构体，函数等，当你需要将你的代码封装成一个库，让别人来用你的代码，你又不想公布源码，那么人家如何利用你的库呢？也就是如何利用你的库中的各个函数呢？？一种方法是公布源码，别人想怎么用就怎么用，另一种是提供头文件，别人从头文件中看你的函数原型，这样人家才知道如何调用你写的函数，就如同你调用printf函数一样，里面的参数是怎样的？？你是怎么知道的？？还不是看人家的头文件中的相关声明啊！！！当然这些东东都成了C标准，就算不看人家的头文件，你一样可以知道怎么使用 程序源码中”.h”文件与”.c”文件有什么区别呀?? 在一个程序源码中,看到了udp.h文件又看到了udp.c文件,不知道这两者是什么关系呀?又有何区别呢? .c就是C语言系列的源文件,以文本形式存在,而.h系列则是头文件,即C系列中存放函数和全局变量的文件,因为C中的函数是被封装起来的,即无法看到其代码. 头文件与之实现文件的的关系关于两者以前的关系,要从N年以前说起了~ long long ago,once aupon a time …….那是一个被遗忘的年代,在编译器只认识.c(.cpp))文件，而不知道.h是何物的年代。那时的人们写了很多的.c(.cpp)文件，渐渐地，人们发现在很多.c(.cpp)文件中的声明语句就是相同的，但他们却不得不一个字一个字地重复地将这些内容敲入每个.c(.cpp)文件。但更为恐怖的是，当其中一个声明有变更时，就需要检查所有的.c(.cpp)文件，并修改其中的声明,啊~简直是世界末日降临! 终于，有人（或许是一些人）再不能忍受这样的折磨，他（们）将重复的部分提取出来，放在一个新文件里,然后在需要的.c(.cpp)文件中敲入#include XXXX这样的语句。这样即使某个声明发生了变更，也再不需要到处寻找与修改了—世界还是那么美好！ 因为这个新文件，经常被放在.c(.cpp)文件的头部，所以就给它起名叫做“头文件”，扩展名是.h.从此，编译器（其实是预处理器）就知道世上除了.c(.cpp)文件，还有个.h的文件，以及一个叫做#include命令。 虽然后来又发生很多的变化，但是这样的用法一直延续至今，只是时日久远了，人们便淡忘了当年的缘由罢了。 提到了头文件,就说说它的作用吧~林锐GG写的高质量C/C++编程上头文件的作用的简短描述: （1）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。 （2）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。 预处理是编译器的前驱,作用是把存储在不同文件里的程序模块集成为一个完整的源程序.#include本身只是一个简单的文件包含预处理命令,即为把include的后面文件放到这条命令这里,除此之外,没有其它的用处(至少我也样认为).我对乾坤一笑兄的观点,十分赞同,基础的东东一定要弄明白.我下面就乾坤一笑兄的例子做讲,完备他的一些让人迷惑不解的时候~例子: 12345678910111213//a.hvoid foo();//a.c#include &quot;a.h&quot; //我的问题出来了：这句话是要，还是不要？void foo()&#123; return;&#125;//main.c#include &quot;a.h&quot;int main(int argc, char *argv[])&#123; foo(); return 0;&#125; 针对上面的代码，请回答三个问题： a.c 中的 #include “a.h” 这句话是不是多余的？1.为什么经常见 xx.c 里面 include 对应的 xx.h？2.如果 a.c 中不写，那么编译器是不是会自动把 .h 文件里面的东西跟同名的 .c 文件绑定在一起？3.第三个问题我给他改了一下:如果 a.c 中不写include&lt;&gt;，那么编译器是不是会自动把 .h 文件里面的东西跟同名的.c文件绑定在一起？ 下面是乾坤一笑的原话: 从C编译器角度看，.h和.c皆是浮云，就是改名为.txt、.doc也没有大的分别。换句话说，就是.h和.c没啥必然联系。.h中一般放的是同名.c文件中定义的变量、数组、函数的声明，需要让.c外部使用的声明。这个声明有啥用？只是让需要用这些声明的地方方便引用。因为 #include “xx.h” 这个宏其实际意思就是把当前这一行删掉，把 xx.h 中的内容原封不动的插入在当前行的位置。由于想写这些函数声明的地方非常多（每一个调用 xx.c 中函数的地方，都要在使用前声明一下子），所以用 #include “xx.h” 这个宏就简化了许多行代码——让预处理器自己替换好了。也就是说，xx.h 其实只是让需要写 xx.c 中函数声明的地方调用（可以少写几行字），至于 include 这个 .h 文件是谁，是 .h 还是 .c，还是与这个 .h 同名的 .c，都没有任何必然关系。 这样你可能会说：啊？那我平时只想调用 xx.c 中的某个函数，却 include了 xx.h 文件，岂不是宏替换后出现了很多无用的声明？没错，确实引入了很多垃圾 ，但是它却省了你不少笔墨，并且整个版面也看起来清爽的多。鱼与熊掌不可得兼，就是这个道理。反正多些声明（.h一般只用来放声明，而放不定义，参见拙著“过马路，左右看”）也无害处，又不会影响编译，何乐而不为呢？翻回头再看上面的3个问题，很好解答了吧？ 它的解答如下:答：1.不一定。这个例子中显然是多余的。但是如果.c中的函数也需要调用同个.c中的其它函数，那么这个.c往往会include同名的.h，这样就不需要为声明和调用顺序而发愁了（C语言要求使用之前必须声明，而include同名.h一般会放在.c的开头）。有很多工程甚至把这种写法约定为代码规范，以规范出清晰的代码来。2.答：1中已经回答过了。3.答：不会。问这个问题的人绝对是概念不清，要不就是想混水摸鱼。非常讨厌的是中国的很多考试出的都是这种烂题，生怕别人有个清楚的概念了，绝对要把考生搞晕。 在此里要明确一点,编译器是按照编译单元进行编译的,所谓的编译单元,是指一个.c文件以及它所include的所有.h文件.最直观的理解就是一个文件,一个工程中可以包含很多文件,其中有一个程序的入口点,即我们通常所说的main()函数(当然也可以没有这个函数,程序照样能启动,详细见我的blog中).在没有这个程序入口点的情况下,编译单元只生成目标文件object file(.o文件,windows下叫做.obj). 这个例子中总共包含了二个编译单元,分别是a.c,main.c,按照我所说的,在编译阶段只是生成各自的.o文件.这个阶段不和其它的文件发生任何的关系.而include这个预处理指令发生在预处理阶段(早先编译阶段,只是编译器的一个前驱处理程序)..h .c不见得是浮云,脱离了编译器谈这些没有任何的意义,抛开更深层次的这些,比如说,OS如何启动这个文件,PE结构(linux 下为elf)等等编译器首先要识别这个文件才可能去编译它,这是前提.如果你改了它的扩展名那么你的编译器还能认识它吗~上升到一个更高的层次上看待这个问题,XX兄说的也不错~我想XX兄说的意思就是两者不可因为名字相同就认为两者有什么关系,名字是可以随便的~ 两者之间的联系(拿我举个例子,一个数据表如果多于30个字段,我就觉得头大了,现在弄的表有的多达上百个字段,真希望那位高人研究出什么好的方法来~,也让我们的世界美好一些~)乾坤一笑的第三个问题很有代表性,多次在网上看到,现在的编译器绝对没有那么智能,而且也没有必须那么做.下面我们主要聊聊编译器的处理过程.(我想初学者有疑问的正在于此,即是对于编译过程.h .c(.cpp)的变化不太了解,)下面我说举个简单的例子来聊聊~例子如下: 12345678910111213//a.hclass A&#123;pubic: int f(int t);&#125;;//a.cpp#include &quot;a.h&quot;int A::f(int t)&#123; return t;&#125;//main.cpp#include &quot;a.h&quot;void main()&#123; A a; a.f(3);&#125; 在预处理阶段,预处理器看到#include”文件名”就把这个文件读进来,比如它编译main.cpp，看到#include “a.h”，它就把a.h的内容读进来，它知道了，有一类A，包含一个成员函数f，这个函数接受一个int型的参数，返回一个int型的值。 再往下编译很容易就把A a这行读懂了，它知道是要拿A这个类在栈上生成一个对象。 再往下，它知道了下面要调用A的成员函数f了，参数是3，由于它知道这个函数要一个整形数用参数，这个3正好匹配，那就正好把它放到栈上，生成一条调用f(int)函数的指令（一般可能是一句call），至于这个f(int)函数到底在哪里，它不知道，它留着空，链接时再解决。它还知道f(int)函数要返回一个int，所以也许它也为这一点做好了准备（在例子中，我们没用这个返回值，也许它就不处理）。 再往下到文件末尾了main.cpp编译好了，生成了main.obj。整个编译过程中根本就不需要知道a.cpp的内容。同理，编译器再编译a.cpp，把f()函数编译好，编译a.cpp时，它也不用管别的，把f()编译好就行了。生成了a.obj。最后一步就是链接的阶段了，链接器把项目中所有.cpp生成的所有.obj链接起来，在这一步中，它就明确了f(int)函数的实现所在的地址，把main.obj中空着的这个地址位置填上正确的地址。最终生成了可执行文件main.exe。 明白了吗?不明白那就多说几句了,我们在学编译原理的时候都知道,编译器是分阶段进行的,每一个阶段将源程序从一种表示转换成另一种表示,一般情况下都进行如下顺序:源程序-&gt;词法分器-&gt;语法分析器-&gt;语义分析器-&gt;中间代码生成器-&gt;代码优化器-&gt;代码生成器-&gt;目标程序. 其中这中间6项活动都要涉及的两项主要活动是:符号管理器与错误处理器. 归根原因,这里有一个叫做符号表的东东在里面让你着魔一样不明白,其实符号表是一个数据结构.编译器的基本一项功能就是要记录源程序中使用的标识符并收集与每个标识符相关的各种属性信息.属性信息表明了该标识符的存储位置/类型/作用域(在那个阶段有效)等信息,通俗的说一下就是,当编译器看到一个符号声明时,例如你的函数名它就会把它放到这个符号表中去登记一下~符号表里存放着你的函数的入口地址,参数个数,返回信息等等一堆东西~而在联接阶段主要是处理工程中的符号表与调用对应处理关系,即我们通常所说的解引用.经过前面的,不知明白与否? 最后引用一下XXX兄的结尾三点:搞清楚语法和概念说易也易，说难也难。窍门有三点：1.不要晕着头工作，要抽空多思考思考，多看看书；2.看书要看好书，问人要问强人。烂书和烂人都会给你一个错误的概念，误导你；3.勤能补拙是良训，一分辛苦一分才； 如果认为.c和.h文件是仅仅名字不一样难免理解得肤浅了点.有op的历史看来,语言的发展是趋向与oop..h文件的出现.有点类的性质在里边..h文件的隐蔽性好.这个道理不难发现.只要大开c自己的.h文件看看,就很明显了.所以,我同意XXX兄认为乾坤一笑的肤浅.但是,从另外一个方面看.:(至于编译器的实现.我还没了解.不过.我相信.象)12345//a.cpp #include &quot;a.h&quot; int A::f(int t) &#123; return t; &#125; 这样的程序不会出现吧….呵呵.所以现在的人要理解.h和.c简单化.也有点历史和时代的影响. 现在总结一下:1.头文件可以预先告诉编译器一些必要的声明,让编译器顺利进行下去,在连接实现以前.未必出现实际的定义. 头文件的意义在a.使得程序简明,清晰.b.避免了重复编写相同的声明代码.2.**.c和**.h文件没有必然的联系. 文章来源：.c和.h文件的区别(头文件与之实现文件的的关系~ )]]></content>
      <categories>
        <category>小概念</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[世界这么大（看心情更）]]></title>
    <url>%2F2018%2F10%2F24%2F%E4%B8%96%E7%95%8C%E8%BF%99%E4%B9%88%E5%A4%A7%2F</url>
    <content type="text"><![CDATA[这些年，一直在路上。 一直以来，嗯，基本上旅游都是自己一个人，看到很多美景，那时候就在想，以后要带小他一起去赏这片朕打下的江山。 我要带小他去看海边日落，去山顶看日出，去沙滩上奔跑，去山间漫步，去成都吃火锅，去看大草原，去新疆吃羊肉串，去泰国吃水果，去巴西看美女，去斐济度假，去埃及看金字塔，去沙漠骑骆驼，在海边的度假屋里吹着海风看日出日落，躺在沙滩上看云卷云舒，在世界的尽头看极光，在成都的小巷子里寻觅美食，在小岛上看漫天的星空，在大草原上策马奔腾。 看心情游玩，累了就停下了歇着，手牵手躺在柔软的床上。 我喜欢旅游，背上包，带着相机，拖着行李箱就走。高中毕业后，感受到了自由的气息，记得那年暑假，想要来一场毕业旅行，但是父母不放心一个女孩子家家的到处跑，最后也只能约了三个小伙伴一起去爬黄山了，在西递宏村赏赏夜景。也是从那时开始，就想赶紧长大，这样就可以一个人去旅行了。 大学黄山 西递宏村可能是性格原因吧，不太习惯和情侣或者其他人一起出去旅游，还是一个人最舒服，累了，就停下来休息，想玩就去玩，自由自在的。唯一麻烦的就是拍照了，一个人拍照大部分都是自拍，那个时候手机像素还很渣，很多美景也只能沉淀在记忆中了，一直想着买个单反，把这个美好的世界装进我的相机中。 十九岁那年，一心想出去玩，老爸老妈看着我召集了三个小伙伴，才放心让我蹦跶，揣着一丢丢money，就奔赴黄山了，之前毕业后班级组织过一次漂流，好像也是在那，记忆不是很清楚了。这次去的人比较少，去之前仔细的规划了路程，不过还是没什么经验，宾馆什么的也没有提前预定，还好人不是很多。非常幸运的是，在去的大巴上，坐在我旁边的一个小伙子和我聊天，发现我是去黄山玩的，超级热心的给我联系了住宿的地方，打了半折，还记得那个双人间是八十一晚，很优惠了，超级nice。 想着去黄山顶上看日出，但是没有买帐篷，山顶的住宿又特别贵，最后放弃了，我想，后面有时间，还是要去看看，五岳泰山，黄山，都要攀登下。当初年少，还想要攀爬珠穆朗玛峰，现在想想，真逗。 估计我上辈子是个猴子，爬黄山的时候，完全没有想象中的累，蹦蹦跳跳的上去了，下来的时候，为了赶时间，一路上都是跑下去的，现在回想起来，都觉得自己强悍到不行，完全没想过摔跤，同行的小伙伴为了看松鼠，一个不留神摔了一跤，膝盖都流血了，吓坏我了，后面也没跑了。看着黄山阶梯上的挑脚夫，真佩服，很多人没什么包袱都爬不动，但是他们挑着那么多东西还走那么多。 夜晚的西递宏村还是很好看的，徽派建筑总是那么的古色古香，有那么刹那间以为自己穿越了。趁着傍晚，把一条小街逛了一遍，尝了各种小吃，还品尝了他们自家酿的酒，蛮好喝的，用竹子装的，回家的时候，还给家人带了一些，哈哈哈。 自从毕业后，感觉身体没有以前那么灵活了，所以还是要多运动。后来步入大学，哇，脱了缰的哈士奇，可以学跳舞了，可以练习书法了，可以看帅哥了，真好。 上海大一那年吧，老爸老妈还在老家吃喝玩乐，我买了张票就去上海了，那是第一次开始一个人的旅途，带着孤独出发，去知会好友，一路上充斥着欢快，窗外的景色也格外的自由，后来一发不可收拾。心情不好的时候，或者找不到方向的时候，就会背上包，来一场说走就走的旅程。 生活这么美好，何必拘束在一个圈中，出来看看，才发现还有更多好玩的事，还有更多美景等着本姑凉去赏。 后来一发不可收拾，还好没钱，不然估计要全世界各地浪了。经常和老爸老妈说，你们没事也出去旅游啊，但是没想到又被喂了一把狗粮，扎心。我妈说：“我对旅游不是很感兴趣，只要牵着你爸的手，就算是老家的山里游一游，我都非常的舒服。”我：“……”.(你们开心就好，不要再喂我狗粮了啊！) 南京大一国庆那年，还是太年轻，和高中的小花们（闺蜜们）相约南京，从此下定决心国庆放假家里七日游。那人头看的叫一个过瘾，各式各样的人头，黑的，红的，白的，黄的，绿的。。。。从那次之后，对南京有了深深的恐惧，人太多了，还是喜欢错开高峰期去人少的地方安安静静的玩。在南京游玩的时候，让我记忆尤深的是一对年纪比较大的夫妻，属于爷爷奶奶辈的，那个奶奶真的好有气质，爷爷应该是一个摄影爱好者，奶奶作为model，爷爷一直帮她拍照，令人羡慕。后来我们几个找那个爷爷帮忙拍合照，一个小手机，被他拍出了单反的感觉，可见一斑。 扬州从南京玩了一圈之后就转向扬州，顺道去看奶奶。扬州夜晚的秦淮河还是蛮热闹的，人来人往，商贩们在河的两岸叫唤着，卖着各式各样的小吃和点心。安安静静的走着，吹着风。 但是没有逛扬州的瘦西湖，对于湖，一直以来没多大的兴趣，不如去看海。 常州大二那年，想我的小伙伴了，于是买张火车票就去了她的大学，两人吃吃喝喝，常州的臭豆腐还是蛮好吃的。 苏州同里常州除了一个恐龙乐园好像就没啥好玩的了，于是我们二人转战苏州，去了同里古镇。在那里吃吃喝喝。话说这几年去了好多古镇，感觉都大差不差，没什么区别，倒是对凤凰古镇和丽江古城充满了兴趣，打算啥时有时间去走一走。 天柱山从苏州回来，安静了一段时间，好像是因为要考试了，嗯，不能挂。学还是要好好上的，毕竟一年学费不便宜啊。 不过还是忍不住想浪，某个周末，带上了大欢（室友），她也喜欢爬山，我们两人坐上火车就去了安庆爬山，其实这些年，在很多地方玩，也非常感谢我的朋友们，虽然都是一个人出行，但是有很多朋友在这些城市招待我。有非常要好的闺蜜，有联系不多的同学，还有没见过面的网友，还有游玩期间结交的朋友。真的非常温暖了，这些朋友，让我觉得生活总是那么的美好，对人对事都充满了感激。（果然是年纪大了，没忍住就感慨了） 天柱山和黄山区别还是很大的，在黄山运气好的话，可以感受一年四季的变化，从山底到山顶。天柱山基本都是石头，而且也蛮陡峭的，不过单纯作为爬山来说，还是可以去溜达溜达的。 在回来的火车上，我又做了一件超级逗的事情，那时坐在我对面的一个哥们，他的手超级好看，就是那种可以做手模的，然后呢，他的火车票放在桌子上，我刚开始不知道是他的，就看了看，感觉姓氏好少见，就记住了，然后，哈哈哈哈，就上网搜了下（这是个坏习惯，不尊重别人隐私。但是对于不了解的我已经习惯了搜索。），然后现在的信息又没有什么隐秘，只要想了解的，就能查到想看的，于是就查到了这位仁兄的qq，抱着好奇心，就加了下，然后！！！哈哈哈哈，他居然也记得我，我们聊得还很开心。神奇的大千世界，不过也就那几天聊了，后面忙起来就没联系过了，哈哈哈。纯粹是一时兴起，记得最初初中高中对电脑黑客啥感兴趣，大概就是觉得能做一切想做的事，能够查到很多信息，还能发现好玩的东西。不过后来上了大学，就转向了应用，感觉能做出各种牛逼的产品，佩服佩服。 芜湖回到寝室闲置了一段时间，又坐上火车去芜湖找小伙伴浪了，几朵小花一起逛吃逛吃，说实话，芜湖的小吃真的不错，那什么酒酿元宵，还有大学城那一片小摊子，都有一堆好吃的，上次出去游玩，遇到一哥们，聊起芜湖，他说那边有一种小吃超好吃（完了，想不起名字了），反正能吃好多。 话说芜湖的方特一直没去玩，当初踹了钱，兴致勃勃去玩，结果在芜湖呆了三天，三天下雨，我刚到家，雨停了。那叫一个气啊。后来又过了一段时间，又踹了钱去，结果！又下雨，等我到家，雨又停了！算你狠，姐姐不玩了。 青岛 日照 大连青岛的体验是难以言说的，和爷爷去玩的，暑假在家闲的不行，爷爷的小卖部商家正好有活动，抱团去玩了青岛日照大连，一路上都是上了年纪的叔叔阿姨爷爷奶奶，深深的感受到了跟团的可怕。从那以后，宁愿一个人做攻略，都不愿跟团，简直跟打仗似的，早上四五点就起来赶车，反正我觉得基本都是在大巴上度过这段旅程的。而且还带着我们去购物，那些东西又不好看不好吃，糟心。 真心觉得要是出去玩，要么自由行，要么做攻略，千万不要跟团，妈呀，噩梦。 武汉记得又一次，闺蜜和我视频说失恋了，心情不好，当晚就打算买火车票去武汉看她，后来没票了，然后又要考试就没去了。 直到后面时间闲置了下来，就买了张票去武汉了，武汉还是蛮不错的，当时下火车买地铁票，忘记带钱了，旁边有个哥们人很好，我问他借钱，说支付宝给他，结果地铁下面信号差到爆，一直出不来，他就没收钱了，好人一生平安。 和闺蜜把光谷逛了一遍，她还带我吃了她们学校附近的热干面，味道真不错，后来来上海，大学路那边有一家小晴川热干面味道还蛮正宗的。那会儿在那边上班的时候经常去吃，记得第一次吃，没吃饱，让老板再来一碗，没想到善良的老板又给我加了一碗面，后来我带同样大胃口的同事去吃，每次我两都是再来一碗，哈哈哈哈哈哈哈，感觉老板内心是很忧桑的，两个大吃货。 之前想去武大看看樱花，不过人那么多，后来也没去。对，武汉的周黑鸭不错，麻麻的，口味甚好，回去还带了不少。 武汉的小吃还是蛮多的 欢乐谷开始实习乌镇杭州太湖工作成都毕棚沟色达佛学院四姑娘山雪山马来西亚-沙巴东极岛]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的哈希表实现]]></title>
    <url>%2F2018%2F10%2F23%2FPHP%E7%9A%84%E5%93%88%E5%B8%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[PHP的哈希实现PHP内核中的哈希表是十分重要的数据结构，PHP的大部分语言特性都是基于哈希表实现的，例如：变量的作用域，寒暑表，类的属性，方法等，zend引擎内部的很多数据都是保存在哈希表中的。 数据结构及说明PHP中的哈希表就是使用链表来存储哈希到同一个槽位的数据，zend为了保存数据之间的关系使用了双向链表来链接元素。 哈希表结构PHP中的哈希表实现在Zend/zend_hash.c中，先看看PHP使用如下两个数据结构来实现哈希表，HashTable结构体用于保存整个哈希表需要的基本信息，而Bucket结构体用于保存具体的数据内容，如下：1234567891011121314151617typedef struct _hashtable&#123; uint nTableSize; //hash Bucket 的大小。最小为8，以2x增长 uint nTableMask; //nTableSize-1,索引取值的优化 uint nNumOfElements; //hash Bucket中当前存在的元素个数，count（）函数会直接返回此值。 ulong nNextFreeElement; //下一个数字索引的位置 Bucket *pInternalPointer;//当前遍历的指针（foreach比for快的原因之一） Bucket *pListHead;//存储数组头元素指针 Bucket *pListTail;//存储数组尾元素指针 Bucket **arBuckets;//存储hash数组 dtor_func_t pDestructor; //在删除元素时执行的回调函数，用于资源的释放 zend_bool persistent;//指出了Bucket内存分配的方式，如果persistent为True,则使用操作系统本身的内存分配函数为Bucket分配内存，否则使用PHP的内存分配函数。 unsigned char nApplyCount;//标记了当前hash Bucket被递归访问的次数，防止多次递归。 zend_bool bApplyProtection;//标记当前hash桶允许不允许多次访问，不允许时，最多只能递归3次#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; nTableSize字段用于标示哈希表的容量，哈希表的初始容量最小为8。首先看看哈希表的初始化函数: 12345678910111213141516171819202122232425262728ZEND_API int _zend_hash_init(HashTable *ht, uint nSize, hash_func_t pHashFunction, dtor_func_t pDestructor,zend_bool persistent ZEND_FILE_LINE_DC)&#123; uint i = 3; if(nSize &gt;= 0x80000000); /* prevent overflow*/ ht-&gt;nTableSize = 0x80000000;&#125;else&#123; while((1U &lt;&lt; i)&lt; nSize)&#123; i++; &#125; ht-&gt;nTableSize = 1 &lt;&lt; i;&#125;ht-&gt;nTableMask = ht-&gt;nTableSize - 1;/* Uses ecalloc() so that Bucket* == NULL */if (persistent )&#123; tmp = (Bucket **)calloc(ht-&gt;nTableSize, sizeof(Bucket *)); if(!tmp)&#123; return FALLURE; &#125; ht-&gt;arBuckets = tmp;&#125;else&#123; tmp = (Bucket **) ecalloc_rel(ht-&gt;nTableSize, sizeof(Bucket *)); if(tmp)&#123; ht-&gt;arBuckets = tmp; &#125; return SUCCESS;&#125; 如果设置出事大小为10 ，则上面的算法将会将大小调整为16，也就是始终将大小调整为接近初始大小的2的整数次方。 为什么会做这样的调整？我们先看看HashTable将哈希值映射到槽位的方法，上一小节我们使用了取模的方式来将哈希值 映射到槽位，例如大小为8的哈希表，哈希值为100， 则映射的槽位索引为: 100 % 8 = 4，由于索引通常从0开始， 所以槽位的索引值为3，在PHP中使用如下的方式计算索引： 12H = zend_inline_hash_func(arKey, nKeyLength);nIndex = h &amp; ht-&gt;nTableMask; 从上面的_zend_hash_int()函数可知，ht-&gt;nTableMask的大小为ht-&gt;nTableSize-1.这里使用&amp;操作而不是使用取模，是因为相对来说，驱魔操作的消耗和按位与的操作大很多。 mask的作用就是将哈希值映射到槽位所能存储的索引范围内。 例如：某个key的索引值是21， 哈希表的大小为8，则mask为7，则求与时的二进制表示为： 10101 &amp; 111 = 101 也就是十进制的5。 因为2的整数次方-1的二进制比较特殊：后面N位的值都是1，这样比较容易能将值进行映射， 如果是普通数字进行了二进制与之后会影响哈希值的结果。那么哈希函数计算的值的平均分布就可能出现影响。 设置好哈希表大小之后就需要为哈希表申请存储数据的空间了，如上面初始化的代码，根据是否需要持久保存而调用了不同的内存申请方法，HashTable中的nNumOfElemnets字段很好理解，每插入一个元素或者unset删除元素时会更新这个字段，这样在进行count（）函数统计数组元素个数时就能快速的返回。 nNextFreeElement字段非常有用： 12345678910&lt;?php$a = array(10=&gt;’Hello);$a[] = ‘TIPI’;var_dump($a);//outputarray(2)&#123; [10]=&gt;string(5) “Hello” [11]=&gt;string(5) “TIPI”&#125; PHP中可以不指定索引值向数组中添加元素，这是将默认使用数字作为索引，和C语言中的枚举类似，而这个元素的索引到底是多少就由nNextFreeElement字段决定了，如果数组中存在了数字key，则默认使用最新使用的key+1，例如上面已经存在了作为10为key的元素，这样新插入的默认索引就是11了。 数据容器：槽位保存哈希表数据的槽位数据结构体： 1234567891011typeof struct bucket&#123; ulong h;//对char *key进行hash后的值，或者是用户指定的数字索引值 uint nKeyLength;//hash关键字的长度，如果数组索引为数字，此值为0 void *pData; //指向value。一般是用户数据的副本，如果是指针数据，则指向pDataPtr struct bucket *pListNext;//整个hash表的下一个元素 struct bucket *pListLast;//整个哈希表该元素的上一个元素 struct bucket *pNext;//存放在同一个hash Bucket内的下一个元素 struct bucket *pList;//同一个哈希bucket的上一个元素 //保存当前值所对于的key字符串，这个字段只能定义在最后，实现变长结构体。 char arkey[1];&#125;Bucket; 如上面各字段的注释。h字段保存哈希表key哈希后的值。这里保存的哈希值而不是在哈希表中的索引值， 这是因为索引值和哈希表的容量有直接关系，如果哈希表扩容了，那么这些索引还得重新进行哈希在进行索引映射， 这也是一种优化手段。 在PHP中可以使用字符串或者数字作为数组的索引。 数字索引直接就可以作为哈希表的索引，数字也无需进行哈希处理。h字段后面的nKeyLength字段是作为key长度的标示， 如果索引是数字的话，则nKeyLength为0。在PHP数组中如果索引字符串可以被转换成数字也会被转换成数字索引。 所以在PHP中例如’10’，’11’这类的字符索引和数字索引10， 11没有区别。 上面结构体的最后一个字段用来保存key的字符串，而这个字段却申明为只有一个字符的数组， 其实这里是一种长见的变长结构体，主要的目的是增加灵活性。 以下为哈希表插入新元素时申请空间的代码: 12345P = (Bucket *) pemalloc(sizeof(Bucket) - 1 + nKeyLength, ht-&gt;persistent );if(!p)&#123; return FALLURE;&#125;memcpy(p-&gt;arKey, arKey, nKeyLength); 如代码，申请的空间大小加上了字符串key的长度，然后把key拷贝到新申请的空间里。 在后面比如需要进行hash查找的时候就需要对比key这样就可以通过对比p-&gt;arKey和查找的key是否一样来进行数据的 查找。申请空间的大小-1是因为结构体内本身的那个字节还是可以使用的。 在PHP5.4中将这个字段定义成const char* arKey类型了。 上图来源于网络。 Bucket结构体维护了两个双向链表，pNext和pLast指针分别指向本槽位所在的链表的关系。 而pListNext和pListLast指针指向的则是整个哈希表所有的数据之间的链接关系。 HashTable结构体中的pListHead和pListTail则维护整个哈希表的头元素指针和最后一个元素的指针。 PHP中数组的操作函数非常多，例如：array_shift()和array_pop()函数，分别从数组的头部和尾部弹出元素。 哈希表中保存了头部和尾部指针，这样在执行这些操作时就能在常数时间内找到目标。 PHP中还有一些使用的相对不那么多的数组操作函数：next()，prev()等的循环中， 哈希表的另外一个指针就能发挥作用了：pInternalPointer，这个用于保存当前哈希表内部的指针。 这在循环时就非常有用。 如图中左下角的假设，假设依次插入了Bucket1，Bucket2，Bucket3三个元素： 1. 插入Bucket1时，哈希表为空，经过哈希后定位到索引为1的槽位。此时的1槽位只有一个元素Bucket1。 其中Bucket1的pData或者pDataPtr指向的是Bucket1所存储的数据。此时由于没有链接关系。pNext， pLast，pListNext，pListLast指针均为空。同时在HashTable结构体中也保存了整个哈希表的第一个元素指针， 和最后一个元素指针，此时HashTable的pListHead和pListTail指针均指向Bucket1。 2. 插入Bucket2时，由于Bucket2的key和Bucket1的key出现冲突，此时将Bucket2放在双链表的前面。 由于Bucket2后插入并置于链表的前端，此时Bucket2.pNext指向Bucket1，由于Bucket2后插入。 Bucket1.pListNext指向Bucket2，这时Bucket2就是哈希表的最后一个元素，这是HashTable.pListTail指向Bucket2。 3. 插入Bucket3，该key没有哈希到槽位1，这时Bucket2.pListNext指向Bucket3，因为Bucket3后插入。 同时HashTable.pListTail改为指向Bucket3。 简单来说就是哈希表的Bucket结构维护了哈希表中插入元素的先后顺序，哈希表结构维护了整个哈希表的头和尾。 在操作哈希表的过程中始终保持预算之间的关系。 简单来说就是哈希表的Bucket结构维护了哈希表中插入元素的先后顺序，哈希表结构维护了整个哈希表的头和尾。 在操作哈希表的过程中始终保持预算之间的关系。 哈希表的操作接口PHP哈希表的操作接口实现： 初始化操作，例如zend_hash_init()函数，用于初始化哈希表接口，分配空间等。 查找，插入，删除和更新操作接口，这是比较常规的操作。 迭代和循环，这类的接口用于循环对哈希表进行操作。 复制，排序，倒置，销毁等操作 本小节选取其中的插入操作进行介绍。 在PHP中不管是对数组的添加操作（zend_hash_add），还是对数组的更新操作（zend_hash_update）， 其最终都是调用_zend_hash_add_or_update函数完成，这在面向对象编程中相当于两个公有方法和一个公共的私有方法的结构， 以实现一定程度上的代码复用。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ZEND_API int _zend_hash_add_or_update(HashTable *ht, const char *arKey, uint nKeyLength, void *pData, uint nDataSize, void **pDest, int flag ZEND_FILE_LINE_DC)&#123; //。。。省略变量初始化和nKeyLength &lt;= 0 的异常处理 h = zend_inline_hash_func(arkey, nKeyLength); nIndex = h &amp; ht-&gt;nTableMask; p = ht-&gt;arBuckets(nIndex); while(p != NULL)&#123; if((p-&gt;h == h) &amp;&amp; (p-&gt;nKeyLength == nKeyLength))&#123; if(flag &amp; HASH_ADD)&#123; return FALLURE; &#125; HANDLE_BLOCK_INTERRUPTIONS(); //省略debug输出 if(ht-&gt;pDetructor)&#123; ht-&gt;pDestructor(p-&gt;pData); &#125; UPDATE_DATA(ht, p, pData, nDataSize); if(pDest)&#123; *pDest = p-&gt;pData; &#125; HANDLE_UNBLOCK_INTERRUPTIONS(); return SUCCESS; &#125; &#125; p = p-&gt;pNext;&#125;P = (Bucket *)pemalloc(sizeof(Bucket) - 1 + nKeyLength, ht-&gt;persistent );if(!p)&#123; return FALLURE;&#125;memcpy(p-&gt;arKey, arKey, nKeyLenghth);P-&gt;nKeyLength = nKeyLength;INIT_DATA(ht, p, pData, nDataSize);p-&gt;h = h;CONNECT_TO_BUCKET_DLLIST(p, ht-&gt;arBuckets[nIndex]);//Bucket双向链表操作if(pDest)&#123; *pDest = p-&gt;pData;&#125;HANDLE_BLOCK_INTERRUPTIONS();CONNECT_TO_GLOBAL_DLLIST(p, ht);//将新的Bucket元素添加到数组的链接表的最后面Ht-&gt;arBuckets[nIndex] = p;HANDLE_UNBLOCK_INTERRUPTIONS();Ht-&gt;nNumOfElements++;ZEND_HASH_IF_FULL_DO_RESIZE(ht);//如果此时数组的容量满了，则对其进行扩容return SUCCESS; 整个写入或更新的操作流程如下： 1. 生成hash值，通过与nTableMask执行与操作，获取在arBuckets数组中的Bucket。 2. 如果Bucket中已经存在元素，则遍历整个Bucket，查找是否存在相同的key值元素，如果有并且是update调用，则执行update数据操作。 3. 创建新的Bucket元素，初始化数据，并将新元素添加到当前hash值对应的Bucket链表的最前面（CONNECT_TO_BUCKET_DLLIST）。 4. 将新的Bucket元素添加到数组的链接表的最后面（CONNECT_TO_GLOBAL_DLLIST）。 5. 将元素个数加1，如果此时数组的容量满了，则对其进行扩容。这里的判断是依据nNumOfElements和nTableSize的大小。 如果nNumOfElements &gt; nTableSize则会调用zend_hash_do_resize以2X的方式扩容（nTableSize &lt;&lt; 1）。 文章来源：《深入理解PHP内核》]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的hash]]></title>
    <url>%2F2018%2F10%2F22%2FPHP%E4%B8%AD%E7%9A%84hash%2F</url>
    <content type="text"><![CDATA[hash table哈希表通常提供查找，插入，删除等操作。这些操作在最坏的情况下和链表的性能一样为O(n)。 不过通常并不会这么坏，合理设计的哈希算法能有效的避免这类情况，通常哈希表的这些操作时间复杂度为O(1)。 哈希表是一种通过哈希函数，将特定的键映射到特定值的一种数据结构，它维护键和值之间一一对应关系。 - 键(key)：用于操作数据的标示，例如PHP数组中的索引，或者字符串键等等。 槽(slot/bucket)：哈希表中用于保存数据的一个单元，也就是数据真正存放的容器。 哈希函数(hash function)：将key映射(map)到数据应该存放的slot所在位置的函数。 哈希冲突(hash collision)：哈希函数将两个不同的key映射到同一个索引的情况。 哈希表可以裂解为数组的扩展或者关联数组，数组使用数字下标来寻址，如果关键字（key）的范围较小且是数字，可以直接使用数组来完成哈希表，而如果关键字范围太大，直接使用数组就需要为所有可能的key申请空间，很多情况下是不现实的，即使空间足够，空间利用率也会很低，不理想，同时键也可能并不是数字，在PHP中尤为如此，所以人们使用一种映射函数（哈希函数）来将key映射到特定的域中。 1h(key) -&gt; index 通过合理设计的哈希函数，就能将key映射到合适的范围，因为key空间范围可以很大（例如字符串key），在映射到一个较小的空间中时可能会出现两个不同的key映射被到同一个index上的情况，这就是出现了冲突。目前解决hash冲突的方法主要有两种：链接法和开放寻址法。 链接法（PHP中hash table的哈希冲突解决方法就是链接法）链接法通过使用一个链表来保存slot值的方式来解决冲突，也就是当不同的key映射到同一个槽中的时候使用链表来保存这些值。所以使用链接表实在最坏的情况下，也就是所有的key都映射到同一个槽中了，这样哈希表就退化成了一个链表，这样的话操作链表的时间复杂度则成了O(n），哈希表的性能优势就没有了。目前大部分的哈希算法都是公开的算法，虽然目前的哈希算法都能良好的将key进行比较均匀的分布，而这个假使的前提是key是随机的，正是由于算法的确定性，这就导致了别有用心的黑客能利用已知算法的可确定性来构造一些特殊的key。让这些key都映射到同一个槽位导致哈希表退化成了单链表，导致程序的性能急剧下降，造成一些应用的吞吐能力急剧下降，尤其是对于高并发的应用影响很大，通过大量类似的请求可以让服务器遭受Dos（服务拒绝攻击）。哈希冲突利用的哈气表最根本的弱点：开源算法和哈希实现的确定性以及可预测性。这样攻击者才可以利用特殊构造的key来进行攻击，要解决这个问题的方法则是让攻击者无法轻易构造能够进行攻击的key序列。 哈希表的实现主要完成以下三点： 实现哈希函数 冲突的解决 操作接口的实现 数据结构首先需要一个容器来保存哈希表，哈希表需要保存的内容主要是保存进来的数据，同事为了方便的得知哈希表中存储的元素个数，需要保存一个大小字段，第二个需要的就是保存数据的容器了，作为实例，下面实现一个建议的哈希表，基本的数据结构主要有两个，一个用于保存哈希表本身，另外一个就是用于实际保存数据的单链表了： 1234567891011typedef struct _Bucket&#123; char *key; void *value; struct _Bucket *next;&#125;Bucket;typedef struct _HashTable&#123; int size; int elem_num; Bucket** buckets;&#125;HashTable; Key的数据类型为字符串，而存储的数据类型可以为任意类型。Bucket结构体是一个单链表，这是为了解决多个key哈希冲突的问题，当多个key映射到同一个index的时候将冲突的元素连接起来。 哈希函数实现哈希函数需要尽可能的将不同的key映射到不同的槽（slot or bucket）中，首先采用最为简单的哈希算法：将key字符串的所有字符加起来，然后以结果对哈希表的大小取模，这样索引就能落在数组索引的范围之内了。 123456789101112static int hash_str(char *key)&#123; int hash = 0; char *cur = key; while (*cur != ‘\0’)&#123; hash += *cur; ++cur; &#125; return hash;&#125;//使用这个宏来求得key在哈希表中的索引#define HASH_INDEX(ht, key) (hash_str(key)) % (ht)-&gt;size) 操作接口的实现为了操作哈希表，实现了如下几个操作接口函数：12345int hash_init(HashTable *ht);//初始化哈希表int hash_lookup(HashTable *ht, char *key, void **result);//根据key查找内容int hash_insert(HashTable *ht, char *key, void *value);//将内容插入到哈希表中int hash_remove(HashTable *ht, char *key);//删除key所指向的内容int hash_destroy(HashTable *ht); 下面开始初始化，插入，获取操作函数： 1234567891011Int hash_init(HashTable *ht)&#123; ht-&gt;size = HASH_TABLE_INIT_SIZE; ht-&gt;elem_num = 0; ht-&gt;buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *)); if(ht-&gt;buckets == NULL) return FALLED; LOG_MSG(“[init]\tsize: %I\n”,ht-&gt;size); Return SUCCESS;&#125;//初始化的主要工作是为哈希表申请存储空间，函数中使用calloc函数的目的是确保数据存储的槽为都初始化为0，以便后续在插入和查找时确认该槽是否被占用。 1234567891011121314151617181920212223242526272829303132333435363738int hash_insert(HashTable *ht, char *key, void *value)&#123; //check if we need to resize the hashtable resize_hash_table_if_needed(ht); int index = HASH_INDEX(ht, key); Bucket *org_bucket = ht-&gt;buckets[index]; Bucket *tmp_bucket = org_bucket; //check if the key exits already while(tmp_bucket)&#123; if(strcmp(key, tmp_bucket-&gt;key) == 0) &#123; LOG_MSG(“[update]\tkey: %s\n”, key); tmp_bucket-&gt;value = value; return SUCCESS; &#125; tmp_bucket = tmp_bucket-&gt;next; &#125; Bucket *bucket = (Bucket *)malloc(sizeof(Bucket));bucket-&gt;key = key;bucket-&gt;value = value;bucket-&gt;next = NULL;ht-&gt;elem_num +=1; if(org_bucket != NULL) &#123; LOG_MSG(&quot;[collision]\tindex:%d key:%s\n&quot;, index, key); bucket-&gt;next = org_bucket; &#125; ht-&gt;buckets[index]= bucket; LOG_MSG(&quot;[insert]\tindex:%d key:%s\tht(num:%d)\n&quot;, index, key, ht-&gt;elem_num); return SUCCESS;&#125; 上面这个哈希表的插入操作比较简单，简单的以key做哈希，找到元素应该存储的位置，并检查该位置是否已经有了内容， 如果发生碰撞则将新元素链接到原有元素链表头部。由于在插入过程中可能会导致哈希表的元素个数比较多，如果超过了哈希表的容量， 则说明肯定会出现碰撞，出现碰撞则会导致哈希表的性能下降，为此如果出现元素容量达到容量则需要进行扩容。 由于所有的key都进行了哈希，扩容后哈希表不能简单的扩容，而需要重新将原有已插入的预算插入到新的容器中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445static void resize_hash_table_if_needed(HashTable *ht)&#123; if(ht-&gt;size - ht-&gt;elem_num &lt; 1) &#123; hash_resize(ht); &#125;&#125; static int hash_resize(HashTable *ht)&#123; // double the size int org_size = ht-&gt;size; ht-&gt;size = ht-&gt;size * 2; ht-&gt;elem_num = 0; LOG_MSG(&quot;[resize]\torg size: %i\tnew size: %i\n&quot;, org_size, ht-&gt;size); Bucket **buckets = (Bucket **)calloc(ht-&gt;size, sizeof(Bucket *)); Bucket **org_buckets = ht-&gt;buckets; ht-&gt;buckets = buckets; int i = 0; for(i=0; i &lt; org_size; ++i) &#123; Bucket *cur = org_buckets[i]; Bucket *tmp; while(cur) &#123; // rehash: insert again hash_insert(ht, cur-&gt;key, cur-&gt;value); // free the org bucket, but not the element tmp = cur; cur = cur-&gt;next; free(tmp); &#125; &#125; free(org_buckets); LOG_MSG(&quot;[resize] done\n&quot;); return SUCCESS;&#125;//哈希表的扩容首先申请一块新的内存，大小为原来的2倍，然后重新将元素插入到哈希表中 在查找时也使用插入同样的策略，找到元素所在的位置，如果存在元素， 则将该链表的所有元素的key和要查找的key依次对比， 直到找到一致的元素，否则说明该值没有匹配的内容。 12345678910111213141516171819202122232425int hash_lookup(HashTable *ht, char *key, void **result)&#123; int index = HASH_INDEX(ht, key); Bucket *bucket = ht-&gt;buckets[index]; if(bucket == NULL) goto failed; while(bucket) &#123; if(strcmp(bucket-&gt;key, key) == 0) &#123; LOG_MSG(&quot;[lookup]\t found %s\tindex:%i value: %p\n&quot;, key, index, bucket-&gt;value); *result = bucket-&gt;value; return SUCCESS; &#125; bucket = bucket-&gt;next; &#125; failed: LOG_MSG(&quot;[lookup]\t key:%s\tfailed\t\n&quot;, key); return FAILED;&#125; PHP中数组是基于哈希表实现的，依次给数组添加元素时，元素之间是有先后顺序的， 而这里的哈希表在物理位置上显然是接近平均分布的，这样是无法根据插入的先后顺序获取到这些元素的， 在PHP的实现中Bucket结构体还维护了另一个指针字段来维护元素之间的关系 参考教材：《深入理解PHP内核》]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>小概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP之数组]]></title>
    <url>%2F2018%2F10%2F22%2FPHP%E4%B9%8B%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[了解下PHP的数组]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆波兰表达]]></title>
    <url>%2F2018%2F10%2F16%2F%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%2F</url>
    <content type="text"><![CDATA[逆波兰表示法逆波兰表示法（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。逆波兰结构由弗里德里希·鲍尔（Friedrich L. Bauer）和艾兹格·迪科斯彻在1960年代早期提议用于表达式求值，以利用堆栈结构减少计算机内存访问。逆波兰记法和相应的算法由澳大利亚哲学家、计算机学家查尔斯·汉布林（Charles Hamblin）在1960年代中期扩充 在1960和1970年代，逆波兰记法广泛地被用于台式计算器，因此也在普通公众（工程、商业和金融领域）中使用。 逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 +”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 +”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 5”与“（3 - 4）5”不相同，但后缀记法中前者写做“3 4 5 -”，无歧义地表示“3 (4 5 ) -”；后者写做“3 4 - 5 *”。 逆波兰表达式的解释器一般是基于堆栈的。 解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。 注意：逆波兰记法并不是简单的波兰表达式的反转。因为对于不满足交换律的操作符，它的操作数写法仍然是常规顺序，如，波兰记法“/ 6 3”的逆波兰记法是“6 3 /”而不是“3 6 /”；数字的数位写法也是常规顺序。 逆波兰表达式求值伪代码- while有输入符号 - 读入下一个符号X - IF X是一个操作数 - 入栈 - ELSE IF X是一个操作符 - 有一个先验的表格给出该操作符需要n个参数 - IF堆栈中少于n个操作数 - （错误） 用户没有输入足够的操作数 - Else，n个操作数出栈 - 计算操作符。 - 将计算所得的值入栈 - IF栈内只有一个值 - 这个值就是整个计算式的结果 - ELSE多于一个值 - （错误） 用户输入了多余的操作数 例子中缀表达式“5 + ((1 + 2) 4) − 3”写作5 1 2 + 4 + 3 −下表给出了该逆波兰表达式从左至右求值的过程，堆栈栏给出了中间值，用于跟踪算法。 输入 操作 堆栈 注释 5 入栈 5 1 入栈 5，1 2 入栈 5，1，2 + 加法运算 5，3 (1,2)出栈；将结果(3)入栈 4 入栈 5，3，4 * 乘法运算 5，12 (3,4)出栈；将结果(12)入栈 + 加法运算 17 (5,12)出栈；将结果(17)入栈 2 入栈 17，3 - 减法运算 14 (17,3)出栈；将结果(14)入栈 计算完成时，栈内只有一个操作数，这就是表达式的结果：14上述运算可以重写为如下运算链方法（用于HP的逆波兰计算器）：1 2 + 4 * 5 + 3 − 实际意义- 当有操作符时就计算，因此，表达式并不是从右至左整体计算而是每次由中心向外计算一部分，这样在复杂运算中就很少导致操作符错误。 - 堆栈自动记录中间结果，这就是为什么逆波兰计算器能容易对任意复杂的表达式求值。与普通科学计算器不同，它对表达式的复杂性没有限制。 - 逆波兰表达式中不需要括号，用户只需按照表达式顺序求值，让堆栈自动记录中间结果；同样的，也不需要指定操作符的优先级。 - 逆波兰计算器中，没有“等号”键用于开始计算。 - 逆波兰计算器需要“确认”键用于区分两个相邻的操作数。 - 机器状态永远是一个堆栈状态，堆栈里是需要运算的操作数，栈内不会有操作符。 - 教育意义上，逆波兰计算器的使用者必须懂得要计算的表达式的含义。 目前逆波兰的实现有： - 任何基于栈的程序语言： - Forth - Factor语言 - PostScript语言。 - 线上的逆波兰计算器 - Windows下逆波兰计算器 - Windows XP下的Microsoft PowerToy calculator - 手机逆波兰计算器开源的JAVA计算器 - Palm PDA下的逆波兰计算器 - Mac OS X计算器 - Mac OS X和iPhone下的逆波兰计算器 - Unix下的计算程序dc - 交互式JavaScript的逆波兰计算器 - Wikibooks:Ada Programming/Mathematical calculations (Ada语言中的逆波兰计算器) - Emacs的lisp lib包: calc - 基于GTK+的galculator - 表达式转换]]></content>
      <categories>
        <category>小概念</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
        <tag>维基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员职业素养之读后感]]></title>
    <url>%2F2018%2F10%2F10%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%E4%B9%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[程序员的职业素养花了几个小时，把《程序员的职业素养》看完了，刚开始以为是一本讲代码规范什么的，看了才发现，内容很给力，挺干的。我觉得工作以来，自己绝对算不上一个称职的程序员，也很不专业，一直想往专业的方向去发展，却总是事与愿违。一路走来，发现了很多自身的不足以及太多需要学习的知识，看到自己还有那么多不懂得，真棒，又可以学习新知识了。简单记录下观书笔记，以便日后查看： 专业主义 说“不” 说“是” 编码 测试驱动开发 练习 验收测试 测试策略 时间管理 预估 压力 协作 团队与项目 辅导，学徒期，技艺 最初接触编程，除了兴趣爱好之外，就是觉得coding是一件很酷炫的事，在暗黑的终端敲击着绿色白色的代码，做出各种各样的网站，还能编写app……但如果带着这样的心思工作，就很糟糕了，心猿意马，随心所欲，今天对这个感兴趣，学一点，明天对那个感兴趣，再学学，很不专业了，最后什么也做不好。 专业主义专业程序员对于程序员来说，没有什么称赞比专业更让人兴奋了。但是想要成为一个专业的程序员，对我来说，还有很长的路要走。 专业意味着责任，工作上的每一个承诺，每一件自己的任务，都要百分百负责。 这个深有体会，刚来公司那会儿，由于之前的公司就我一个技术人员，对待工作就很自由，其实那时候就应该意识到自己的错误，这样的散漫对一个刚毕业没多久的人来说，是很致命的。来到现在这家公司，当时进来负责一个开发票的模块，pm说这个需求很重要，关系到财务等各个方面，务必做好，同时也给了我一个期限，问我可不可以？对于当时的我来说，从没接触过这这方面的业务，对于技术框架也不熟悉，业务流程也不是很了解，但是还是说应该可以吧。最后的结果和书里说的大部分例子一样，完成的很糟糕，可以说非常糟糕。最初完成开发阶段之后，简单测试了几个，就提交给QA了，结果QA那边测试出各种问题，老实说，被QA说bug的时候，真的非常尴尬。而且客户测试的时候也出现各种各样的问题，除了数据的问题，最大的问题就是在开发完成之后没有对自己的代码负责，没有做极致的测试。如果开发后，对代码进行细致的测试，考虑各种情况的发生，就不会出现后面一系列的问题了。 很多想成为专业人士的程序员，都把以下几点作为小目标： 让QA找不到任何问题 要确信代码正常运行 自动化QA 最初看到自己写的那一大段代码，真的不想在上面继续修改，但事实上是应该要修改，保持自己的软件灵活可变。专业的开发人员对自己的代码和测试都极有把握，他们敢随心所欲的修改、拆分、重新组织。他们会把switch语句改成堕胎结构，或者将继承层次重构成一条“命令链”。 职业道德工作以来，接触的很多人，对当下的工作其实很不满，但是又无力改变现状，于是在遇到问题或者无所事事的时候，开始抱怨，各种抱怨。我也不例外，当时从舒适区换到一个新的工作环境时，对业务的不熟悉，对技术的不了解，处理事务的不成熟，都让我整日抱怨，希望公司能够对自己进行职场培训，希望有机会去学习……其实这些想法是很消极和偏激的，对于雇主来说，他们没有义务对你进行培训，学习是自己的事情，和公司或者他人都无关。公司发放薪水，作为员工来说，必须明白每个礼拜有7.5*5=37.5个小时是解决公司的问题，而不是个人的问题。除此之外的时间可以合理安排自己去学习，去恋爱，去陪家人朋友。当处理好这些时间之后，就会发现，无论是工作还是生活，都会非常的充实，而不是各种抱怨，因为之所以抱怨，一方面是对自己的不满，但是却又不愿去做改变和学习，一方面是太闲了，当忙碌起来，根本没时间抱怨。要明白和公司之间的关系，公司是工作的地方，不是学习和成长的场所，个人的职业成长充电是需要付出额外的时间。 了解自己的领域什么是N-S图表？知道米利型和摩尔型这两种状态机的差别么？能不查阅算法手册写出一个快速排序程序么？知道变换分析么？如何用数据流图进行功能分解么？什么是临时传递数据？耦合性是什么？什么是parnas表？…… 对于程序员来说，每天都要面临着技术的日新月异，新技术层出不断，行业发展迅速，每天都需要学习，不仅是学习新知识，还要了解过去的知识，基础的，经验的。刚入行的时候，对于我来说，很少去了解领域中的知识，每当交谈的时候，总会对很多名词一脸懵逼，这就是很不专业了。 书中列出了每个专业软件开发人员要精通的事项（仅供参考） 设计模式，必须能描述GOF书中的全部24种模式，同时还要有POSA书中的多数模式的实战经验。 设计原则，必须了解SOLID原则，而且要深刻理解组件设计原则 方法，必须理解XP，scrum，精益，看板，瀑布，结构化分析及结构化设计等 实践，必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程 工件，必须了解如何使用UML图，DFD图，结构图，Petri网络图，状态迁移图表，流程图和决策表 坚持学习只有坚持广泛学习才不至于落伍，否则跟不上时代 练习业精于勤 合作团队协作 辅导教学相长 了解业务领域要了解自己公司的业务领域，否则对需求就不能有很好的分析。 与雇主/客户保持一致站在雇主的角度思考问题 谦逊接受自己的不足 说“不” 能就是能，不能就是不能，不要说“试试看”-尤达 面对不合理的需求和安排，要根据自己的实际情况作出拒绝，否则将会一直处在被动并且糟糕的状态。 不过我个人理解，如果要说“不”，前提是对需求或者安排的任务以及自身的实际水平和项目有足够的了解，否则连说“不”的资格都没有。因为连自己都说服不了，怎么去拒绝别人的要求。 所以还是要做到对自己的工作负责，熟悉相关领域，才能做出合理的安排，对于不合理的需求或者安排才可以通过分析去拒绝。而不是一味接受最后发现完成不了草草了事敷衍交差，然后不停修补bug。（比如我最开始工作时，老板说的都是对的，按照老板说的来做，最后一个都没做好，因为老板一天一个想法，一拍脑袋一个需求） 说“是”当承诺一件事情的时候，就要不惜一切代价去完成，因为是你承诺的，就要对这负责。没有借口，如果发现自己兑现不了，就需要及时的说出，而不是藏着掖着最后耽误的更多。早点发出预警，还可以采取其他措施挽救。 说是=对自己将会做某件事做了清晰的事实陈述，而且还明确说明了完成期限，针对自己。 关于编码编码这部分让我感触最深的就是测试驱动开发，以前很少写单元测试，后来接触多了，越发的觉得测试是很重要的，不，非常重要。（！！！）千万不要在心烦意乱和心情不好的时候编写代码，亲身体会，一塌糊涂。还有就是保持睡眠充足！还有就是保持睡眠充足！还有就是保持睡眠充足！重要的事说三遍！！！切身感受，刚进公司后，有一个月没睡好，睡得太晚，睡不好，那些天不仅记忆力衰退，整个人萎靡不振，每天上班不在状态，就感觉行尸走肉一样，实在是太可怕了，更别提coding了。所以睡眠很重要。 时间管理安排好每天的时间可以借鉴番茄工作法，我觉得这个比较适合我，因为我经常注意力不集中，会被各种事情干扰。番茄的25分钟，还是有点效果的，主要还是靠自己自觉。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rfc_7239]]></title>
    <url>%2F2018%2F10%2F09%2Frfc-7239%2F</url>
    <content type="text"><![CDATA[1. Introduction In today’s HTTP landscape, there are a multitude of different applications that act as proxies for the user agents. In many cases, these proxies exists without the action or knowledge of the end-user.These cases occur, for example, when the proxy exists as a part of the infrastructure within the organization running the web server. Such proxies may be used for features such as load balancing or crypto offload. Another example is when the proxy is used within the same organization as the user, and the proxy is used to cache resources. However, these proxies make the requests appear as if they originated from the proxy’s IP address, and they may change other information in the original request. This represents a loss of information from the original request. This loss of information can cause problems for a web server that has a specific use for the clients’ IP addresses that will not be met by using the address of the proxy or other information changed by the proxy. The main uses of this information are for diagnostics, access control, and abuse management. Diagnostic functions can include event logging, troubleshooting, and statistics gathering, and the information collected is usually only stored for short periods of time and only gathered in response to a particular problem or a complaint from the client. Access control can be operated by configuring a list of client IP addresses from which access is permitted, but this approach will not work if a proxy is used, unless the proxy is trusted and is, itself, configured with a list of allowed client addresses for the server. Cases of abuse require identification of the abuser and this uses many of the same features identified for diagnostics. Most of the time that a proxy is used, this loss of information is not the primary purpose, or even a desired effect, of using the proxy. Thus, to restore the desired functionality when a proxy is in use, a way of disclosing the original information at the HTTP level is needed. Clearly, however, when the purpose of using a proxy is to provide client anonymity, the proxy will not use the feature defined in this document. It should be noted that the use of a reverse proxy also hides information. Again, where the loss of information is not a deliberate function of the use of the reverse proxy, it can be desirable to find a way to encode the information within the HTTP messages so that the consumer can see it. A common way to disclose this information is by using the non-standard header fields such as X-Forwarded-For, X-Forwarded-By, and X-Forwarded-Proto. There are many benefits to using a standardized approach to commonly desired protocol function: not least is interoperability between implementations. This document standardizes a header field called “Forwarded” and provides the syntax and semantics for disclosing such information. “Forwarded” also combines all the information within one single header field, making it possible to correlate that information. With the header field format described in this document, it is possible to know what information belongs together, as long as the proxies are trusted. Such conclusions are not possible to make with the X-Forwarded class of header fields. The header field defined in this document is optional such that implementations of proxies that are intended to provide privacy are not required to operate or implement the header field. Note that similar issues to those described for proxies also arise with use of NATs. This is discussed further in [RFC6269]. 2. Notational Conventions The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in [RFC2119]. 3. Syntax Notations This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with the list rule extension defined in Section 7 of [RFC7230]. 4. Forwarded HTTP Header Field The “Forwarded” HTTP header field is an OPTIONAL header field that, when used, contains a list of parameter-identifier pairs that disclose information that is altered or lost when a proxy is involved in the path of the request. Due to the sensitive nature of the data passed in this header field (see Sections 8.2 and 8.3), this header field should be turned off by default. Further, each parameter should be configured individually. “Forwarded” is only for use in HTTP requests and is not to be used in HTTP responses. This applies to forwarding proxies, as well as reverse proxies. Information passed in this header field can be, for example, the source IP address of the request, the IP address of the incoming interface on the proxy, or whether HTTP or HTTPS was used. If the request is passing through several proxies, each proxy can add a set of parameters; it can also remove previously added “Forwarded” header fields. The top-level list is represented as a list of HTTP header field-values as defined in Section 3.2 of [RFC7230]. The first element in this list holds information added by the first proxy that implements and uses this header field, and each subsequent element holds information added by each subsequent proxy. Because this header field is optional, any proxy in the chain may choose not to update this header field. Each field-value is a semicolon-separated list; this sublist consists of parameter-identifier pairs. Parameter-identifier pairs are grouped together by an equals sign. Each parameter MUST NOT occur more than once per field-value. The parameter names are case-insensitive. The header field value can be defined in ABNF syntax as: Forwarded = 1#forwarded-element forwarded-element = [ forwarded-pair ] *( &quot;;&quot; [ forwarded-pair ] ) forwarded-pair = token &quot;=&quot; value value = token / quoted-string token = &lt;Defined in [RFC7230], Section 3.2.6&gt; quoted-string = &lt;Defined in [RFC7230], Section 3.2.6&gt; Examples: Forwarded: for=&quot;_gazonk&quot; Forwarded: For=&quot;[2001:db8:cafe::17]:4711&quot; Forwarded: for=192.0.2.60;proto=http;by=203.0.113.43 Forwarded: for=192.0.2.43, for=198.51.100.17 Note that as “:” and “[]” are not valid characters in “token”, IPv6 addresses are written as “quoted-string”. A proxy server that wants to add a new “Forwarded” header field value can either append it to the last existing “Forwarded” header field after a comma separator or add a new field at the end of the header block. A proxy MAY remove all “Forwarded” header fields from a request. It MUST, however, ensure that the correct header field is updated in case of multiple “Forwarded” header fields. 5. Parameters This document specifies a number of parameters and valid values for each of them: o “by” identifies the user-agent facing interface of the proxy. o “for” identifies the node making the request to the proxy. o “host” is the host request header field as received by the proxy. o “proto” indicates what protocol was used to make the request. 5.1. Forwarded By The “by” parameter is used to disclose the interface where the request came in to the proxy server. When proxies choose to use the “by” parameter, its default configuration SHOULD contain an obfuscated identifier as described in Section 6.3. If the server receiving proxied requests requires some address-based functionality, this parameter MAY instead contain an IP address (and, potentially, a port number). A third option is the “unknown” identifier described in Section 6.2. The syntax of a “by” value, after potential quoted-string unescaping, conforms to the “node” ABNF described in Section 6. This is primarily added by reverse proxies that wish to forward this information to the backend server. It can also be interesting in a multihomed environment to signal to backend servers from which the request came. 5.2. Forwarded For The “for” parameter is used to disclose information about the client that initiated the request and subsequent proxies in a chain of proxies. When proxies choose to use the “for” parameter, its default configuration SHOULD contain an obfuscated identifier as described in Section 6.3. If the server receiving proxied requests requires some address-based functionality, this parameter MAY instead contain an IP address (and, potentially, a port number). A third option is the “unknown” identifier described in Section 6.2. The syntax of a “for” value, after potential quoted-string unescaping, conforms to the “node” ABNF described in Section 6. In a chain of proxy servers where this is fully utilized, the first “for” parameter will disclose the client where the request was first made, followed by any subsequent proxy identifiers. The last proxy in the chain is not part of the list of “for” parameters. The last proxy’s IP address, and optionally a port number, are, however, readily available as the remote IP address at the transport layer. It can, however, be more relevant to read information about the last proxy from preceding “Forwarded” header field’s “by” parameter, if present. 5.3. Forwarded Host The “host” parameter is used to forward the original value of the “Host” header field. This can be used, for example, by the origin server if a reverse proxy is rewriting the “Host” header field to some internal host name. The syntax for a “host” value, after potential quoted-string unescaping, MUST conform to the Host ABNF described in Section 5.4 of [RFC7230]. 5.4. Forwarded Proto The “proto” parameter has the value of the used protocol type. The syntax of a “proto” value, after potential quoted-string unescaping, MUST conform to the URI scheme name as defined in Section 3.1 in [RFC3986] and registered with IANA according to [RFC4395]. Typical values are “http” or “https”. For example, in an environment where a reverse proxy is also used as a crypto offloader, this allows the origin server to rewrite URLs in a document to match the type of connection as the user agent requested, even though all connections to the origin server are unencrypted HTTP. 5.5. Extensions Extensions allow for additional parameters and values. Extensions can be particularly useful in reverse proxy environments. All extension parameters SHOULD be registered in the “HTTP Forwarded Parameter” registry. If certain extensions are expected to have widespread deployment, they SHOULD also be standardized. This is further discussed in Section 9. 6. Node Identifiers The node identifier is one of the following: o The client’s IP address, with an optional port number o A token indicating that the IP address of the client is not known to the proxy server o A generated token, allowing for tracing and debugging, while allowing the internal structure or sensitive information to be hidden The node identifier is defined by the ABNF syntax as: node = nodename [ &quot;:&quot; node-port ] nodename = IPv4address / &quot;[&quot; IPv6address &quot;]&quot; / &quot;unknown&quot; / obfnode IPv4address = &lt;Defined in [RFC3986], Section 3.2.2&gt; IPv6address = &lt;Defined in [RFC3986], Section 3.2.2&gt; obfnode = &quot;_&quot; 1*( ALPHA / DIGIT / &quot;.&quot; / &quot;_&quot; / &quot;-&quot;) node-port = port / obfport port = 1*5DIGIT obfport = &quot;_&quot; 1*(ALPHA / DIGIT / &quot;.&quot; / &quot;_&quot; / &quot;-&quot;) DIGIT = &lt;Defined in [RFC5234], Section 3.4&gt; ALPHA = &lt;Defined in [RFC5234], Section B.1&gt; Each of the identifiers may optionally have the port identifier, for example, allowing the identification of the endpoint in a NATed environment. The “node-port” can be identified either by its port number or by a generated token obfuscating the real port number. An obfuscated port may be used in situations where the possessor of the proxy wants the ability to trace requests – for example, in debug purposes – but does not want to reveal internal information. Note that the ABNF above also allows port numbers to be appended to the “unknown” identifier. Interpretation of such notation is, however, left to the possessor of a proxy adding such a value to the header field. To distinguish an “obfport” from a port, the “obfport” MUST have a leading underscore. Further, it MUST also consist of only “ALPHA”, “DIGIT”, and the characters “.”, “_”, and “-“. It is important to note that an IPv6 address and any nodename with node-port specified MUST be quoted, since “:” is not an allowed character in “token”. Examples: &quot;192.0.2.43:47011&quot; &quot;[2001:db8:cafe::17]:47011&quot; 6.1. IPv4 and IPv6 Identifiers The ABNF rules for “IPv6address” and “IPv4address” are defined in [RFC3986]. The “IPv6address” SHOULD comply with textual representation recommendations [RFC5952] (for example, lowercase, compression of zeros). Note that the IP address may be one from the internal nets, as defined in [RFC1918] and [RFC4193]. Also, note that an IPv6 address is always enclosed in square brackets. 6.2. The “unknown” Identifier The “unknown” identifier is used when the identity of the preceding entity is not known, but the proxy server still wants to signal that a forwarding of the request was made. One example would be a proxy server process generating an outgoing request without direct access to the incoming request TCP socket. 6.3. Obfuscated Identifier A generated identifier may be used where there is a wish to keep the internal IP addresses secret, while still allowing the “Forwarded” header field to be used for tracing and debugging. This can also be useful if the proxy uses some sort of interface labels and there is a desire to pass them rather than an IP address. Unless static assignment of identifiers is necessary for the server’s use of the identifiers, obfuscated identifiers SHOULD be randomly generated for each request. If the server requires that identifiers persist across requests, they SHOULD NOT persist longer than client IP addresses. To distinguish the obfuscated identifier from other identifiers, it MUST have a leading underscore ““. Furthermore, it MUST also consist of only “ALPHA”, “DIGIT”, and the characters “.”, ““, and “-“. Example: Forwarded: for=_hidden, for=_SEVKISEK 7. Implementation Considerations7.1. HTTP Lists Note that an HTTP list allows white spaces to occur between the identifiers, and the list may be split over multiple header fields. As an example, the header field Forwarded: for=192.0.2.43,for=&quot;[2001:db8:cafe::17]&quot;,for=unknown is equivalent to the header field Forwarded: for=192.0.2.43, for=&quot;[2001:db8:cafe::17]&quot;, for=unknown which is equivalent to the header fields Forwarded: for=192.0.2.43 Forwarded: for=&quot;[2001:db8:cafe::17]&quot;, for=unknown 7.2. Header Field Preservation There are some cases when this header field should be kept and some cases where it should not be kept. A directly forwarded request should preserve and possibly extend it. If a single incoming request causes the proxy to make multiple outbound requests, special care must be taken to decide whether or not the header field should be preserved. In many cases, the header field should be preserved, but if the outbound request is not a direct consequence of the incoming request, the header field should not be preserved. Consider also the case when a proxy has detected a content mismatch in a 304 response and is following the instructions in [RFC7232], Section 4.1 to repeat the request unconditionally, in which case the new request is still basically a direct consequence of the origin request, and the header field should probably be kept. 7.3. Relation to Via The “Via” header field (see [RFC7230], Section 5.7.1) is a header field with a similar use case as this header field. The “Via” header field, however, only provides information about the proxy itself, and thereby leaves out the information about the client connecting to the proxy server. The “Forwarded” header field, on the other hand, has relaying information from the client-facing side of the proxy server as its main purpose. As “Via” is already widely deployed, its format cannot be changed to address the problems that “Forwarded” addresses. Note that it is not possible to combine information from this header field with the information from the Via header field. Some proxies will not update the “Forwarded” header field, some proxies will not update the Via header field, and some proxies will update both. 7.4. Transition If a proxy gets incoming requests with X-Forwarded-* header fields present, it is encouraged to convert these into the header field described in this document, if it can be done in a sensible way. If the request only contains one type – for example, X-Forwarded-For – this can be translated to “Forwarded”, by prepending each element with “for=”. Note that IPv6 addresses may not be quoted in X-Forwarded-For and may not be enclosed by square brackets, but they are quoted and enclosed in square brackets in “Forwarded”. X-Forwarded-For: 192.0.2.43, 2001:db8:cafe::17becomes: Forwarded: for=192.0.2.43, for=”[2001:db8:cafe::17]” However, special care must be taken if, for example, both X-Forwarded-For and X-Forwarded-By exist. In such cases, it may not be possible to do a conversion, since it is not possible to know in which order the already existing fields were added. Also, note that removing the X-Forwarded-For header field may cause issues for parties that have not yet implemented support for this new header field. 7.5. Example Usage A request from a client with IP address 192.0.2.43 passes through a proxy with IP address 198.51.100.17, then through another proxy with IP address 203.0.113.60 before reaching an origin server. This could, for example, be an office client behind a corporate malware filter talking to a origin server through a reverse proxy. o The HTTP request between the client and the first proxy has no “Forwarded” header field. o The HTTP request between the first and second proxy has a “Forwarded: for=192.0.2.43” header field. o The HTTP request between the second proxy and the origin server has a “Forwarded: for=192.0.2.43, for=198.51.100.17;by=203.0.113.60;proto=http;host=example.com” header field. Note that, at some points in a connection chain, the information might not be updated in the “Forwarded” header field, either because of lack of support of this HTTP extension or because of a policy decision not to disclose information about this network component. 8. Security Considerations8.1. Header Validity and Integrity The “Forwarded” HTTP header field cannot be relied upon to be correct, as it may be modified, whether mistakenly or for malicious reasons, by every node on the way to the server, including the client making the request. One approach to ensure that the “Forwarded” HTTP header field is correct is to verify the correctness of proxies and to whitelist them as trusted. This approach has at least two weaknesses. First, the chain of IP addresses listed before the request came to the proxy cannot be trusted. Second, unless the communication between proxies and the endpoint is secured, the data can be modified by an attacker with access to the network. 8.2. Information Leak The “Forwarded” HTTP header field can reveal internal structures of the network setup behind the NAT or proxy setup, which may be undesired. This can be addressed either by using obfuscated elements, by preventing the internal nodes from updating the HTTP header field, or by having an egress proxy remove entries that reveal internal network information. This header field should never be copied into response messages by origin servers or intermediaries, as it can reveal the whole proxy chain to the client. As a side effect, special care must be taken in hosting environments not to allow the TRACE request where the “Forwarded” field is used, as it would appear in the body of the response message. 8.3. Privacy Considerations In recent years, there have been growing concerns about privacy. There is a trade-off between ensuring privacy for users versus disclosing information that is useful, for example, for debugging, statistics, and generating location-dependent content. The “Forwarded” HTTP header field, by design, exposes information that some users consider privacy sensitive, in order to allow for such uses. For any proxy, if the HTTP request contains header fields that specifically request privacy semantics, the proxy SHOULD NOT use the “Forwarded” header field, nor in any other manner pass private information, such as IP addresses, on to the next hop. The client’s IP address, that may be forwarded in the “for” parameter of this header field, is considered to be privacy sensitive by many people, as the IP address may be able to uniquely identify a client, what operator the user is using, and possibly a rough estimation of where the user is geographically located. Proxies using this extension will preserve the information of a direct connection. This has an end-user privacy impact regardless of whether the end-user or deployer knows or expects that this is the case. Implementers and deployers of such proxies need to consider whether, and how, deploying this extension affects user privacy. The default configuration for both the “by” and “for” parameters SHOULD contain obfuscated identifiers. These identifiers SHOULD be randomly generated per request. If identifiers that persist across requests are required, their lifetimes SHOULD be limited and they SHOULD NOT persist longer than client IP addresses. When generating obfuscated identifiers, care must be taken not to include potentially sensitive information in them. Note that users’ IP addresses may already be forwarded by proxies using the header field X-Forwarded-For, which is widely used. It should also be noted that if the user were doing the connection directly without passing the proxy, the client’s IP address would be sent to the web server. Users that do not actively choose an anonymizing proxy cannot rely on having their IP address shielded. These users who want to minimize the risk of being tracked must also note that there are other ways information may leak, for example, by browser header field fingerprinting. The Forwarded header field itself, even when used without a uniquely identifying client identifier, may make fingerprinting more feasible by revealing the chain of proxies traversed by the client’s request. 9. IANA Considerations This document specifies the HTTP header field listed below, which has been added to the “Permanent Message Header Field Names” registry defined in [RFC3864]. Header field: Forwarded Applicable protocol: http Status: standard Author/Change controller: IETF (iesg@ietf.org) Internet Engineering Task Force Specification document(s): this specification (Section 4) Related information: None The “Forwarded” header field contains parameters for which IANA has created and now maintains a new registry entitled “HTTP Forwarded Parameters”. Initial registrations are given below. For future assignments, the registration procedure is IETF Review [RFC5226]. The security and privacy implications of all new parameters should be thoroughly documented. New parameters and their values MUST conform with the forwarded-pair as defined in ABNF in Section 4. Further, a short description should be provided in the registration. +————-+—————————————+————-+ | Parameter | Description | Reference | | name | | | +————-+—————————————+————-+ | by | IP address of incoming interface of a | Section 5.1 | | | proxy | | | for | IP address of client making a request | Section 5.2 | | | through a proxy | | | host | Host header field of the incoming | Section 5.3 | | | request | | | proto | Application protocol used for | Section 5.4 | | | incoming request | | +————-+—————————————+————-+ Table 1: Initial Assignments 10. References10.1. Normative References [RFC2119] Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels”, BCP 14, RFC 2119, March 1997. [RFC3864] Klyne, G., Nottingham, M., and J. Mogul, “Registration Procedures for Message Header Fields”, BCP 90, RFC 3864, September 2004. [RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax”, STD 66, RFC 3986, January 2005. [RFC4193] Hinden, R. and B. Haberman, “Unique Local IPv6 Unicast Addresses”, RFC 4193, October 2005. [RFC4395] Hansen, T., Hardie, T., and L. Masinter, “Guidelines and Registration Procedures for New URI Schemes”, BCP 35, RFC 4395, February 2006. [RFC5226] Narten, T. and H. Alvestrand, “Guidelines for Writing an IANA Considerations Section in RFCs”, BCP 26, RFC 5226, May 2008. [RFC5234] Crocker, D. and P. Overell, “Augmented BNF for Syntax Specifications: ABNF”, STD 68, RFC 5234, January 2008. [RFC5952] Kawamura, S. and M. Kawashima, “A Recommendation for IPv6 Address Text Representation”, RFC 5952, August 2010. [RFC7230] Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, RFC 7230, June 2014. [RFC7232] Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests”, RFC 7232, June 2014. 10.2. Informative References [RFC6269] Ford, M., Boucadair, M., Durand, A., Levis, P., and P. Roberts, “Issues with IP Address Sharing”, RFC 6269, June 2011. Appendix A. Acknowledgments Thanks to Per Cederqvist, Alissa Cooper, Adrian Farrel, Stephen Farrell, Ned Freed, Per Hedbor, Amos Jeffries, Poul-Henning Kamp, Murray S. Kucherawy, Barry Leiba, Salvatore Loreto, Alexey Melnikov, S. Moonesamy, Susan Nichols, Mark Nottingham, Julian Reschke, John Sullivan, Willy Tarreau, and Dan Wing for their feedback.]]></content>
      <categories>
        <category>小概念</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Production]]></title>
    <url>%2F2018%2F10%2F08%2FProduction%2F</url>
    <content type="text"><![CDATA[Production (computer science)From Wikipedia A production or production rule in computer science is a rewrite rule specifying a symbol substitution that can be recursively performed to generate new symbol sequences. A finite set of productions is the main component in the specification of a formal grammar (specifically a generative grammar). The other components are a finite set of nonterminal symbols, a finite set (known as an alphabet) of terminal symbols that is disjoint from and a distinguished symbol that is the start symbol. In an unrestricted grammar, a production is of the form where and are arbitrary strings of terminals and nonterminals however may not be the empty string. If is the empty string, this is denoted by the symbol , or (rather than leave the right-hand side blank). So productions are members of the cartesian product,where is the vocabulary, is the Kleene star operator, indicates concatenation, and denotes set union. If we do not allow the start symbol to occur in (the word on the right side), we have to replace by on the right side of the cartesian product symbol.[1]The other types of formal grammar in the Chomsky hierarchy impose additional restrictions on what constitutes a production. Notably in a context-free grammar, the left-hand side of a production must be a single nonterminal symbol. So productions are of the form: Grammar generationTo generate a string in the language, one begins with a string consisting of only a single start symbol, and then successively applies the rules (any number of times, in any order) to rewrite this string. This stops when we obtain a string containing only terminals. The language consists of all the strings that can be generated in this manner. Any particular sequence of legal choices taken during this rewriting process yields one particular string in the language. If there are multiple different ways of generating this single string, then the grammar is said to be ambiguous.For example, assume the alphabet consists of and , with the start symbol , and we have the following rules: then we start with , and can choose a rule to apply to it. If we choose rule 1, we replace with and obtain the string . If we choose rule 1 again, we replace with and obtain the string . This process is repeated until we only have symbols from the alphabet (i.e., and ). If we now choose rule 2, we replace with and obtain the string , and are done. We can write this series of choices more briefly, using symbols: . The language of the grammar is the set of all the strings that can be generated using this process: .See also[edit] • Formal grammar • Finite automata • Generative grammar • L-system • Rewrite rule • Backus–Naur form (A compact form for writing the productions of a context-free grammar.) • Phrase structure rule • Post canonical system (Emil Post’s production systems- a model of computation.)References[edit]]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我终于成了你的前女友]]></title>
    <url>%2F2018%2F10%2F08%2F%E6%88%91%E7%BB%88%E4%BA%8E%E6%88%90%E4%BA%86%E4%BD%A0%E7%9A%84%E5%89%8D%E5%A5%B3%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[两三年前写的小说，当年的伪文艺啊,现在看看，还是没经历过爱情的天真和浪漫，没恋爱之前以为喜欢就是爱情，经历过才知道，合适才是主要。突然想写小说了，改日有空再写写。 写在前面:这部小说是在我看了巫其格的小说猫小姐恋爱之后写的,里面也借鉴了猫小姐.不过这片小说里面其实是带了我的影子.朋友们看了都觉得我是在写自己.喜欢巫大大的暖文.所以开始尝试写自己的文章.记下那些美好.憧憬一些未来. 一直喜欢在别人的故事里迷失了自己。看到一句暖心的话会不自主的扬起嘴角，如果故事里的主角遇到不开森也会流泪。我叫云舒.不知道为什么母上大人会给我取这么”文雅”的名字,以至于每次刚开学老师说这次叫个男生起来回答问题时都会说:”那就云舒来回答吧”,伴着一阵哄笑我不得不说我是个女生.老师一脸尴尬”那就你来回答吧”.心里头默默画个圈圈.人家明明是个软妹子嘛.唉,虽然看起来不是很像. 因为名字的原因,特别喜欢那句宠辱不惊,闲看庭前花开花落,去留无意,漫随天外云卷云舒.总想做个这样的女子,把生活过得宠辱不惊.但是我这跳脚的性格总能和宠辱不惊扯得十万八千里. 那天应该天气正好,而你恰好推开门闯进了我的视线.如果回忆起来你是穿着白衬衫就更好了,不过生活毕竟不是小说,能清楚的记住你穿着黑色的裤子,灰白条纹的T恤,一身风骨是我想要的.完了,多年没谈恋爱的我想谈恋爱了.买完东西的我不想马上离开,于是和服务员说,再给我来两份鸡排,三杯酸梅汤.一串烤肉,想着这么多吃的可以让我在这多待会了,说不定还能和你搭讪呢,这样的小心思让我不禁笑了.抬脚向后挪动,准备瞅瞅你在哪,不小心踩到了一个软软的鞋,抬头被你清澈的眼神震惊了.连忙说”对不起,对不起,我不是故意的”.你低头看了看鞋子,说没关系.我还想多说两句来着,那边店员叫到”姑娘你点的两份鸡排一串烤肉三杯酸梅汤好了.”在你略诧异的眼神里我默默的挪到了收银台.准备付钱,哦我的天哪,该死的一卡通,里面竟然只剩下十元了.偏偏我还点了这么多.一见帅哥误终身啊,本来还记得只买一份的,为了多待会忘了卡里没钱了.尴尬啊.这时你买了一杯酸梅汤过来准备付钱了,我在想要不要问你借呢,正好还能要到联系方式,啊哦,简直天助我也啊.于是我弱弱的问你”那个我的卡里没钱了,能帮我刷下,回头我给你钱.我绝对不是骗子.我是电院的.不是坏人…”还没等我介绍完,你拿出了卡,说,没关系,拿去用吧.付完钱后,我向你要了联系方式. 云舒一直觉得自己是不会谈恋爱的,尤其是看遍了身边好友的恋爱史,分分合合,路过一个又一个,甚至撕心裂肺.所以云舒是抵触爱情的.以至于只要有了想要恋爱的萌芽都直接把它扼杀在摇篮里. 云舒条件其实不错,尤其在这个理科学院,僧多肉少,但是每次室友提到某某某其实不错,可以考虑考虑,云舒就想到了好友的要死要活.就立马扼杀了这个念头.”小箐,还记得茹茹么?” 茹茹是云舒的室友,她刚进大学喜欢上了隔壁班的一个男生,军训结束之后两人就在一起了,各种甜蜜各种秀恩爱,可能正应了那句秀恩爱分的快,不到一个月两人就分了,然后寝室三人开始彻夜开导,但是第二天两人又和好了,无奈的室友们再后来听他们吵架已经麻木了,只有云舒会在听他们的故事时安慰一两句,大二时,他们分分合合好多次,直到大二期末,茹茹站在湖边问秦墨到底爱不爱她.一只脚悬在湖边的茹茹大声哭着不让人靠近,这件事闹的很大,后来茹茹也没来上学了,听说家里让她去一个城市打工去了.爱情总是盲目的追求安全感.其实让你感觉若即若离的人,最终还是会离开.只是当初有为何那样执着呢.耗尽了自己的青春. 我一直觉得自己是个理智的女生,不会随便恋爱,不会随意动心.似乎我还可以扼杀心中的悸动.但是现在我想恋爱了.室友说我是个直发及腰鼻梁高高眼睛大大的姑娘，似乎很多男生都喜欢这样的姑娘.只是一直不谈恋爱,所以大家对我的兴趣淡了.但人生总有一些意外，它会打破常规，突如其来。每次想起那天初次见面的场景,我总会想起这样的一句话,阳光正好,我爱的人刚好没穿白衬衫,柏彬正好就是这个意外. 柏彬是谁?我也不知道,目前对他的了解只有一串数字.哦,我还顺便加了这个号码的微信,不知道会不会同意. 打完水回到寝室的我听到手机一个熟悉的提示音,打开手机一看,哈哈,他同意了.于是我发了一条简讯过去”我是今天让你帮忙刷卡的女生,还记得我么?””嗯,记得”.”那个,你寝室在哪,我把钱送过去””不用这么麻烦吧,我过去拿吧,你在哪个寝室?””XXXX””好的,我待会正好过去” 到底穿哪件衣服好呢,云舒在寝室苦恼了半天,最后还是选择了最开始的那一套.柏彬来的很快,”到你楼下了”,我雀跃的下去了,远远就看见路灯下的你,渲染了一层橙色,温馨又美好.我蹦蹦跳跳的走到了你面前,给了一根棒棒糖给你,说”感谢你的出手相救.请你吃的”.你不好意思的笑了笑.我问你是哪个院的,你说也是电院的,真是太太太巧了,天知道我此刻的内心是多么激动啊.哈哈哈.我说既然是同一师门,我请你去喝奶茶吧,正好把钱找开,你说你请我,我说下次请我,这次我请.你想了下答应了.坐在奶茶店,看着对面的你,发现原来你是我的学长.云舒话很多,一直在说,和柏彬聊得不错,知道你是哪个寝室的了.后来奶茶喝完了又出去溜达了一圈,不再是陌生人了. 晚上躺在床上想着奶茶店里灯光下的你柔和的笑容,我想我沦陷了. 我想我要和你说我喜欢你.后来你说请我喝咖啡,十年咖啡的环境很好,你说上次让我请你喝奶茶不好意思的,这次请我喝咖啡,问我要喝什么,我点了一杯卡布奇诺.你也点了一杯卡布奇诺.我看着你的眼睛说”学长,我喜欢你.一见钟情,没开玩笑”你一脸震惊.还没反应过来, “所以,你喜欢我么?” 你刚打算说话,突然我的手机响了,辅导员找我,十万火急.哭丧着脸的我留下一脸尴尬的你走了. 后来两人在微信你也没聊天,我也忙着期末考试的项目,我和室友说过你的事,大家觉得知己知彼百战不殆,开始帮我收集你的资料,你竟然没谈过恋爱.我觉得我应该要主动出击,管理校园寝室的室友决定因公济私一下,给了我进男生寝室的权力,于是某个月黑风高的晚上,我溜进了男生寝室,竟然让我很快的找到了你的寝室,男生寝室的门都不锁么,推开柏彬宿舍看到刚好洗完澡光着上身出来的柏彬时，鼻腔一热，鼻血顺着流了出来。让还没有反应过来的柏彬顿时手忙脚乱，一边抓起放在床上的衣服一边抓着桌子上的抽纸地给她。 我知道，这回事大了。等柏彬收拾整齐，两个人面对面坐在十年的餐桌时，我羞耻地快把头低到鞋面上去了。柏彬咳了咳嗓子，率先说话， “云舒，你身为女孩子擅自进入男生宿舍，你知道这意味着什么吗？” 我戳了戳手指，抬头说， “我会对你负责的。” 其实我心里想好了，反正我对柏彬是真的喜欢了，如果对方愿意的话，我是很愿意的。 “那是私闯民宅。”柏彬一脸无奈接着说，“云舒，你能说说你喜欢我哪里吗？” 听到这话，我知道柏彬这是在间接地拒绝我， “如果我说出来，你就会改掉吗？”柏彬大概看我太认真的样子，一下子笑出了声， “你的思维一直都是这么跳脱吗？” “也不是，分情况。” “现在是什么情况？” “现在的情况是，既然来都来了，不妨一起吃点甜点吧。我请客！”我看了一眼时间，又看了一眼柜台说。 我点了一份抹茶麻糬芝士蛋糕,你点了一份培根奶酪塔.今晚的芝士在橘黄色的灯 光下散发着迷人的气息.可是想吃你面前的培根奶酪塔了.和谐一致的我们安安静静吃着 点心,没有人说话.除了偶尔响起的消息提示音. “柏先生,我会对你负责的.你要不要过来 和我谈个恋爱呢?” “姑娘,承诺是不可以随便许下的哟.我们彼此还不了解,要不先做朋友 怎样?” “今晚天气不错,我订了两张刚上映的电影票,一起去看吧.请你的哟,学长.” “好 吧,等下我来买爆米花吧”. 电影很好看,事先听说你喜欢悬疑类的,果然是真的和我来看 电影的.关了灯的电影院是安全的,侧头能看到你眉头微锁,应该是在推演情节.电影说的 什么我不记得了.电影屏幕下的你刻在记忆里.一起吃爆米花不小心触碰到的手指微凉. “ 电影好看么?我看你都没怎么看电影啊?” “美人在卧,朕没心思想其他的.” 哈哈哈,看你被 我调戏的样子简直可爱. “柏小彬,我带你去看我最爱的狗狗,走” 不等你说话,就带着你走 到了一个废弃楼,”大宝,姐姐过来看你啦,快出来,今天给你带了个大哥哥来啦””汪汪呜 ~”后来才知道柏彬最开始是拒绝的的,他心想像他这么高大帅气的男人怎么能拘泥于丢 点的小事情上，可脚步却已经跟着我去了那片弃楼。 我从书包里掏出狗粮蹲在地上一边撒狗粮一边和大宝说话，问大宝今天开不开 心,有没有交到新的小伙伴啊。最后转过头问柏彬，“你要不要摸一下它，不用怕的， 我都带它打过针了？” 柏彬后来捋着我的头发说当时他的心里一百个不愿意，从小到大都很少玩毛绒 玩具,但是很奇怪腿却不由自主地曲下去伸手摸了一下大宝，大宝的脑袋在你宽厚的 手掌下舒服地摇摆，小尾巴一直摆动。他转头看向我，他说那个角度下我整个人都沐浴 在夜色下，头发被灯光反射出金黄色，脸上绒绒的小毛,看上去就像一只小宠物，会心 一击。他当时就想顺手在我的脑袋上摸一摸.然后收藏起来. “你看,我们家大宝是不是很可爱?”你说，“可爱，都很可爱。” 你送我回来的时候已经很晚了, “云舒,你挺可爱的,和你在一起很开心.早点休息 吧.” “柏小彬,可爱是可怜没人爱的意思!不要说我可爱啦,你应该夸姑娘好看.” “我记得 你之前是叫我学长的啊,现在学长也不叫了?””我发现柏小彬比柏彬好听,我决定以后就 叫你柏小彬啦.” 后面的日子我 有事没事就叫上你一起喂狗狗，约饭也是常态。我带着你从 一食堂吃到八食堂，从酸辣粉吃到排骨饭，吃得室友说我每天都笑得像朵花一样。 可从始至终，你都不说你到底喜不喜欢我。 期末答辩前夕我紧张得连觉都睡不好，光是资料就背了好几遍。等我搞定一 切后想起来好几天没有去喂大宝的时候，愧疚得就差把那一整袋狗粮都背下去。等我风 风火火跑到树林的时候，居然看到你正蹲在那喂大宝，吓得我揉了几次眼睛才确定自己 没有看错。 我为了表示感谢决定再请你吃次食堂，别问我为什么，我绝对不会说我把自 己的生活费都用在了照顾狗狗身上，而自己只能吃着食堂。 但是当你提出请我去吃火锅的时候，我毅然决然的放弃了学校的黄焖鸡米饭 ，“ 我可以多点几盘肉吗？” “为了庆祝你期末答辩过关，允许你点所有想吃的，但不能浪费。” 我觉得你是在意我的，不然怎么知道我期末答辩是否顺利结束了呢？所以在 你送我回宿舍的时候，就问你明天可以一起出去玩玩，你却拒绝了，说是要回公司上班 了。忘了说柏彬已经在上班了,在一家科技公司. 我回到宿舍后赶紧跑到窗边，看到你瘦削的背影正慢慢地走出了视线。其实 你拒绝的不仅仅是一场出游，而是我整个人。 晚上便下起了大暴雨，和我的心情一样糟糕的天气，自怨自艾地趴在床上刷 着微博，就看见班级群里有人在讨论大暴雨大宝的废弃楼淹了,想到大宝可能被淹了,我 赶紧拿起一把伞冲出去了,雨下的真大,一把伞真不顶什么事,我的身上都湿了,折腾了半 天,终于把小狗窝固定了,换了窝,大宝可以安心睡觉了. 但是, 第二天，我就生病了。高烧三十九度被到医院的时候，室友说我那时 嘴里还在不停地念叨着我的大宝和柏小彬。小箐觉得我烧坏的是脑子，得好好治治。 你赶来医院的时候，我刚刚办完出院手续。看着气还没喘匀的你，一脸茫然， “你是来看我的吗？” “恩，我今天才听说你这几天生病。” 我一脸认真地看着你，突然就笑了出来，“柏小彬，你现在这样子特可爱。 ” “我在考虑要不要收回给你惊喜的这个想法？”你摸索着下巴，眯着眼睛说话 ，活脱脱的狐狸相。 我眼珠转了一圈，“柏小彬你高大威猛，帅气逼人，能沉鱼能落雁的。” 你带着我一路开车到南京，中途几次我都怀疑自己要被拐卖了， “你是不 是从事人口拐卖的行当了？” “云舒，我要告你诽谤。” “律师费不会是我出吧？” 到了宠物店的时候，我激动地直接抱住了你，也没等你做出什么反应，即刻转身 投向了大宝的怀抱。 转过身的我嘴角露出了苦涩的笑，我想再问问你是否喜欢我，我不想像茹茹 那样每天都活在揣测对方心思的日子里，也怕会有站在湖边上嚎叫着逼问对方到底爱不 爱自己的那一天。可面对这样淡定的你时，我什么都不想问，比起拒绝的答案来说，这 样似乎也挺好. 实习期到了,我要去我父母的城市了，你说送我去车站 ，一路上窗外的景色倒退的厉害,玻璃上反射出你的轮廓，空气里凝聚着一股沉默。我 依依不舍地和你告别，嘱咐一定要定期去看望大宝，(一定要记得想起我。)你点头答应 。 最后转头的时候，我的眼泪就掉了下来，觉得自己好委屈，好不容易有了喜 欢的人，都没有好好的在一起就要分开了。这么一想，我不由得哭出声，声音响得整个 火车站的人目光都投向这边，指指点点地比划着什么，偶尔听到的几个字眼都是“可怜 了人家小姑娘了”“这年头没一个男人靠谱”。 我越哭越厉害，吓得你手忙脚乱地翻口袋找纸巾，嘴里一直哄着，“别哭别 哭，以后还能见到的。” 那天躺在你怀里,你对我说, “我一个人生活久了，习惯的三思后行，总是犹 豫不决，以为你会一直在，从没想过你也会有离开的一天，那天你一直哭一直哭，哭得 我心都碎了，可我却什么都不能为你做。”从那一刻你决定来我的城市找我.你说你每 次和大宝玩闹的时候都会想起我,原来你已经喜欢上我了. 一直到大厅里响起了我这班火车要检票进站时，我才收声，抽泣地问你， “ 我能抱抱你吗？”没等你回答直接就扑到你的怀里，紧紧地抱着他，哪怕是多一分钟都 让我心里能舒服。 “柏小彬，我觉得我越来越喜欢你了，喜欢到连离开你都觉得害怕。”我感 觉到你身体一僵，我继续说，“你别说话，听我说完，我不知道以后还会不会回来，希 望你能遇到让你心动的姑娘，” 话一说完，我拖着行李箱就进站了，身后的你什么都没说，我也不知道自己到 底在期待着什么。 我在魔都找了份程序媛工作，我开始无比寂寞地怀念在学校的生活，想念室友 想念大宝，也更加地想念你。 我已经一个星期没有联系你了，这时我才意识到原来我和你之间的情谊，都只 是我在一厢情愿的维护。我不主动，就再也不会有关系了. 你发来信息的时候，我正在看一篇感人肺腑的微博，是关于一对老夫妻携手多 年的爱情事迹，感动的眼泪都在眼圈里打转，在打开你的信息后直接就飙出了眼泪。 坐在我旁边的程序员小杨连忙给我递纸巾说，“姑娘啊，以后这种新闻多的是 ，小心把眼睛哭坏咯！” “呜呜，我真的太感动了，铁树居然开花了。” “什么铁树开花，哪家的新闻，快给我看看。” “不是的，是我心中的铁树开花了。”我抽泣着说。 小杨会心一笑，“刚出校园就是好啊！” 你发来的信息内容是一张照片，你和大宝合照，下边写着“我们都想你了。” 我很慎重地想该发什么样的短信回去，短信编辑了又删,删了又写,担心一句说 错的话就失去你,一直到下班，我也没有想到怎么回复最恰当。最后我决定我要去见你 ，我觉得在短信里根本表达不了我热血沸腾的心。心动不如行动。 我立刻给老板打电话 请假，老板知道下午的事,颇为理解的在电话那头调侃“年轻人就是精力旺盛”，还嘱 咐我勇敢一点，以后才不会后悔度过余生。得到鼓励后，我拖着行李箱就往公交站走，一分钟一秒钟都不想耽误。 初春的风有点大，把我的头发吹得全部贴在脸上，我不得不停下来把头发往耳后 别，别着别着我的手就动不了了。 路灯弥漫下，你像镀了一层金边一样向我走过来。我不可置信地揉着眼睛看着站 在面前的人， “柏小彬？” “是我。”你笑着说，细长的眼睛弯成了一条弧，“我来告诉你，我找到想要在 一起的人了。” 我心一惊，我觉得你说的是自己，可我又不能确定，试探着问，“那个人是我吗？ ” “我一个人生活久了，习惯的三思后行，总是犹豫不决，以为你会一直在，从没想 过你也会有离开的一天，那天你一直哭一直哭，哭得我心都碎了，可我却什么都不能为 你做。”你看着我震惊的表情接着说，“这一个月里，我每天都去喂大宝，看着它才意 识到我早在不自觉的时候就喜欢你了。其实不止你会害怕，我也怕，我怕我越来越喜欢 你，而你会离开我该怎么办？这样一想，我就来了。” 这是我认识你以来他说过最多的一次话。 你后来说你当时的内心是忐忑的，你不知道这一个月里我的喜欢是否发生了变化 ，“所以呢，我现在还有资格待在你身边吗？” 缓过神的我丢下手里的行李箱，二话不说直接就扑到你的怀里，“你能来就最好 了！” 爱情从来不怕晚，怕的是没人愿意最先说出口，只能遗憾地在心里揣测不安。 时间不长不短,在我最美的年华认识了你,习惯了每天早起的早安,睡前的晚安.很 多人都说爱情到后来会失去了最初的新鲜.在一起三年了,我从没想多会成为你的前女友 . 我坐在副驾驶上,看着你的侧脸,眼泪开始打转. 从当初认识你的那家店,到此时此刻,就像一部无声电影,承载了我们太多的回忆. 你说我很笨,以后丢了就在原地等着你来找我.我想要YSL口红的所有色号,逛街时问你会 不会买给我,你问我是婚前还是婚后,我说有区别么,你是不是婚后就不爱我了?你说婚前 的话现在就去买,你付钱 ,婚后的话你想买就买,钱都在你那,问我干嘛? 没想到现在我就 成了前女友.你的侧脸比那时的你更成熟了. 今天你穿的很正式,其实你很适合西装.今天早上给你打领带的时候不小心留下了 一个唇印,看着白衬衫上一个红唇,确实挺尴尬的. 毕竟今天是我们去领证的日子啊. 终于我成了你的前女友.你成了我的老公。 “汪汪汪~”后座上传来大宝欢快的叫声. 附上咱们大宝的照片(由于大宝爱吃鸡,没办法只好把她弄个链子了)获取授权]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文法]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%96%87%E6%B3%95%2F</url>
    <content type="text"><![CDATA[上下无关文法文法被用于组织编译器前端，文法自然地描述了大多数程序设计语言构造的层次化语法结构，例如java的if-else语句有如下的形式：if(expression) statement else statement用expr表示表达式，变量stmt表示语句，构造规则表示：Stmt-&gt;if(expr)stmt else stmt（产生式）-&gt;:可以具有如下形式If ():终结符号expr stmt :非终结符号 文法定义 终结符号集合（词法单元），终结符号是该文法所定义的语言的基本符号的集合 非终极符号集合（语法变量），每个非终结符号表示一个终结符号串的集合。 产生式集合，其中每个产生式包括一个称为产生式头或左部的非终极符号，一个箭头，一个称为产生式体或右部的由终结符号及非终结符号组成的序列。产生式主要用来表示某个构造的某种书写形式，如果产生式头非终极符号代表一个构造，那么该产生式体就代表了该构造的一种书写方式。 指定一个非终极符号为开始符号。 词法单元和终结符号在编译器中，词法分析器读入源程序的字符序列，将它们组织为具有词法含义的词素，生成并输出代表这些词素的词法单元序列。词法单元由两个部分组成：名字和属性值。 描述文法的时候。列出该文法的产生式，并且首先列出开始符号对应的产生式。假设数位，符号（&lt;,&lt;=）和黑体字符串（while）都是终结符号。斜体字符串表示非终结符号，所有非斜体的名字或者符号都可以看做终结符号，为表示方便，以同一个非终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用“|（或）”分隔。 推导根据文法推导符号串时，首先从开始符号出发，不断将某个非终极符号替换为该非终结符号的某个产生式的体。可以从开始符号推导得到的所有终结符号串的集合称为该文法定义的语言。 二义性一个文法可能有多棵语法分析树能够生成同一个给定的终结符号串。 练习Consider the context-free grammar:S -&gt; S S + | S S * | a 1. Show how the string aa+a* can be generated by this grammar. 2. Construct a parse tree for this string. 3. What language does this grammar generate? Justify your answer. Answer 1. S -&gt; S S * -&gt; S S + S * -&gt; a S + S * -&gt; a a + S * -&gt; a a + a * 3. L = {Postfix expression consisting of digits, plus and multiple signs} What language is generated by the following grammars? In each case justify your answer.1. S -&gt; 0 S 1 | 0 1 2. S -&gt; + S S | - S S | a 3. S -&gt; S ( S ) S | ε 4. S -&gt; a S b S | b S a S | ε 5. S -&gt; a | S + S | S S | S * | ( S ) Answer 1. L = {0n1n | n&gt;=1} context-free grammarsA grammar is a set of rules for putting strings together and so corresponds to a language. grammarsA grammar consists of: a set of variables(also called nonterminals),one of which is designated the start variable;It’s customary to use upper-case letters for variables; a set of terminals(from the alphabet); a list of productions(also called rules) Using a GrammarA production allows one to take a string containing a variable and replace the variable by the RHS of the production.String w of terminals is generated by the grammar if, starting with the start variable, one can apply productions and end up with w, The sequence of strings so obtained is a derivation of w.We focus on a special version of grammars called a context-free grammar (CFG), A language is context-free if it’s generated by a CFG.]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个“简单”的语法制导翻译器]]></title>
    <url>%2F2018%2F09%2F26%2F%E4%B8%80%E4%B8%AA%E2%80%9C%E7%AE%80%E5%8D%95%E2%80%9D%E7%9A%84%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-Interview-Practices]]></title>
    <url>%2F2018%2F09%2F26%2FPHP-Interview-Practices%2F</url>
    <content type="text"><![CDATA[PHP interview best practices in China基础篇 了解大部分数组处理函数 字符串处理函数 区别 mb_ 系列函数 &amp; 引用，结合案例分析 == 与 === 区别 isset 与 empty 区别 全部魔术函数理解 static、$this、self 区别 private、protected、public、final 区别 OOP 思想 抽象类、接口 分别使用场景 Trait 是什么东西 echo、print、print_r 区别(区分出表达式与语句的区别) construct 与 destruct 区别 static 作用（区分类与函数内）手册 、SOF __toString() 作用 单引号&#39;与双引号&quot;区别 常见 HTTP 状态码，分别代表什么含义 301 什么意思 404 呢? 进阶篇 Autoload、Composer 原理 PSR-4 、原理 Session 共享、存活时间 异常处理 如何 foreach 迭代对象 如何数组化操作对象 $obj[key]; 如何函数化对象 $obj(123); yield 是什么，说个使用场景 yield PSR 是什么，PSR-1, 2, 4, 7 如何获取客户端 IP 和 服务端 IP 地址 如何开启 PHP 异常提示 如何返回一个301重定向 如何获取扩展安装路径 字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制 BOM 头是什么，怎么除去 什么是 MVC 依赖注入实现原理 如何异步执行命令 模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade） 如何实现链式操作 $obj-&gt;w()-&gt;m()-&gt;d(); Xhprof 、Xdebug 性能调试工具使用 索引数组 [1, 2] 与关联数组 [&#39;k1&#39;=&gt;1, &#39;k2&#39;=&gt;2] 有什么区别 实践篇 给定二维数组，根据某个字段排序 如何判断上传文件类型，如：仅允许 jpg 上传 不使用临时变量交换两个变量的值 $a=1; $b=2; =&gt; $a=2; $b=1; strtoupper 在转换中文时存在乱码，你如何解决？php echo strtoupper(&#39;ab你好c&#39;); Websocket、Long-Polling、Server-Sent Events(SSE) 区别 “Headers already sent” 错误是什么意思，如何避免 算法篇 快速排序（手写） 冒泡排序（手写） 二分查找（了解） 查找算法 KMP（了解） 深度、广度优先搜索（了解） LRU 缓存淘汰算法（了解，Memcached 采用该算法） 数据结构篇（了解） 堆、栈特性 队列 哈希表 链表 对比篇 Cookie 与 Session 区别 GET 与 POST 区别 include 与 require 区别 include_once 与 require_once 区别 Memcached 与 Redis 区别 MySQL 各个存储引擎、及区别（一定会问 MyISAM 与 Innodb 区别） HTTP 与 HTTPS 区别 Apache 与 Nginx 区别 define() 与 const 区别 traits 与 interfaces 区别 及 traits 解决了什么痛点？ Git 与 SVN 区别 数据库篇 MySQL CRUD JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN UNION GROUP BY + COUNT + WHERE 组合案例 常用 MySQL 函数，如：now()、md5()、concat()、uuid()等 1:1、1:n、n:n 各自适用场景 了解触发器是什么，说个使用场景 数据库优化手段 索引、联合索引（命中条件） 分库分表（水平分表、垂直分表） 分区 会使用 explain 分析 SQL 性能问题，了解各参数含义 重点理解 type、rows、key Slow Log（有什么用，什么时候需要） MSSQL(了解) 查询最新5条数据 NOSQL Redis、Memcached、MongoDB 对比、适用场景（可从以下维度进行对比） 持久化 支持多钟数据类型 可利用 CPU 多核心 内存淘汰机制 集群 Cluster 支持 SQL 性能对比 支持事务 应用场景 你之前为了解决什么问题使用的什么，为什么选它？ 服务器篇 查看 CPU、内存、时间、系统版本等信息 find 、grep 查找文件 awk 处理文本 查看命令所在目录 自己编译过 PHP 吗？如何打开 readline 功能 如何查看 PHP 进程的内存、CPU 占用 如何给 PHP 增加一个扩展 修改 PHP Session 存储位置、修改 INI 配置参数 负载均衡有哪几种，挑一种你熟悉的说明其原理 数据库主从复制 M-S 是怎么同步的？是推还是拉？会不会不同步？怎么办 如何保障数据的可用性，即使被删库了也能恢复到分钟级别。你会怎么做。 数据库连接过多，超过最大值，如何优化架构。从哪些方便处理？ 502 大概什么什么原因？ 如何排查 504呢？ 架构篇 偏运维（了解）： 负载均衡（Nginx、HAProxy、DNS） 主从复制（MySQL、Redis） 数据冗余、备份（MySQL增量、全量 原理） 监控检查（分存活、服务可用两个维度） MySQL、Redis、Memcached Proxy 、Cluster 目的、原理 分片 高可用集群 RAID 源代码编译、内存调优 缓存 工作中遇到哪里需要缓存，分别简述为什么 搜索解决方案 性能调优 各维度监控方案 日志收集集中处理方案 国际化 数据库设计 静态化方案 画出常见 PHP 应用架构图 框架篇 ThinkPHP（TP）、CodeIgniter（CI）、Zend（非 OOP 系列） Yaf、Phalcon（C 扩展系） Yii、Laravel、Symfony（纯 OOP 系列） Swoole、Workerman （网络编程框架） 对比框架区别几个方向点 是否纯 OOP 类库加载方式（自己写 autoload 对比 composer 标准） 易用性方向（CI 基础框架，Laravel 这种就是高开发效率框架以及基础组件多少） 黑盒（相比 C 扩展系） 运行速度（如：Laravel 加载一大堆东西） 内存占用 设计模式 单例模式（重点） 工厂模式（重点） 观察者模式（重点） 依赖注入（重点） 装饰器模式 代理模式 组合模式 安全篇 SQL 注入 XSS 与 CSRF 输入过滤 Cookie 安全 禁用 mysql_ 系函数 数据库存储用户密码时，应该是怎么做才安全 验证码 Session 问题 安全的 Session ID （让即使拦截后，也无法模拟使用） 目录权限安全 包含本地与远程文件 文件上传 PHP 脚本 eval 函数执行脚本 disable_functions 关闭高危函数 FPM 独立用户与组，给每个目录特定权限 了解 Hash 与 Encrypt 区别 高阶篇 PHP 数组底层实现 （HashTable + Linked list） Copy on write 原理，何时 GC PHP 进程模型，进程通讯方式，进程线程区别 yield 核心原理是什么 PDO prepare 原理 PHP 7 与 PHP 5 有什么区别 Swoole 适用场景，协程实现方式 前端篇 原生获取 DOM 节点，属性 盒子模型 CSS 文件、style 标签、行内 style 属性优先级 HTML 与 JS 运行顺序（页面 JS 从上到下） JS 数组操作 类型判断 this 作用域 .map() 与 this 具体使用场景分析 Cookie 读写 JQuery 操作 Ajax 请求（同步、异步区别）随机数禁止缓存 Bootstrap 有什么好处 跨域请求 N 种解决方案 新技术（了解） ES6 模块化 打包 构建工具 vue、react、webpack、 前端 mvc 优化 浏览器单域名并发数限制 静态资源缓存 304 （If-Modified-Since 以及 Etag 原理） 多个小图标合并使用 position 定位技术 减少请求 静态资源合为单次请求 并压缩 CDN 静态资源延迟加载技术、预加载技术 keep-alive CSS 在头部，JS 在尾部的优化（原理） 网络篇 IP 地址转 INT 192.168.0.1/16 是什么意思 DNS 主要作用是什么？ IPv4 与 v6 区别 网络编程篇 TCP 三次握手流程 TCP、UDP 区别，分别适用场景 有什么办法能保证 UDP 高可用性(了解) TCP 粘包如何解决？ 为什么需要心跳？ 什么是长连接？ HTTPS 是怎么保证安全的？ 流与数据报的区别 进程间通信几种方式，最快的是哪种？ fork() 会发生什么？ API 篇 RESTful 是什么 如何在不支持 DELETE 请求的浏览器上兼容 DELETE 请求 常见 API 的 APP_ID APP_SECRET 主要作用是什么？阐述下流程 API 请求如何保证数据不被篡改？ JSON 和 JSONP 的区别 数据加密和验签的区别 RSA 是什么 API 版本兼容怎么处理 限流（木桶、令牌桶） OAuth 2 主要用在哪些场景下 JWT PHP 中 json_encode([&#39;key&#39;=&gt;123]); 与 return json_encode([]); 区别，会产生什么问题？如何解决 加分项 了解常用语言特性，及不同场景适用性。 PHP VS Golang PHP VS Python PHP VS JAVA 了解 PHP 扩展开发 熟练掌握 C]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[API]]></title>
    <url>%2F2018%2F09%2F26%2FAPI%2F</url>
    <content type="text"><![CDATA[API 篇RESTful 是什么 RESTful是一种软件设计风格，全称是：Representational State Transfer（表现层状态转移/用URL定位资源，用HTTP动词描述操作）有哪些RESTful风格的接口？Github API why choose RESTful ？ 接口基本原则：1、安全可靠，高效易扩展2、简单明了，可读性强，没有歧义3、API风格统一，调用规则，传入参数和返回数据有统一的标准 RESTful的设计理念基于HTTP协议，设计原则： 1、HTTPS HTTPS为接口的安全提供了保障，可以有效防止通信被窃听和篡改，可以通过cerbot等工具。Attention：非HTTPS的API调用，不要重定向到HTTPS。而要直接返回调用错误以禁止不安全的调用。 2、域名 应当尽可能的将API和主域名区分开，可以使用专用的域名：https://api.zoe.comOrhttps://www.zoe.com/api 3、版本控制 第一种：将版本号直接加入到URL中12https://api.zoe.com/v1https://api.zoe.com/v2 第二种：使用http请求头的accept字段进行区分（推荐）123Https://api.zoe.com/ Accept:application/prs.zoe.va+json Accept:application/prs.zoe.va+json 4、用URL定位资源 在REST福利的架构中，所有的一切都表示资源，每个URL都代表一个资源（名词），而且大部分情况下资源是名词的复数，尽量不要在URL中出现动词。Such as：(冒号开始的代表变量)1234567GET /issues 列出所有的 issueGET /orgs/:org/issues 列出某个项目的 issueGET /repos/:owner/:repo/issues/:number 获取某个项目的某个 issuePOST /repos/:owner/:repo/issues 为某个项目创建 issuePATCH /repos/:owner/:repo/issues/:number 修改某个 issuePUT /repos/:owner/:repo/issues/:number/lock 锁住某个 issueDELETE /repos/:owner/:repo/issues/:number/lock 接收某个 issue 总结：1、资源的设计可以嵌套，表明资源与资源之间的关系2、大部分情况下访问的是某个资源集合，想要得到单个资源，可以通过资源的id或者number等唯一标识获取。3、某些情况下，资源会是单数形式，例如某个项目某个issue的锁，每个issue只会有一把锁，所以是单数错误的例子：1234POST https://api.larabbs.com/createTopicGET https://api.larabbs.com/topic/show/1POST https://api.larabbs.com/topics/1/comments/createPOST https://api.larabbs.com/topics/1/comments/100/delete 正确的例子:1234POST https://api.larabbs.com/topicsGET https://api.larabbs.com/topics/1POST https://api.larabbs.com/topics/1/commentsDELETE https://api.larabbs.com/topics/1/comments/100 5、用http动词描述操作 http设计了很多动词来表示不同的操作，RESTful吧这些利用的很好，来表明如何操作资源。幂等性：指一次和多次请求某一个资源应该具有同样的副作用，也就是一次访问和多次访问，对这个资源带来的变化是相同的。常见的动词及幂等性：|动词|描述|是否幂等性||:—- |:—|:—– ||GET|获取资源，单个或多个|是||POST|创建资源|否||PUT|更新资源，客户端提供完整的资源数据|是||PATCH|更新资源。客户端提供部分的资源数据|否||DELETE|删除资源|是| 为什么PUT是幂等而patch不是呢？因为put是根据客户端提供了完整的资源数据，客户端提交什么就更新什么，而patch有可能是根据客户端提供的参数，动态的计算出某个值，例如每次请求后资源的某个参数减1，所以多次调用，资源会有不同的变化。 Attention：GET请求对于资源来说是安全的，不允许GET请求改变（更新或创建）资源，但是实际中，为了方便统计类的数据，会有一些例外，例如帖子详情，记录访问次数，每调用一次，访问次数加一。 6、资源过滤 需要提供合理的参数供客户端过滤资源，such as：123?state=closed:不同的状态?page=2&amp;per_page=100:访问第几页数据，每页多少条?sortby=name&amp;order=asc:指定返回结果按照哪个属性排序，以及排序顺序。 7、正确使用状态码 1234567891011121314200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行响应。也可以被用在不创建新资源的 POST 操作上201 Created - 对创建新资源的 POST 操作进行响应。应该带着指向新资源地址的 Location 头202 Accepted - 服务器接受了请求，但是还未处理，响应中应该包含相应的指示信息，告诉客户端该去哪里查询关于本次请求的信息204 No Content - 对不会返回响应体的成功请求进行响应（比如 DELETE 请求）304 Not Modified - HTTP缓存header生效的时候用400 Bad Request - 请求异常，比如请求中的body无法解析401 Unauthorized - 没有进行认证或者认证非法403 Forbidden - 服务器已经理解请求，但是拒绝执行它404 Not Found - 请求一个不存在的资源405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问410 Gone - 表示当前请求的资源不再可用。当调用老版本 API 的时候很有用415 Unsupported Media Type - 如果请求中的内容类型是错误的422 Unprocessable Entity - 用来表示校验错误429 Too Many Requests - 由于请求频次达到上限而被拒绝访问 8、数据响应格式 默认使用json作为数据响应格式，如果客户端需求使用其他的响应格式，例如xml，需要在accept头中指定需要的格式。123Https://api.zoe.com/ Accept:application/prs.zoe.v1+json Accept:application/prs.zoe.v1+xml 对于错误数据，默认使用如下结构：12345‘message’ =&gt; ‘:message’, //错误的具体描述‘errors’ =&gt; ‘:errors’, //参数的具体错误描述，422等状态码提供‘code’ =&gt;’:code’ //自定义的异常码‘status_code’ =&gt; ‘:status_code’,//http状态码‘debug’=&gt;’:debug’, //debug信息，非生产环境提供 例如：1234567891011121314&#123; “message”:”422 Unprocessable Entity”, “errors”:&#123; “name”:[ “姓名必须好听“ ] &#125;, “status+code”:422&#125;&#123; “message”:”您无权访问该订单”, “status_code”:403&#125; 9、调用频率限制 为了防止服务器被攻击，减少服务器压力。需要对接口进行合适的限流控制，在响应头信息中加入合适的信息，告知客户端当前的限流情况：123X-RateLimit-Limit :100 最大访问次数X-RateLimit-Remaining :93 剩余的访问次数X-RateLimit-Reset :1513784506 到该时间点，访问次数会重置为 X-RateLimit-Limit 超过限流次数后，需要返回 429 Too Many Requests 错误。 10、编写文档 为了方便用户使用，我们需要提供清晰的文档，尽可能包括以下几点 • 包括每个接口的请求参数，每个参数的类型限制，是否必填，可选的值等。 • 响应结果的例子说明，包括响应结果中，每个参数的释义。 • 对于某一类接口，需要有尽量详细的文字说明，比如针对一些特定场景，接口应该如何调用。 如何在不支持 DELETE 请求的浏览器上兼容 DELETE 请求 常见 API 的 APP_ID APP_SECRET 主要作用是什么？阐述下流程 客户端（app/浏览器）将用户导向第三方认证服务器 用户在第三方认证服务器，选择是否给予客户端授权 用户同意授权后，认证服务器将用户导向客户端事先指定的重定向URI，同时附上一个授权码。 客户端将授权码发送至服务器，服务器通过授权码以及APP_SECRET向第三方服务器申请access_token 服务器通过access_token，向第三方服务器申请用户数据，完成登陆流程， APP_SECRET 存储在客户端，客户端获取授权码之后，直接通过授权码和 APP_SECRET 去第三方换取 access_token。 APP_SECRET 存储在服务端，客户端获取授权码之后，将授权码发送给服务器，服务器通过授权码和 APP_SECRET 去第三方换取 access_token。（推荐） API 请求如何保证数据不被篡改？ JSON 和 JSONP 的区别谈到ajax会面临两个问题，一个是：AJAX以何种格式来交换数据？另一个：跨域的需求如何解决？比较推崇的方案：用json来传数据，靠jsonp来实现跨域。 json示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 描述一个人var person = &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true&#125;// 获取这个人的信息var personAge = person.Age;// 描述几个人var members = [ &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true &#125;, &#123; &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false &#125;, &#123; &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false &#125;]// 读取其中John的公司名称var johnsCompany = members[1].Company;// 描述一次会议var conference = &#123; &quot;Conference&quot;: &quot;Future Marketing&quot;, &quot;Date&quot;: &quot;2012-6-1&quot;, &quot;Address&quot;: &quot;Beijing&quot;, &quot;Members&quot;: [ &#123; &quot;Name&quot;: &quot;Bob&quot;, &quot;Age&quot;: 32, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true &#125;, &#123; &quot;Name&quot;: &quot;John&quot;, &quot;Age&quot;: 20, &quot;Company&quot;: &quot;Oracle&quot;, &quot;Engineer&quot;: false &#125;, &#123; &quot;Name&quot;: &quot;Henry&quot;, &quot;Age&quot;: 45, &quot;Company&quot;: &quot;Microsoft&quot;, &quot;Engineer&quot;: false &#125; ]&#125;// 读取参会者Henry是否工程师var henryIsAnEngineer = conference.Members[2].Engineer; JSONP Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面还是动态页面，web服务，WCF（？），但是在web页面上调用js文件时不受到跨域的影响（凡是yongyousrc属性的都有跨域的神奇能力），所以可以通过在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理，而处理这些数据的格式可以是json，而且json还被原生js支持，很完美了。 方案如下：Web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，客户端在对json文件成功调用之后，获得了自己所需的数据，这就是jsonp，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住json数据，这样客户端就可以随意定制函数来自动处理返回数据。 具体实现示例：喵喵：远程服务器。cat.com汪汪：本地服务器.dag.com1 miaomiao.js是cat.com根目录下的一个js文件。代码如下：1alert(‘喵呜，我是喵喵’); Jsonp.html是dag.com下的一个页面：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://cat.com/miaomiao.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这里会弹出弹窗，现实跨域成功。 2 在jsonp.html页面定义一个函数。然后在远程文件miaomiao.js中传入数据进行调用。1234567891011121314&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var localHandler = function(data)&#123; alert(&apos;我是dog函数，可以被跨域猫的miaomiao.js文件调用，远程js带来的数据是：&apos; + data.result); &#125;; &lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://cat.com/miaomiao.js”&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; miaomiao.js:1localHandler(&#123;&quot;result&quot;:&quot;我是远程猫js带来的数据&quot;&#125;); 运行之后，显示本地调用成功，并且获取数据。但是如何让miaomiao知道它调用的dog函数叫什么呢？毕竟附近的dog太多了。 3 喵喵和汪汪想了一个办法，如果汪汪想要调用喵喵，就在返回的骨头上加一个标志，说我想调用XXX函数的js代码，你丫别给我传错了啊。于是喵喵就按照骨头上的需求来生成js脚本并且给汪汪一个响应“拿好你的骨头，别搞丢了”汪汪的jsonp.html123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 得到骨头信息查询结果后的回调函数 var boneHandler = function(data)&#123; alert(&apos;你查询的肉骨头结果是：骨头价格 &apos; + data.price + &apos; 元，&apos; + &apos;余骨 &apos; + data.nums + &apos; 块。’); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = &quot;http://cat.com/jsonp/boneResult.aspx?code=pig&amp;callback=boneHandler&quot;; // 创建script标签，设置其属性 var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 上面实现的是编码动态查询，也是jsonp客户端实现的核心。下面是如何完成jsonp调用的全过程。上面url中的code参数表示dog告诉cat我要查询附近猪骨的信息，并且把一个叫callback的骨头给cat，说这是我们的暗号（boneHandler），别和其他狗子搞混了，你把结果都放到这块骨头的这个暗号中给我传过来。于是这个叫做boneResult.aspx的页面生成了一段这样的代码提供给jsonp.html12345boneHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5&#125;); 4 如何用jquery实现？Attention:jquery在处理jsonp类型的ajax时（虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Untitled Page&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; src=jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: &quot;get&quot;, async: false, url: &quot;http://cat.com/jsonp/boneResult.aspx?code=pig”, dataType: &quot;jsonp&quot;, jsonp: &quot;callback&quot;,//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:”boneHandler&quot;,//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据 success: function(json)&#123; alert(&apos;您查询到骨头信息：骨头价格： &apos; + json.price + &apos; 元，余骨： &apos; + json.nums + &apos; 块。’); &#125;, error: function()&#123; alert(&apos;fail&apos;); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext(?)等框架都把jsonp作为ajax的一种形式进行了封装；2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。3、其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ 数据加密和验签的区别 RSA 是什么 API 版本兼容怎么处理 限流（木桶、令牌桶） OAuth 2 主要用在哪些场景下 JWT PHP 中 json_encode([&#39;key&#39;=&gt;123]); 与 return json_encode([]); 区别，会产生什么问题？如何解决]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个编译器的结构]]></title>
    <url>%2F2018%2F09%2F26%2F%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[编译器主要有两个部分构成的，一个是分析部分，一个是综合部分。 分析部分（analysis）分析部分吧源程序分解成多个组成要素，并在这些要素之上加上语法结构。其实最主要就是对代码进行检查，看看有没有错。没有错的话就会把各种信息存放在一个叫做符号表（symbol table）的数据结构中，符号表和中间表示形式一起传送给综合部分。 综合部分（synthesis）这时候综合部分根据符号表和中间表示形式的信息来构造用户期待的目标程序。 一个编译器的步骤（字节流）-&gt;词法分析器-&gt;(符号流)-&gt;词法分析-&gt;（语法树）-&gt;语义分析-&gt;（语法树）-&gt;中间代码生成器-&gt;中间表示形式-&gt;机器无关代码优化器-&gt;（中间表示形式）-&gt;代码生成器-&gt;（目标机器语言）-&gt;机器相关代码生成器-&gt;（目标机器语言） 词法分析词法分析其实就是把高级语言按照放在符号表里面的数据和运算符号重新组织成有意义的词素（lexeme）的序列。按照这样的形式输出： &lt;token-name,attribute-value&gt;就是编译器把这些语句一个一个按照目标语言所需要的形式先拆分好，后面好直接使用。example:Position = initial + rate * 60词法分析这哥们要做的事呢，就是一个个的重新排列下： position 是一个词素，被映射成词法单元&lt;id,1&gt;,其中这个id就是那个符号表里面对应条目为1的。这哥们为了方便，把position，initial，rate都放到一个符号表里，然后每个都标上了号，里面存放对应的名字类型啥的 赋值符号 = 是一个词素，被映射成词法单元&lt;=&gt;,因为=没有属性值啥的，所以这哥们直接忽略了第二个分量。 initial 你猜被映射成啥样 同 = rate 你猜 同 = 60 是一个词素，被映射成//本来应该是形如&lt;number,4&gt;酱紫的词法单元，4是60对应的条目，这个放后面再说，嗯，书上是这么说的。 所以上面的例子就被词法分析这哥们整合成下面酱紫： &lt;id,1&gt;&lt;=&gt;&lt;id,2&gt;&lt;+&gt;&lt;id,3&gt;&lt;*&gt; 语法分析/解析（syntax analysis/parsing）语法分析这哥们是把上面那哥们分析好的词素创建树形的中间表示。常用的表示方法是语法树，树的每个内部结点表示一个运算，而该节点的子节点表示该运算的分量。按照上面那个例子理解，这里就是理下运算的优先级，比如rate*60肯定先运算的 语义分析(semantic analyzer)语义分析就像一个检查员，把语法树和符号表的信息检查，看是否和语言定义的语义一致，顺便呢，收集一些类型信息，放到语法树或者符号表中，方便随后中间代码生成过程总使用。检查员手动检查工作量太多了，所以这里有个部分就自动化了，程序设计语言可能允许某些类型转换，自动类型转换出现了（coercion）.比如一个二元算术运算符可以应用于一对整数或者一对浮点数，如果这个运算符应用于一个浮点数和一个整数，那么编译器可以把介个整数自动转换成一个浮点数，比如那个60 中间代码生成检查员表示没问题了，然后这里开始为目标语言的生成做准备了，饭都要一口一口吃嘛，不能指望编译器一下子就生成目标语言对吧，这里的中间代码要易于生成而且能被轻松的翻译成目标机器上的语言。 代码优化中间代码生成之后，可能不够美观和简介，于是这里给它梳妆打扮下 代码生成Duang~目标代码生成中。。。 编译器构造工具一些常用的编译器构造工具包括： 语法分析器的生成器 扫描器的生成器 语法制导的翻译引擎 代码生成的生成器 数据流分析引擎 编译器构造工具集 程序设计语言的发展历程 随着20世纪40年代第一台电子计算机的出现，机器语言编程也出现了，由0，1组成。（第一代语言） 后来到了50年代，汇编出现了（第二代语言） 50年代的后五年，用于科学计算的Fortran，商业数据处理的Cobol，用于符号计算的Lisp被开发出来。（第三代语言） 后来C,C++,Java,C#,Ruby,Go,PHP…..（第三代语言-高级程序设计语言） 为特定应用设计的语言，比如用于生成报告的NOMAD，用于数据库查询的SQL…… 给予逻辑和约束的语言，比如Prolog和OPS5 语言的一个简单分类 强制式（imperative） 把程序中指明如何完成一个计算任务的语言称为强制式语言，比如C,C++,Java 声明式（declarative） 把程序中指明要进行那些计算的语言称为声明式语言。 比如ML,Haskell,Prolog 面向对象语言 Simula 67, Smalltalk, C++,C#,Java, RUby…… 冯诺依曼语言 C, Fortran 脚本语言 Awk, JavaScript, Perl, PHP, Python, Ruby……]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自由软件]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%2F</url>
    <content type="text"><![CDATA[所谓“自由软件”就是让你可以自由使用的正版软件，典型代表就是使用GPL许可证的软件，只要软件的许可证是GPL，那么就是自由软件。 1980年，一个叫Richard Stallman的美国程序员，由于无法忍受软件私有化造成的代码封闭，而创立了GPL许可证。 “我试图从总体改变人们接触知识和信息的方式，我认为，个人占有知识，控制人们使用知识或是阻止人们共享知识的企图都是一种蓄意破坏行为。这是一种只有利于这样做的个别人，而代价趋却是使全社会贫困化的行为。” GPL许可证，允许任何人观看、修改，并散播程序软件里的原始程序码，唯一条件是如果你要发布修改后的版本就要连源代码一起公布。 &quot; 大多数软件许可证决意剥夺你的共享和修改软件的自由。对比之下，GNU通用公共许可证GPL力图保证你的共享和修改自由软件的自由。----保证自由软件对所有用户是自由的。GPL适用于大多数自由软件基金会的软件，以及由使用这些软件而承担义务的作者所开发的软件。（自由软件基金会的其他一些软件受GNU库通用许可证的保护）。你也可以将它用到你的程序中。当我们谈到自由软件（free software）时，我们指的是自由而不是价格。&quot; GUN通用公共许可协议]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php中时间戳等相关小概念笔记]]></title>
    <url>%2F2018%2F09%2F25%2Fphp%E4%B8%AD%E6%97%B6%E9%97%B4%E6%88%B3%E7%AD%89%E7%9B%B8%E5%85%B3%E5%B0%8F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[首先说下时间戳吧,因为工作需要,对接接口时要用到各种类型的时间戳,所以抽个时间把这些时间戳整理了下.如果想看看返回的时间戳对不对,这里有个在线转换工具,可以试试时间戳在线转换 获取当前的时间戳是最简单的格式如下:$test = time();它返回当前的 Unix 时间戳.这是返回的结果1487839316 获取当前日期下的零时零点零分的时间戳格式如下:$tmp1 = date(&quot;Y-m-d H:i:s&quot;, mktime(0, 0, 0, date(&quot;m&quot;), date(&#39;d&#39;), date(&quot;Y&quot;)));这个获取的是当前日期下的零时零点零分的时间.打印如下结果:2017-02-23 00:00:00但是这里直接使用strtotime获取的并不是这个时间,他实际返回的是2017-02-23 07:00:00.这个结果和mktime(0, 0, 0, date(&quot;m&quot;), date(&#39;d&#39;), date(&quot;Y&quot;))是一样的.如果想要得到当前日期下的零时零点零分的时间戳,需要这样12345$tmp = mktime(0, 0, 0, date(&quot;m&quot;), date(&apos;d&apos;), date(&quot;Y&quot;));$tmp1 = date(&quot;Y-m-d H:i:s&quot;, mktime(0, 0, 0, date(&quot;m&quot;), date(&apos;d&apos;), date(&quot;Y&quot;)));//显示$tmp2 = strtotime($tmp1)-25200;$tmp3 = $tmp - 25200;//等价于$tmp2print_r($tmp3); 获取前一天(后一天)的零时零点零分的时间戳这个就是对上面的mktime里面的参数进行修改类似这样$day = date(&#39;d&#39;) + 1;顺便说下mktime(时,分,秒,月,日,年),它是取得一个日期的 Unix 时间戳. 获取身份证中出生日期的时间戳首先说下如何从身份证中获取出生日期,当然,在这之前,要知道身份证有15位的和18位的,所以如果是15位的要转换成18位的,方便计算.代码如下:123456789101112131415161718public function getIDCard($idCard) &#123; // 若是15位，则转换成18位；否则直接返回ID if (15 == strlen ( $idCard )) &#123; $W = array (7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2,1 ); $A = array (&quot;1&quot;,&quot;0&quot;,&quot;X&quot;,&quot;9&quot;,&quot;8&quot;,&quot;7&quot;,&quot;6&quot;,&quot;5&quot;,&quot;4&quot;,&quot;3&quot;,&quot;2&quot; ); $s = 0; $idCard18 = substr ( $idCard, 0, 6 ) . &quot;19&quot; . substr ( $idCard, 6 ); $idCard18_len = strlen ( $idCard18 ); for($i = 0; $i &lt; $idCard18_len; $i ++) &#123; $s = $s + substr ( $idCard18, $i, 1 ) * $W [$i]; &#125; $idCard18 .= $A [$s % 11]; // print_r($idCard18);exit(); return $idCard18; &#125; else &#123; return $idCard; &#125; &#125; 然后提取出生日期:12345678910111213141516public function getAgeByID($id) &#123; $length = strlen($id); if(empty($id))&#123; return &quot;&quot;; &#125; if ($length == 18)&#123; $date = strtotime(substr($id, 6, 8)); print_r($date);exit(); return $date; &#125;elseif($length == 15)&#123; $id = $this-&gt;getIDCard($id); $date = strtotime(substr($id, 6, 8)); return $date; &#125; &#125; 后面就可以直接使用这个函数了. json_encode编码有乱码怎么办json_encode($arr, JSON_UNESCAPED_UNICODE) 返回结果处理成数组1234567891011/* * 返回参数处理，对象转化为数组 */ public function object_array($obj) &#123; $_arr = is_object ( $obj ) ? get_object_vars ( $obj ) : $obj; foreach ( $_arr as $key =&gt; $val ) &#123; $val = (is_array ( $val ) || is_object ( $val )) ? $this-&gt;object_array ( $val ) : $val; $arr [$key] = $val; &#125; return $arr; &#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp中的M,D,C,A,I,S方法]]></title>
    <url>%2F2018%2F09%2F25%2Ftp%E4%B8%AD%E7%9A%84M-D-C-A-I-S%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[才开始接触tp，对里面的大写字母方法不是很理解。现在清晰多了。 D方法实例化模型类的时候通常是实例化某个具体的模型类,如果仅仅是对数据表进行基本的ＣＵＲＤ操作的话，可以使用Ｍ方法．由于不要加载具体的模型类，所以性能会更好．如果D方法没有找到定义的模型类，则会自动调用M方法. M方法12345//使用M方法实例化$User = M(&apos;User&apos;);//和用法$User = new \Think\Model (&apos;User&apos;);等效//执行其他的数据操作$User-&gt;select(); M 方法也支持垮库操作.1234//使用M方法实例化,操作db_name中的ot_user表$User = M(&apos;db_name.User&apos;,&apos;ot_&apos;);//执行其他的数据库操作$User-&gt;select(); M方法的参数和\Think\Model的参数是一样的,所以我们可以这样操作:12$New = M(&apos;new&apos;,&apos;think_&apos;,$connection);//等效于$New = new \Think\Model(&apos;new&apos;,&apos;think_&apos;,$connection); M方法实例化的时候.默认的是直接实例化\Think\Model类,如果要实例化其他的公共模型类,可以使用下面:12$User = M(&apos;\Home\Model\CommonModel:User&apos;,&apos;think_&apos;,&apos;db_config&apos;);相当于$User = new \Home\Model\CommonModel(&apos;User&apos;,&apos;think_&apos;,&apos;db_config&apos;); 实例化基础模型类(Model)在没有定义任何模型的时候,可以使用下面的操作.这种方法简单高效,但是缺点就是没有自定义的模型类,无法写入相关的业务逻辑.只能完成基本的CURD操作.如果你的模型类中有自己的业务逻辑,是无法使用M方法的.123456//实例化User模型$User = new Model(&apos;User&apos;);//或者使用M()快捷方法实例化，和上面的方法是等效的$User = M(&apos;User&apos;);//执行其他的数据操作$User-&gt;select(); 实例化其他模型类 第一种因为没有模型类的定义,很难封装一些额外的逻辑方法.如果只是需要扩展一些通用的逻辑,可以尝试下面方法 1$User = new CommonModel(&apos;User&apos;); 模型的实例化方法有三个参数,第一个参数是模型名称,第二个参数用于设置数据表的前缀(留空则取当前项目配置的表前缀),第三个参数用于设置当前使用的数据库连接信息(留空则取当前项目配置的数据库连接信息). 1$User = new CommonModel(&apos;User&apos;,&apos;think_&apos;,&apos;db_config&apos;); 第三个使用M方法 1$User = M(&apos;CommonModel:User&apos;,&apos;think_&apos;,&apos;db_config&apos;); Ｍ方法默认是实例化ｍｏｄｅｌ类 D方法123456&lt;?php//实例化模型$User = D(&apos;User&apos;);//相当于$User = new \Home\Model\UserModel();//执行操作$User -&gt; select(); 如果Home\Model\UserModel不存在的话,就会尝试实例化公共模型下的\Common\Model\UserModel类.D方法的参数就是实例的名称.并且和模型类的大小写定义是一致的. 参数 实例化的模型文件（假设当前模块为Home） User 对应的模型类文件的 \Home\Model\UserModel.class.php UserType 对应的模型类文件的 \Home\Model\UserTypeModel.class.php 如果在Liunx下,要注意大小写 D方法可以自动检测模型类,如果存在自定义的模型类,则实例化自定义模型类,如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复去实例化。12345//D方法还可以跨模块调用,需要使用//实例化Admin的User模型D(&apos;Admin/User&apos;);//实例化Extend扩展命名空间下的Info模型D(&apos;Extend://Editor/Info&apos;): 注意：跨模块实例化模型类的时候，不支持自动加载公共模块的模型类。 C方法 定义了配置文件之后,可以使用系统提供的C方法来读取已有额配置. 获取已经设置的参数值:C(‘参数名称’)1$model = C(&apos;URL_MODEL&apos;);//不区分大小写=url_model but 大写是比较规范的.注意:配置参数名称中不能含有”.”和特殊字符如果URL_MODEL尚未存在设置,则返回NULL.123//如果是3.2.1版本的话,支持设置默认值.such asC(&apos;my_config&apos;,&apos;null&apos;,&apos;default_config&apos;);//如果my_config没有设置的话,则返回default_config C方法ue可以用于读取二维配置:12//获取用户配置中的用户类型设置C(&apos;USER_CONFIG.USER_TYPE&apos;); 因为配置参数是全局有效的,因此C方法可以在任何地方读取任何配置,即使某个设置参数以及生效过期了 A方法如果需要跨控制机调用的话,可以单独实例化1234//实例化Home模块的User控制器$User = new \Home\Controller\UserController();//实例化Admin模块的blog控制器$Blog = new \Admin\Controller\BlogController(); 上面的代码是不是很多,这里提供了一个快捷调用方法A简化后如下123//假设当前模块是Home模块$User = A(&apos;User&apos;);$Blog = A(&apos;Admin/Blog&apos;); 默认情况下,A方法实例化的是默认控制器(Controller),如果你要实例化其他的分层控制器的话,可以使用1234//假设当前模块是Home//实例化Event控制器$User = A(&apos;User&apos;);// 等效于new \Home\Event\UserEvent();$Blog = A(&apos;Admin/Blog&apos;,&apos;Event&apos;);// 等效于new \Admin\Event\BlogEvent(); I方法在web开发过程中,我们经常要获取系统变量或者用户提交的数据.这些数据处理不好就会引起安全隐患,所以tp给我们提供了一个变量获取功能.我们先看下传统获取方式:12345$id = $_GET[&apos;id&apos;]; // 获取get变量$name = $_POST[&apos;name&apos;]; // 获取post变量$value = $_SESSION[&apos;var&apos;]; // 获取session变量$name = $_COOKIE[&apos;name&apos;]; // 获取cookie变量$file = $_SERVER[&apos;PHP_SELF&apos;]; // 获取server变量 传统获取方法没有统一的安全机制,后期调整比较麻烦,更好的方式是在框架中统一使用I函数进行变量获取和过滤。I方法是ThinkPHP用于更加方便和安全的获取系统输入变量，可以用于任何地方，用法格式如下：1I(&apos;变量类型.变量名/修饰符&apos;,[&apos;默认值&apos;],[&apos;过滤方法或正则&apos;],[&apos;额外数据源&apos;]) 变量类型是指请求方式或者输入类型 变量类型 含义 get 获取GET参数 post 获取POST参数 param 自动判断请求类型获取GET、POST或者PUT参数 request 获取REQUEST 参数 put 获取PUT 参数 session 获取 $_SESSION 参数 cookie 获取 $_COOKIE 参数 server 获取 $_SERVER 参数 globals 获取 $GLOBALS参数 path 获取 PATHINFO模式的URL参数 data 获取 其他类型的参数，需要配合额外数据源参数 注意：变量类型不区分大小写，变量名则严格区分大小写。 默认值和过滤方法均属于可选参数。下面是I方法的范例使用12echo I(&apos;get.id&apos;); // 相当于 $_GET[&apos;id&apos;]echo I(&apos;get.name&apos;); // 相当于 $_GET[&apos;name&apos;] 支持默认值:12echo I(&apos;get.id&apos;,0); // 如果不存在$_GET[&apos;id&apos;] 则返回0echo I(&apos;get.name&apos;,&apos;&apos;); // 如果不存在$_GET[&apos;name&apos;] 则返回空字符串 采用方法过滤:12// 采用htmlspecialchars方法对$_GET[&apos;name&apos;] 进行过滤，如果不存在则返回空字符串echo I(&apos;get.name&apos;,&apos;&apos;,&apos;htmlspecialchars&apos;); 支持直接获取整个变量值12// 获取整个$_GET 数组I(&apos;get.&apos;); 用同样的方式，我们可以获取post或者其他输入类型的变量12345678I(&apos;post.name&apos;,&apos;&apos;,&apos;htmlspecialchars&apos;); // 采用htmlspecialchars方法对$_POST[&apos;name&apos;] 进行过滤，如果不存在则返回空字符串I(&apos;session.user_id&apos;,0); // 获取$_SESSION[&apos;user_id&apos;] 如果不存在则默认为0I(&apos;cookie.&apos;); // 获取整个 $_COOKIE 数组I(&apos;server.REQUEST_METHOD&apos;); // 获取 $_SERVER[&apos;REQUEST_METHOD&apos;] param变量类型是框架特有的支持自动判断当前请求类型的变量获取方式，例如：1echo I(&apos;param.id&apos;); 如果当前请求类型是GET，那么等效于 $_GET[‘id’]，如果当前请求类型是POST或者PUT，那么相当于获取 $_POST[‘id’] 或者 PUT参数id。由于param类型是I函数默认获取的变量类型，因此事实上param变量类型的写法可以简化为：1234I(&apos;id&apos;); // 等同于 I(&apos;param.id&apos;)I(&apos;name&apos;); // 等同于 I(&apos;param.name&apos;) path类型变量可以用于获取URL参数（必须是PATHINFO模式参数有效，无论是GET还是POST方式都有效），例如： 当前访问URL地址是 http://serverName/index.php/New/2013/06/01123456echo I(&apos;path.1&apos;); // 输出2013echo I(&apos;path.2&apos;); // 输出06echo I(&apos;path.3&apos;); // 输出01 data类型变量可以用于获取不支持的变量类型的读取，例如：1I(&apos;data.file1&apos;,&apos;&apos;,&apos;&apos;,$_FILES); 变量过滤如果你没有在调用I函数的时候指定过滤方法的话，系统会采用默认的过滤机制（由DEFAULT_FILTER配置），事实上，该参数的默认设置是：12// 系统默认的变量过滤机制&apos;DEFAULT_FILTER&apos; =&gt; &apos;htmlspecialchars&apos; 也就说，I方法的所有获取变量如果没有设置过滤方法的话都会进行htmlspecialchars过滤，那么：12// 等同于 htmlspecialchars($_GET[&apos;name&apos;])I(&apos;get.name&apos;); 同样，该参数也可以设置支持多个过滤，例如：1&apos;DEFAULT_FILTER&apos; =&gt; &apos;strip_tags,htmlspecialchars&apos; 设置后，我们在使用：12// 等同于 htmlspecialchars(strip_tags($_GET[&apos;name&apos;]))I(&apos;get.name&apos;); 如果我们在使用I方法的时候 指定了过滤方法，那么就会忽略DEFAULT_FILTER的设置，例如:12// 等同于 strip_tags($_GET[&apos;name&apos;])echo I(&apos;get.name&apos;,&apos;&apos;,&apos;strip_tags&apos;); I方法的第三个参数如果传入函数名，则表示调用该函数对变量进行过滤并返回（在变量是数组的情况下自动使用array_map进行过滤处理），否则会调用PHP内置的filter_var方法进行过滤处理，例如：1I(&apos;post.email&apos;,&apos;&apos;,FILTER_VALIDATE_EMAIL); 表示 会对$_POST[‘email’] 进行 格式验证，如果不符合要求的话，返回空字符串。 （关于更多的验证格式，可以参考 官方手册的filter_var用法。） 或者可以用下面的字符标识方式：1I(&apos;post.email&apos;,&apos;&apos;,&apos;email&apos;); 可以支持的过滤名称必须是filter_list方法中的有效值（不同的服务器环境可能有所不同），可能支持的包括：123456789101112131415161718intbooleanfloatvalidate_regexpvalidate_urlvalidate_emailvalidate_ipstringstrippedencodedspecial_charsunsafe_rawemailurlnumber_intnumber_floatmagic_quotescallback 还可以支持进行正则匹配过滤，例如：123// 采用正则表达式进行变量过滤I(&apos;get.name&apos;,&apos;&apos;,&apos;/^[A-Za-z]+$/&apos;);I(&apos;get.id&apos;,0,&apos;/^\d+$/&apos;); 如果正则匹配不通过的话，则返回默认值。在有些特殊的情况下，我们不希望进行任何过滤，即使DEFAULT_FILTER已经有所设置，可以使用：123// 下面两种方式都不采用任何过滤方法I(&apos;get.name&apos;,&apos;&apos;,&apos;&apos;);I(&apos;get.id&apos;,&apos;&apos;,false); 一旦过滤参数设置为空字符串或者false，即表示不再进行任何的过滤。最新版本的I函数支持对变量使用修饰符功能，可以更方便的通过类型过滤变量。1I(&apos;变量类型.变量名/修饰符&apos;) 123456I(&apos;get.id/d&apos;); // 强制变量转换为整型I(&apos;post.name/s&apos;); // 强制转换变量为字符串类型I(&apos;post.ids/a&apos;); // 强制变量转换为数组类型 可以使用的修饰符包括： 修饰符 作用 s 强制转换为字符串类型 d 强制转换为整型类型 b 强制转换为布尔类型 a 强制转换为数组类型 f 强制转换为浮点类型]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由,模块化设计,命名空间]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%B7%AF%E7%94%B1-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[ThinkPHP采用模块化的架构思想,可以支持多模块应用的创建,让应用的扩展更加方便.先简单说下路由规则: 什么是路由?系统从url参数中分析当前请求的分组(平台),控制器和操作方法的过程就是路由.tp框架路由共有四种形式 基本get形式http://网址/index.php?m=分组&amp;c=控制器&amp;a=操作方法该方式是最底层的get形式、传统的参数传递方式，不时尚、不安全。 PATHINFO路径形式(默认方式)http://网址/index.php/分组/控制器/操作方法比如:http://网址/index.php/Home/Index/advert rewrite重写形式(伪静态技术)省略index.php入口文件(URL模式不可用)http://网址/分组/控制器/操作方法http://网址/Home/Index/index 兼容形式http://网址/index.php?s=/分组/控制器/操作方法http://网址/index.php?s=/Home/Index/advert注意不要忘了加接口文件自动生成模块目录如果我们需要生成一个Admin模块用于后台应用，在应用入口文件中定义如下：1234// 绑定Admin模块到当前入口文件define(&apos;BIND_MODULE&apos;,&apos;Admin&apos;);define(&apos;APP_PATH&apos;,&apos;./Application/&apos;);require &apos;./ThinkPHP/ThinkPHP.php&apos;;/ /可不要 如果需要生成更多的控制器类，可以定义BUILD_CONTROLLER_LIST常量.12345// 绑定Admin模块到当前入口文件define(&apos;BIND_MODULE&apos;,&apos;Admin&apos;);define(&apos;BUILD_CONTROLLER_LIST&apos;,&apos;Index,User,Menu&apos;);define(&apos;APP_PATH&apos;,&apos;./Application/&apos;);require &apos;./ThinkPHP/ThinkPHP.php&apos;; 注意：默认生成的控制器类都是继承Think\Controller，如果需要继承其他的公共类需要另外调整。 如果在应用的公共配置文件中设置关闭了 APP_USE_NAMESPACE的话，生成的控制器类则不会采用命名空间定义。 命名空间 什么是命名空间?在php程序语言里边，语法规则要求同名称的函数、类名、常量在一个请求里边不允许出现多次。如果有的应用程序不得已必须出现多个同名的 函数、类名、常量，那么我们就可以把它们放到不同的空间里边做请求。这个不同的空间就称作“命名空间”。同一个请求里边定义两个同名的函数getInfo()，右图由于有使用命名空间，使得程序可以正常执行。同名称的两个函数在同一个空间进行访问系统要报错.同名称的两个函数放到不同空间做访问，就不会报错 使用命名空间通过namespace关键字声明命名空间。namespace 空间名称;(空间名称 按照php正确的命名方式定义即可)命名空间针对 函数、类名、const常量 三部分起作用，并统称为“元素”。常量的声明：123define(名称，值); //(在类外部声明常量)与命名空间没有关系//同名称常量只能define一次const 名称=值; //与命名空间有关系 ① const可以在类的内部声明常量信息(类常量)② const也可以在类外部声明常量(正常常量)使用命名空间的时候const可以放到类外部声明常量。同名称的多个常量，可以分别定义到不同的“命名空间”里边const和define的区别：前者针对命名空间发生影响，后者不发生影响。const可以声明多个同名称的常量define对同名称常量只能声明一个空间元素的访问(当前空间、其他空间)：子级(多级)空间 命名空间可以让我们存放许多元素(函数、类、常量)，有的时候元素比较多，为了管理方便，可以对元素进行分门别类地存储。也就是说命名空间可以设置为多级空间。多级空间的最后一级空间就称为“子级空间”多级空间的声明及空间元素的访问：空间元素访问的三种形式① 非限定名称1234echo Animal::$name; 就近访问上边与其挨着最近空间的Animal元素(类似php引入文件：include “common.php”; //相对路径引入当前目录下的common.php文件) ② 限定名称12echo beijing\Animal::$name; // 把当前空间 和 beijing空间联合获得Animal元素(类似php引入文件：include “Common/Conf/config.php”; 相对路径) ③ 完全限定名称 echo \beijing\Animal::$name; //访问beijing空间的Animal元素 (类似php引入文件：include “d:/web/1121/Conf/common.php”; 绝对路径引入文件) 访问空间元素的两种方式：限定名称访问元素：限定名称访问元素的特殊情况，linken被巧合访问到：引入机制命名空间可以声明为多级空间，这个多级空间元素在其他空间内部访问的时候，不得已需要通过 完全限定名称 方式，这个完全限定名称不方便开发、维护，为了降低代码的复杂度，可以在当前的空间把指定的空间给引入进来，进而可以方便地通过“限定名称”的方便的形式使用其他空间的元素。空间引入use 空间;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的公钥和私钥]]></title>
    <url>%2F2018%2F09%2F25%2Fphp%E4%B8%AD%E7%9A%84%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%2F</url>
    <content type="text"><![CDATA[最近公司业务需要用到公钥和私钥,之前接触的很少,不是很了解,刚刚上网了解了下.发现很多地方都要用到加密.有对称加密算法（ DES,AES）[加密和解密都使用一个密钥]和不对称加密算法(RSA).这里说的是RSA（非对称加密算法）.RSA就涉及到公钥和私钥.要记住的就是:公钥加密,私钥解密.私钥加密,公钥解密. RSA加密:SHA-1(杀one)中的RSA算法核心特点:有一个公钥,有一个私钥,二者是一套,且每一套都是独一无二的.再无第二套一模一样的.公钥可以随便给人,但私钥确是不可外传的.公钥私钥都可以进行加密解密,哪个加的密,就必须用这一套的另外一个钥进行解密.钥的加密实际就是一个规则 什么是公钥加密?假设一下，两个字母，一个是a，一个是b。我喜欢b这个数字，就保留起来，不告诉你们(私钥），然后我告诉大家，a是我的公钥。我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道b就是解密的私钥啊，所以他解不开，只有我可以用数字b，就是我的私钥，来解密。这样我就可以保护数据了。某人用我的公钥a加密了字符hello，加密后成了xxxxx，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道b就是我的私钥，只有我才能解密，解密后就得到hello。这样，我们就可以传送加密的数据了。 私钥签名如果我用私钥加密一段数据（当然只有我可以用私钥加密，因为只有我知道b是我的私钥），结果所有的人都看到我的内容了，因为他们都知道我的公钥是a，那么这种加密有什么用处呢？某人说有人冒充我给他发信。怎么办呢？我把我要发的信，内容是c，用我的私钥b，加密，加密后的内容是d，发给某人，再告诉他解密看是不是c。他用我的公钥a解密，发现果然是c。这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。这样我们就能确认发送方身份了。这个过程叫做数字签名。当然具体的过程要稍微复杂一些。用私钥来加密数据，用途就是数字签名。公钥和私钥是成对的，它们互相解密。公钥加密，私钥解密。私钥数字签名，公钥验证。 下面贴上php中使用公钥私钥加密解密的代码以及其中需要注意的地方:首先公钥和私钥存放的方式有文件和字符串的形式.不过作为小白要注意的是,公钥私钥无论是放在文件中还是字符串里面,千万要记得分行.我刚开始一直不分行,然后就是老是出错,后来才知道要分行.而且不要忘了前后的注释行.—–BEGIN PUBLIC KEY—–下面这段是错误的123-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADxdfxfgcghCBiQKBgQCIgm80UzfD9lQ/tnASRCapNNaoTcodUfDzNYLWAxEMp8EtWkD4eZmWbMdaWKyShIOGS48NKdVGsAB+F4usW1VFtrbqOfKgBUxMJKz1YcciBiV3kvhHZI4/jq94E0qy1jxTNdralRhe+0/JklopEM9QWZScpBT4IXBfbMJ3JD5doQIDAQAB-----END PUBLIC KEY----- 这段代码形式才是正确的123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCIgm80UzfD9lQ/tnASRCapNNaoTcodUfDzNYLWAxEMp8EtWkD4eZmWbMdaWKyShIOGS48NKdVGsAB+F4usW1VFtrbqOfKgBUxMJKz1YcciBiV3kvhHZI4/jq94E0qy1jxTNdralRhe+0/JklopEM9QWZScpBT4IXBfbMJ3JD5doQIDAQAB-----END PUBLIC KEY----- 解决的公钥私钥的存放,然后就是代码中需要用到的加密解密了,加签解签了.其中用到的函数可以直接在php手册加密中查看http://php.net/manual/zh/refs.crypto.php首先是公钥加密:这里用到的函数是openssl_public_encrypt(http://php.net/manual/zh/function.openssl-public-encrypt.php)123456789101112131415public function encrypt($data,$key_path)&#123; $key = file_get_contents($key_path); $encryptedList = array(); $step = 117; $encryptedData = &apos;&apos;; $len = strlen($data); for ($i = 0; $i &lt; $len; $i += $step) &#123; $tmpData = substr($data, $i, $step); $encrypted = &apos;&apos;; openssl_public_encrypt($tmpData, $encrypted, $key,OPENSSL_PKCS1_PADDING); $encryptedList[] = ($encrypted); &#125; $encryptedData = base64_encode(join(&apos;&apos;, $encryptedList)); return $encryptedData;&#125; 用私钥解密(用到的函数openssl_private_decrypt)123456789101112131415private function decrypt($encryptedData)&#123; if (empty($encryptedData)) &#123; return &apos;&apos;; &#125; $encryptedData = base64_decode($encryptedData); $decryptedList = array(); $step = 128; $len = strlen($encryptedData); for ($i = 0; $i &lt; $len; $i += $step) &#123; $data = substr($encryptedData, $i, $step); $decrypted = &apos;&apos;; openssl_private_decrypt($data, $decrypted, file_get_contents($this-&gt;_key_pri), OPENSSL_PKCS1_PADDING); $decryptedList[] = $decrypted; &#125; return join(&apos;&apos;, $decryptedList); 用私钥加签,用到的函数(openssl_get_privatekey)1234567private function rsa_sign($data)&#123; //私钥加签 $res = openssl_get_privatekey(file_get_contents($this-&gt;_key_priva_mime)); openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA1); openssl_free_key($res); $sign = base64_encode($sign); return $sign; 公钥验签(openssl_get_publickey)1234567private function _rsaCheckSign($data, $sign)&#123; $pubKey = file_get_contents($this-&gt;_key_pub_mime); $res = openssl_get_publickey($pubKey); $result = (bool)openssl_verify($data, base64_decode($sign), $res); openssl_free_key($res); return $result; &#125; ps:如果是文件形式的公私钥,需要使用file_get_contents,括号中可以是地址.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>公钥</tag>
        <tag>私钥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器和解释器]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Q &amp; A编译器和解释器之间的区别是什么？编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？把一种高级语言翻译成另一种高级语言的编译器成为源到源（source-to-source）的翻译器。编译器使用C语言作为目标语言有什么好处？描述一下汇编器所要完成的一些任务。 编译器和解释器之间的区别是什么？什么是编译器A compiler is a computer program that transforms code written in a high-level programming language into the machine code. It is a program which translates the human-readable code to a language a computer processor understands (binary 1 and 0 bits). The computer processes the machine code to perform the corresponding tasks.A compiler should comply with the syntax rule of that programming language in which it is written. However, the compiler is only a program and cannot fix errors found in that program. So, if you make a mistake, you need to make changes in the syntax of your program. Otherwise, it will not compile. 编译器是一种计算机程序，它将用高级编程语言编写的代码转换为机器代码。它是一个程序，它将人类可读的代码翻译成计算机处理器理解的语言（二进制1和0位）。计算机处理机器代码以执行相应的任务。 编译器应遵循编写它的编程语言的语法规则。但是，编译器只是一个程序，无法修复该程序中发现的错误。因此，如果犯了错误，则需要更改程序的语法。否则，它将无法编译。 什么是解释器？An interpreter is a computer program, which coverts each high-level program statement into the machine code. This includes source code, pre-compiled code, and scripts. Both compiler and interpreters do the same job which is converting higher level programming language to machine code. However, a compiler will convert the code into machine code (create an exe) before program run. Interpreters convert code into machine code when the program is run. 解释器是一种计算机程序，它将每个高级程序语句转换为机器代码。这包括源代码，预编译代码和脚本。编译器和解释器都执行相同的工作，即将更高级别的编程语言转换为机器代码。但是，编译器会在程序运行之前将代码转换为机器代码（创建exe）。解释程序在程序运行时将代码转换为机器代码。 比较点 编译器 解释器 编程步骤 创建程序-&gt;编译器会分析是否正确，如果有问题提就抛出来，没有-&gt;将源代码转化成机器代码-&gt;它将不同的代码文件链接到一个可运行的程序-&gt;执行 创建程序-&gt;不链接文件或者生成机器代码-&gt;在执行期间逐行执行源语句 优势 这段程序以及被翻译成机器代码，代码执行时间更少 解释器更加方便使用，尤其是对新手来说 劣势 改变程序必须返回到源代码修改 解释程序必须在具有相应解释器的计算机上运行。 机器编码 将机器语言存储为磁盘上的机器代码 根本不保存机器代码 运行时间 编译代码运行得更快 解释的代码运行速度较慢 模型 它基于语言翻译链接加载模型。 它基于解释方法。 编码生成 生成输出程序（以exe的形式），可以独立于原始程序运行。 不生成输出程序。因此，他们在执行期间每次都会评估源程序。 运行 程序执行与编译分开。它仅在编译完整个输出程序后执行。 程序执行是解释过程的一部分，因此它是逐行执行的。 内存要求 目标程序是独立执行的，不需要内存中的编译器。 解释器在解释期间存在于解释器中。 最适合 限制在特定的目标机器上，无法移植。 C和C ++是最流行的一种使用编译模型的编程语言 对于Web环境，加载时间很重要。由于所有详尽的分析都已完成，编译需要相对较长的时间来编译甚至可能无法多次运行的小代码。在这种情况下，解释器会更好。 代码优化 编译器可以预先查看整个代码。因此，它们执行大量优化，使代码运行得更快 解释器逐行查看代码，因此优化不如编译器强大 动态打印 难以实现，因为编译器无法预测转折时会发生什么。 解释语言支持动态打字 环境 它最适合生产环境 它最适合程序和开发环境。 错误执行 编译器在编译时显示所有错误和警告。因此，无法在不修复错误的情况下运行程序 解释器读取单个语句并显示错误（如果有）。您必须更正错误以解释下一行。 输入 它需要一个完整的程序 它需要一行代码。 输出 编译器生成中间机器代码。 解释器不生成中间机器代码。 错误 同时显示编译后的所有错误。 逐个显示每行的所有错误 语言 C,C++,C#,Scala,Java all use compiler PHP,Perl,Ruby uses an interpreter]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp中遇到的相关方法]]></title>
    <url>%2F2018%2F09%2F25%2Ftp%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[getDbFields这个方法在tp手册的字段定义中通常每个模型类是操作某个数据表，在大多数情况下，系统会自动获取当前数据表的字段信息。系统会在模型首次实例化的时候自动获取数据表的字段信息（而且只需要一次，以后会永久缓存字段信息，除非设置不缓存或者删除），如果是调试模式则不会生成字段缓存文件，则表示每次都会重新获取数据表字段信息。字段缓存保存在Runtime/Data/_fields/ 目录下面，缓存机制是每个模型对应一个字段缓存文件（注意：并非每个数据表对应一个字段缓存文件），命名格式是：数据库名.数据表前缀+模型名（小写）.php12demo.think_user.php // User模型生成的字段缓存文件demo.top_article.php // Article模型生成的字段缓存文件 字段缓存包括数据表的字段信息、主键字段和是否自动增长，如果开启字段类型验证的话还包括字段类型信息等等，无论是用M方法还是D方法，或者用原生的实例化模型类一般情况下只要是不开启调试模式都会生成字段缓存（字段缓存可以单独设置关闭）。可以通过设置DB_FIELDS_CACHE 参数来关闭字段自动缓存，如果在开发的时候经常变动数据库的结构，而不希望进行数据表的字段缓存，可以在项目配置文件中增加如下配置：12// 关闭字段缓存&apos;DB_FIELDS_CACHE&apos;=&gt;false 注意：调试模式下面由于考虑到数据结构可能会经常变动，所以默认是关闭字段缓存的。如果需要显式获取当前数据表的字段信息，可以使用模型类的getDbFields方法来获取当前数据对象的全部字段信息，例如：12$User = M(&apos;User&apos;);$fields = $User-&gt;getDbFields(); 如果你在部署模式下面修改了数据表的字段信息，可能需要清空Data/_fields目录下面的缓存文件，让系统重新获取更新的数据表字段信息，否则会发生新增的字段无法写入数据库的问题。 如果不希望依赖字段缓存或者想提高性能，也可以在模型类里面手动定义数据表字段的名称，可以避免IO加载的效率开销，例如：12345678namespace Home\Model;use Think\Model;class UserModel extends Model &#123; protected $fields = array(&apos;id&apos;, &apos;username&apos;, &apos;email&apos;, &apos;age&apos;); protected $pk = &apos;id&apos;;//pk属性定义当前数据表的主键名，默认值就是id，因此如果是id的话可以无需定义&#125; 如果你的数据表使用了复合主键，可以这样定义：123456namespace Home\Model;use Think\Model;class ScoreModel extends Model &#123; protected $fields = array(&apos;user_id&apos;, &apos;lession_id&apos;,&apos;score&apos;); protected $pk = array(&apos;user_id&apos;,&apos;lession_id&apos;);&#125; 除了可以设置数据表的字段之外，我们还可以定义字段的类型，用于某些验证环节。例如：12345namespace Home\Model;use Think\Model;class UserModel extends Model &#123; protected $fields = array(&apos;id&apos;, &apos;username&apos;, &apos;email&apos;, &apos;age&apos;, &apos;_type&apos;=&gt;array(&apos;id&apos;=&gt;&apos;bigint&apos;,&apos;username&apos;=&gt;&apos;varchar&apos;,&apos;email&apos;=&gt;&apos;varchar&apos;,&apos;age&apos;=&gt;&apos;int&apos;) );&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP多表查询]]></title>
    <url>%2F2018%2F09%2F25%2FThinkPHP%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[这里有两张关联的表(table1,table2),想要通过其中一张表(table1)查询另外一张表(table2)的详细信息.在tp框架中该如何实现呢?(table1) id uid tid 1 66 25 2 67 26 3 68 27 4 68 28 5 70 29 (table2) id name gender 25 张三 男 26 李四 男 27 小花 女 28 小草 女 29 可乐 男 注意,其中uid相同代表是在同一个uid下显示信息. 123456789101112131415161718192021if (I(&apos;post.uid&apos;)) &#123; $map[&apos;uid&apos;] = &apos;68&apos;; $table1 = M(&apos;table1&apos;); if($orderData = $table1-&gt;where($map)-&gt;select())&#123; $data = array(); $table2 = M(&apos;table2&apos;); foreach ($orderData as $v) &#123; $news_map[&apos;id&apos;] = $v[&apos;tid&apos;]; if($myClient = $table2-&gt;where($news_map)-&gt;find())&#123; array_push($data, $myClient); &#125; &#125; $msg[&apos;status&apos;] = 1; $msg[&apos;data&apos;] = $data; $this-&gt;ajaxReturn($msg); &#125; else &#123; $msg[&apos;status&apos;] = 0; $msg[&apos;msg&apos;] = &apos;没有信息！&apos;; $this-&gt;ajaxReturn($msg); &#125; &#125; 返回的json数据如下: 123456789101112131415&#123; &quot;status&quot;: 1, &quot;data&quot;: [ &#123; &quot;id&quot;: &quot;27&quot;, &quot;name&quot;: &quot;小花&quot;, &quot;sex&quot;: &quot;女&quot; &#125;, &#123; &quot;id&quot;: &quot;28&quot;, &quot;name&quot;: &quot;小草&quot;, &quot;sex&quot;: &quot;女&quot; &#125; ]&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>多表查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$this、self和static]]></title>
    <url>%2F2018%2F09%2F25%2F%24this%E3%80%81self%E5%92%8Cstatic%2F</url>
    <content type="text"><![CDATA[$this 只有在类产生实例之后才会存在，我们只是设置一个属性，此时不存在 $this,下图会产生语法错误。 记得这种情况不要使用[0]，[1] 这种写法，全都用常量代替，还有获取一个 pubblic static 属性不需要 new一个实例，app(classA) 这个方式 == new classA 修改如下： 关于类属性、方法调用有3个$this、self、static$this-&gt;foo();selff::foo();static::foo(); $this指向当前对象，用来访问当前对象的非静态变量和非静态方法。123456789101112131415&lt;?phpclass Person &#123; public $name; public function getName() &#123; echo $this-&gt;name; &#125;&#125;$p = new Person();$p2 = new Person();$p-&gt;name = &quot;小红&quot;;$p2-&gt;name = &quot;小明&quot;;$p-&gt;getName(); // 小红$p2-&gt;getName(); // 小明 上面 new 了两个对象，并分别设置对象的 name 属性，getName() 中使用了 this 访问当前对象的 name 属性，所以分别输出了 name 的值。所以说，this 就是指向当前对象，不指向其他对象或类。 self::指向类，一般用来访问当前类的静态变量和静态方法，运行之前已经确定指向哪个类。12345678910111213141516&lt;?phpclass Person &#123; public static $name = &quot;小红&quot;; public static function getName() &#123; echo self::$name; &#125;&#125;$p = new Person();$p2 = new Person();$p::getName(); // 小红$p2::getName(); // 小红$p::$name = &quot;小明&quot;;$p::getName(); // 小明$p2::getName(); // 小明 self 和 this 不同，它指向类本身，不指向任何实例化对象，一般用来访问类中的静态变量和静态方法；上例中 new 了两个对象，并修改了其中一个对象的 name 属性，另一个对象的 name 属性值也改变了，所以说，self 是指向当前类的，和对象无关，所有的对象共用一个值。 static指向类，一般用来访问当前类的静态变量和静态方法，但是又不限于静态的调用，运行时才确定指向哪个类。static 和 self 一样，都是指向类，一般都用来访问类中的静态变量和静态方法，但是又有一些不一样，具体来讲：self 写在哪个类里，实际调用的就是这个类；static 则是写在父类里，然后通过子类用到了这个 static，这个 static 指向的是这个子类，官方称之为 后期静态绑定 。12345678910111213141516171819202122232425&lt;?phpclass A &#123; public function say() &#123; echo &quot;Hello&quot;; &#125; public function saySelf() &#123; self::say(); &#125; public function sayStatic() &#123; static::say(); &#125;&#125;class B extends A &#123; public function say() &#123; echo &quot;World&quot;; &#125;&#125;$b = new B();$b-&gt;say(); // World$b-&gt;saySelf(); // Hello$b-&gt;sayStatic(); // World 上例中可以看到，self 写在 A 类里，调用时就指向了 A 类，static 同样写在 A 类里，但是用 A 类的子类 B 类的对象去调用时，却指向了 B 类，在使用时，static 才确定指向哪个类，这就是 后期静态绑定 。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>self</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json & jsonp]]></title>
    <url>%2F2018%2F09%2F25%2Fjson%20%26%20jsonp%2F</url>
    <content type="text"><![CDATA[对于JSON和JSONP，应该都不陌生，咳咳，不过最初对JSONP有点误解，以为是JSON的另外一个别名，其实二者风马牛不相及。 谈到Json和jsonp就不可避免要提到跨域这个话题了，以前对跨域的理解都是比较模糊的，还以为域名不同就是跨域了，那太狭隘了。非同源请求，均为跨域。 不过为什么会出现跨域？出于浏览器的同源策略限制，浏览器会拒绝跨域请求。严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的： 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向； 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签（主要是有src）； 通常浏览器不允许跨域读操作（Cross-origin reads）。* 等等，上面咋又来了个同源策略，本是同根生，相煎何太急啊。 大家互相开开心心的走亲访友多好。哼，谁知道你是我亲戚还是坏人，万一你来我家是想偷小鱼干的呢？还开开心心，本喵不得哭死啊。 同源策略 (Same-Origin Policy) 最早由 Netscape 公司提出, 所谓同源就是要求, 域名, 协议, 端口相同. 非同源的脚本不能访问或者操作其他域的页面对象(如DOM等). 作为著名的安全策略, 虽然它只是一个规范, 并不强制要求, 但现在所有支持 javaScript 的浏览器都会使用这个策略. 以至于该策略成为浏览器最核心最基本的安全功能, 如果缺少了同源策略, web的安全将无从谈起.（这段文字是cv的） 这下好了，同源策略下的web世界, 域的壁垒高筑, 保证各个网页相互独立, 互相之间不能直接访问, iframe, ajax 均受其限制, 而script标签不受此限制. 注: 如非特别说明, 均指非CORS的, 普通跨域请求. 咳咳，我们讲json呢，扯远了，快回来 哎，哎，相公，别敲我脑袋瓜子啊，疼，敲笨了你就只能有个笨媳妇。人家这不是麻溜的回来了嘛，你倒是给我说说json和惊悚有啥不同。 “你知道啥是json么？” “本大喵当然知道，json是一种数据格式” “手写一段给本汪瞅瞅” 12345678// 描述一个人var person = &#123; &quot;Name&quot;: &quot;大宝&quot;, &quot;Age&quot;: 1, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true&#125; “算你上次没逃课，那你给我说说，这个json有啥要注意的地方？” “咦，json不就简单的数据格式吗，有啥要注意？” “就知道你上次没认真听，肯定开小差了，今晚回去小鱼干没了。” “喵呜～～～人家错了，你再说一遍吧？嘤嘤嘤” “记得下次考你，看仔细了” ■ ■■■■ 这会儿带你认识认识jsonp了，看会儿惊悚片 “喵喵，你知道ajax么？” “听过，但是不太了解” “推荐一个blog，你去看看，下次讲给我听听，答的好有小鱼干吃哟” “猴！得令” Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面还是动态页面，web服务，WCF（喵呜，这是啥？），但是在web页面上调用js文件时不受到跨域的影响（凡是拥有src属性的都有跨域的神奇能力），所以可以通过在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理，而处理这些数据的格式可以是json，而且json还被原生js支持，很完美了。 方案如下： Web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，客户端在对json文件成功调用之后，获得了自己所需的数据，这就是jsonp，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住json数据，这样客户端就可以随意定制函数来自动处理返回数据。 具体实现示例： 喵喵：远程服务器。cat.com 汪汪：本地服务器.dag.com 1 miaomiao.js是cat.com根目录下的一个js文件。 代码如下1&lt;pre style=&quot;margin: 0.5em 0px; padding: 0.4em 0.6em; border-radius: 8px; background: rgb(248, 248, 248); box-sizing: border-box;&quot;&gt;alert(‘喵呜，我是喵喵’);&lt;/pre&gt; Jsonp.html是dag.com下的一个页面： 这里会弹出弹窗，现实跨域成功。 2 在jsonp.html页面定义一个函数。然后在远程文件miaomiao.js中传入数据进行调用。 miaomiao.js: 1localHandler(&#123;&quot;result&quot;:&quot;我是远程猫js带来的数据&quot;&#125;); 运行之后，显示本地调用成功，并且获取数据。但是如何让miaomiao知道它调用的dog函数叫什么呢？毕竟附近的dog太多了。 3 喵喵和汪汪想了一个办法，如果汪汪想要调用喵喵，就在返回的骨头上加一个标志，说我想调用XXX函数的js代码，你丫别给我传错了啊。于是喵喵就按照骨头上的需求来生成js脚本并且给汪汪一个响应“拿好你的骨头，别搞丢了” 汪汪的jsonp.html 上面实现的是编码动态查询，也是jsonp客户端实现的核心。 下面是如何完成jsonp调用的全过程。 上面url中的code参数表示dog告诉cat我要查询附近猪骨的信息，并且把一个叫callback的骨头给cat，说这是我们的暗号（boneHandler），别和其他狗子搞混了，你把结果都放到这块骨头的这个暗号中给我传过来。 于是这个叫做boneResult.aspx的页面生成了一段这样的代码提供给jsonp.html 12345boneHandler(&#123; &quot;code&quot;: &quot;pig&quot;, &quot;price&quot;: 170, &quot;nums&quot;: 5&#125;); 4 如何用jquery实现？ Attention:jquery在处理jsonp类型的ajax时（虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用 1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext(?)等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 3、其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ “傻喵，听懂了么？” 参考资料： 路易斯的blog（推荐看看他的blog，内容满赞的，尤其那个关于mac上使用alfred的技巧，很清晰） 阮一峰的日志 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1eteae3c4sdc0]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>jsop</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[傻喵，保管好小鱼干]]></title>
    <url>%2F2017%2F11%2F07%2F%E5%82%BB%E5%96%B5%EF%BC%8C%E4%BF%9D%E7%AE%A1%E5%A5%BD%E5%B0%8F%E9%B1%BC%E5%B9%B2%2F</url>
    <content type="text"><![CDATA[小鱼干忘了是何时认识傻喵的，都说鱼儿的记忆只有七秒，可是小鱼干遇见傻喵之后竟然破天荒的记住了七秒之后发生的事。 小鱼干在没遇到傻喵之前，发誓要做个吃遍全世界的小鱼儿，当然小鱼干到目前为止，也只吃遍河里的小草。为什么要叫自己小鱼干呢，可能是因为作为一条鱼竟然想要去沙滩上晒日光浴。不可理喻，从那以后大家都叫这货小鱼干了。傻喵在遇见小鱼干之前是一只傲娇的中华田园猫，每天扭着猫步领着铲屎官巡视天下，看好朕的江山。 某一天，小鱼干受邀参加家族中一位表姐的婚礼。表姐是一条小金鱼，表姐夫是一条鲤鱼，小鱼干看见表姐大婚那天穿上了最美的金色鱼尾礼服，还化了美美的妆，小鱼干感觉自己作为一条小鲤鱼，结婚那天肯定不能穿像表姐那样美丽的衣服。也找不到表姐夫那么帅的一条鱼。心情十分低落，音乐想起来，小鱼干坐在贝壳餐桌上，晃着小尾巴开始想心事，时间一秒一秒过去了，过了七秒，小鱼干发现桌上已经上了好几道菜，开心的吃了起来，完全忘了刚刚的小心事。 其实鱼的记忆不是只有七秒，只是上天好像很宠爱鱼儿这个小种族，作为一条鱼，对于不开心的事记忆只有七秒。大部分鱼都是这样的，所以小鱼干每天过得开开心心，傻呵呵的四处找好吃的草儿。 傻喵每天晒着日光浴，吃着铲屎官供上来的猫粮，好不惬意。这一天，阳关正好，铲屎官出门打理朕的天下了，于是傻喵躺在房顶上，看着蓝天白云，开始思考作为一只猫的猫生。这时一只麻雀从傻喵上方飞过，落下一片羽毛，打断了傻喵的冥想，傻喵瞅了一眼麻雀：“喵呜~你这刁民想害朕？”傻喵觉得自己的领土遭遇了侵略，于是撒开猫爪，直追麻雀而去，奈何傻喵忘了自己没有翅膀，从屋顶飞下去的那一瞬间，傻喵觉得自己的喵生真是日了狗，竟然在自己的领地发生这样的事，‘噗’的一声，水花四溅，傻喵落进了附近的小河里，砸晕了正在参加婚礼的小鱼干，把一众参加婚礼的鱼儿吓得四处乱窜。傻喵愣了半天才回神，发现自己爪子下面有一只晕了的小鱼。才想起来是被自己砸晕的。想了半天，傻喵决定把小鱼干带回自己的王宫，让铲屎官看看还有没有救。 傻喵叼着小鱼干回到了家，发现铲屎官还没回来，又不方便带着小鱼干翻墙，于是将小鱼干扔在门口晒太阳，自己在旁边闭目养神。大概过了一分钟，小鱼干觉得自己要见上帝鱼了，这时铲屎官回来了，发现自家大人旁边有只晒得要干了的小鲤鱼，诧异极了，你想吃鱼了？铲屎官瞅了一眼傻喵，傻喵指了指旁边的小河，哦~铲屎官说你想养个小宠物啊？傻喵瞄了一眼小鱼干，觉得自己王宫养个小宠物也是可以的。于是看了看铲屎官，示意他把小鱼干安顿好。 小鱼干醒来之后发现自己躺在一个巨大的泡泡里面，开始思考发生了什么？ 获取授权]]></content>
      <categories>
        <category>小说</category>
      </categories>
      <tags>
        <tag>连载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue做一个本地记事本（一）]]></title>
    <url>%2F2017%2F09%2F26%2F%E4%BD%BF%E7%94%A8vue%E5%81%9A%E4%B8%80%E4%B8%AA%E6%9C%AC%E5%9C%B0%E8%AE%B0%E4%BA%8B%E6%9C%AC1%2F</url>
    <content type="text"><![CDATA[这个参考的是一个记事本的demo，为了面试学的vue，看了两天，觉得想要更快的上手最好还是做一个demo。这是我刚开始学的时候做的一些小demo，跟着文档来的。这里就不写关于如何安装vue了，文档上写的很清楚，而且我自己安装过程也没遇到什么大问题，如果有问题，可以看看他写的windows下搭建vue开发环境（他这里面npm老是写错，注意点）。把那几个命令记住就可以了（我老是记不住，我写在这里防止我自己又忘了）12345678# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev 安装依赖的时候，使用npm可能会比较慢，推荐使用cnpm。123npm install -g cnpm --registry=[https://registry.npm.taobao.org](https://registry.npm.taobao.org/)# vue-cli的安装cnpm install -g vue-cli 担心自己忘了，就截图放这了，唉，人老了，记性好差的。 还有要安装vuex：npm insatll --save vuex 这里说下啊，如果不想用eslint来规范代码的话，可以选择no，不然后面没配置好容易报一些格式上的错误。vue给我最大的特点就是数据绑定和组件化，使用起来确实很方便，而且功能强大。建议先把文档上给的小demo都跟着敲一遍，然后看看文档，入门还是可以的。我是为了更快的入门，所以打算着手做一个大点的demo，不然面试会被刷啊。poor me。这里推荐一篇写的不错的，可以参考参考。Vue 学习笔记,因为这个demo基于vue2.0+vuex+localStorage+sass+webpack，所以需要了解webpack的一些知识，这里面总结的挺好的。我也在看，后面看完了我再写笔记吧。废话不多说了，我要开始撸代码了。先了解一下vuex。这篇Vuex 入门介绍挺好的。相关参考：Vuex 通俗版教程快速上手vuexVue 2.0 起步(3) 数据流vuex和LocalStorage实例 - 微信公众号RSSvuex入门实例2vue全家桶之vuex 为什么要用vuex？vuex是类似redux的状态管理器，用来管理Vue的所有组件状态，一般来说vuex适合中型或者大型的单页应用（SPA），会出现多个视图组件依赖同一个状态，来自不同视图的行为需要变更同一个状态。但是这个记事本中有个修改主题，切换状态的地方，所以使用vuex更加方便。利用vuex进行状态管理，把所有事件和状态存储在store对象中，在组件中通过计算属性获得事件，因此就有了实时性。使用vuex管理主题状态，并进行模块化管理，用localStorage永久存储选中的主题颜色。（待）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零碎之viewport]]></title>
    <url>%2F2017%2F09%2F25%2F%E9%9B%B6%E7%A2%8E%E4%B9%8Bviewport%2F</url>
    <content type="text"><![CDATA[viewport 在移动设备上进行网页的重构或开发，首先得搞明白的就是移动设备上的viewport了，只有明白了viewport的概念以及弄清楚了跟viewport有关的meta标签的使用，才能更好地让我们的网页适配或响应各种不同分辨率的移动设备。 一、viewport的概念 移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，再具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但是viewport的大小不局限于可视区域，默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 二、css中的1px并不等于设备的1px 在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，这可能会造成我们的一个错觉，那就是css中的像素就是设备的物理像素。但实际情况却并非如此，css中的像素只是一个抽象的单位，在不同的设备或不同的环境中，css中的1px所代表的设备物理像素是不同的。 在为桌面浏览器设计的网页中，我们无需对这个津津计较，但在移动设备上，必须弄明白这点。 在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。 还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。关于这点，在文章后面的部分还会讲到。 在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。css中的px就可以看做是设备的独立像素，所以通过devicePixelRatio，我们可以知道该设备上一个css像素代表多少个物理像素。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。但是要注意的是，devicePixelRatio在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西，具体的情况可以看下这篇文章。 三、PPK的关于三个viewport的理论 ppk大神对于移动设备上的viewport有着非常多的研究（第一篇，第二篇，第三篇），有兴趣的可以去看一下，本文中有很多数据和观点也是出自那里。ppk认为，移动设备上有三个viewport。 首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为viewport的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的viewport太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？ 前面我们已经说了，css中的1px并不是代表屏幕上的1px，你分辨率越大，css中1px代表的物理像素就会越多，devicePixelRatio的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让css中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视devicePixelRatio的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱，所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 layout viewport。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 然而，layout viewport 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 visual viewport。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 现在我们已经有两个viewport了：layout viewport 和 visual viewport。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的viewport。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。ppk把这个viewport叫做 ideal viewport，也就是第三个viewport——移动设备的理想viewport。 ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 再总结一下：ppk把移动设备上的viewport分为layout viewport 、 visual viewport 和 ideal viewport 三类，其中的ideal viewport是最适合移动设备的viewport，ideal viewport的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为ideal viewport的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。ideal viewport 的意义在于，无论在何种分辨率的屏幕下，那些针对ideal viewport 而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题整理]]></title>
    <url>%2F2017%2F07%2F13%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[Javascript数据类型答：null，number，boolean，string，undefinedJavaScript 数据类型 ECMAscript和Javascript的关系答：ECMAscript是Javascript的规格，Javascript是ECMAscript的一种实现（另外的ECMAScript方言还有Jscript和ActionScript）。在日常场合，这两个词是可以互换的。es是js的各个版本。javascript与ECMAScript、DOM、BOM的关系 闭包主要解决什么问题？答：凡是在闭包域内声明的变量或方法,外部无法直接访问,闭包域可以访问外部的变量或方法.隔离了作用域。用9种办法解决 JS 闭包经典面试题之 for 循环取 i 匹配一段由数字和大写字母组成的字符串的正则表达式答：/[A-Z0-9]/参考学习：系统地学习正则表达式(一)：基础篇 web storage 和cookie的区别答：① cookie是客户端用来存储数据的,它既可以在客户端设置也可以在服务器端设置。cookie会跟随任意HTTP请求一起发送.② html5标准中的Web Storage包括了两种存储方式:sessionStorage和localStorage。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sessionStorage用于本地存储一个会话中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage仅仅是会话级别的存储。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。WebStorage 和 Cookie的区别 JavaScript AMD规范主要解决什么问题？答：主要解决web端模块问题。JavaScript的AMD规范 样式自动居中有哪几种？答： 12&#123;display:block,margin:0 auto&#125; &#123;display:block,position,absolute,left:50%,right:50%,transform:translate(-50%,-50%)&#125; 对数组[1，2，1，6，7，-2，4，0，6]按从大到小排序。答: 冒泡排序—–从小到大排序,存在10个不同大小的气泡，由底至上地把较少的气泡逐步地向上升，这样经过遍历一次后，最小的气泡就会被上升到顶（下标为0），然后再从底至上地这样升，循环直至十个气泡大小有序。在冒泡排序中，最重要的思想是两两比较，将两者较少的升上去.冒泡排序最坏情况的时间复杂度是O(n²)经典排序算法 - 冒泡排序Bubble sort 使用Jquery遍历class等于lock的标签，并将标签内容收集到一个数组中。答： 12345var a=[]$(&apos;.lock&apos;).each(function()&#123; var h=$(this).html(); a.push(h);&#125;) 用SQL语句创建一张USER表答：create table &quot;tablename&quot; (username string,password int) Nodejs操作文件需要加载哪个模块答：fs h5的桌面应用开发，以及相应的解决方案答：nw.js轻量级桌面应用开发的捷径——nw.js 对于web前端适配多端的模式有什么解决方案答：@meida多屏适配移动端Web页面适配方案 行内元素，块级元素，盒模型答：说说行内元素与块级元素以及之间的转换？html块级元素与行内元素前端面试之CSS总结(上)你真的了解盒模型吗？CSS 布局经典问题初步整理 怎样对网站文件和资源进行优化答：1.尽可能减少http请求次数，将css, js, 图片各自合并2.使用CDN，降低通信距离3.添加Expire/Cache-Control头4.启用Gzip压缩文件5.将css放在页面最上面6.将script放在页面最下面7.避免在css中使用表达式8.将css, js都放在外部文件中9.减少DNS查询10.最小化css, js，减小文件体积11.避免重定向12.移除重复脚本13.配置实体标签ETag14.使用AJAX缓存，让网站内容分批加载，局部更新如何对网站进行优化提速？ 两栏布局答：使用负边距 元素content添加父元素，设置左浮动，宽度为100%； content 设置右边距，宽度为aside的宽度（留出aside浮上来的空间）； aside左浮动，并设置负边距，等于自身宽度。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style type=&quot;text/css&quot;&gt; html,body&#123; padding: 0; margin: 0; &#125; #header, #footer&#123; height: 100px; background: red; overflow: hidden; &#125; #main&#123; overflow: auto; &#125; #main .center&#123; height: 200px; width: 100%; float: left; &#125; .center .content&#123; height: 200px; background: green; margin-right: 100px; &#125; #main .aside&#123; height: 200px; width: 100px; background: blue; float: left; margin-left: -100px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;header&lt;/div&gt; &lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;content&quot;&gt; 我是主区块 我是主区块 main main main &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 两栏布局是主内容区为主，左（右）侧有一栏，(将侧边区块域浮动，浮动后覆盖绿色, 再将 overflow:auto，形成BFC，形成独立区域，达到效果。)代码如下：123456789101112131415161718192021222324252627&lt;style&gt; #header, #footer&#123; height: 100px; background: red; &#125; #content .main&#123; height: 200px; background: green; overflow: auto; &#125; #content .aside&#123; height: 200px; width: 100px; background: blue; float: left; &#125; &lt;/style&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt;&lt;/div&gt; &lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt; &lt;div class=&quot;main&quot;&gt; main main main main main main &lt;/div&gt; &lt;/div&gt; &lt;div id=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; 写一段sass的@include的@extend的mixin答：Sass：@mixin和@extend该如何选择 如何实现0.5px答：webapp中的CSS3实现 0.5px的细线纯CSS实现border的0.5px设置 箭头函数答：箭头函数 数组去重答：js数组去重的三种常用方法总结 vue相关 v-model的内容改变是在生命周期的哪个阶段？答：vue生命周期]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我也想随梦逐流]]></title>
    <url>%2F2017%2F04%2F04%2F%E6%88%91%E4%B9%9F%E6%83%B3%E9%9A%8F%E6%A2%A6%E9%80%90%E6%B5%81%2F</url>
    <content type="text"><![CDATA[假期总是一如既往的过得很快，上大学之后，放假最后一天不再是以前赶作业的匆忙日子，所以时间流逝的更快了。实习的日子里开始为了未来奋斗着，摸索着前进的道路。以前看的小说里面有句话很喜欢——“我心有猛虎细嗅蔷薇”。我想每个还没毕业或者已经毕业的朋友们，都有着自己的梦。尤其对于我们程序员来说，很多伙伴都有一颗创业的心。农民翻身把歌唱。每天搬砖搬多了也想去规划一栋大楼。时代变了，电脑手机不再是有钱人的奢侈物了。如今的社会几乎是人手一部手机，家中常备电脑。大一大二时我还没有自己的电脑，对于一个计算机专业的学生来说，有点尴尬。直到大二暑假在一个暑期班当了一个月的老师，终于买了我心爱的小黑。从此不离不弃。 从那时起开始我的码媛生活。之前也写过为什么要做程序员,感兴趣的可以点击这里看看。一直以为自己以后的工作会是一个Android工程师，然后做几年转产品。等挣了足够的钱，就背起我的背包，去实现从小到大的理想。（周游世界）闯荡江湖。自小就想成为一个走遍世界的人，留下自己的脚印。每个人来到这个世上，都怀揣着各自的使命和理想，能不能实现就是最难的关卡，上帝是一个很棒的架构师，设计了各种各样的程序关卡让我们去过关，体验人生。但是我们总是在虚幻中憧憬理想，在现实中和小怪打斗却一直杀不了boss，过不了关卡，最后梦想在现实中越来越远。社会是一个巨大的磨盘，撒上岁月的粉，加点生活的苦水。拉着磨着，就这样一点一滴磨平曾经激情澎湃的梦，碾碎大家觉得不能实现的想法，那些龇牙咧嘴的“棱角”不再是你的标识了。慢慢的我们习惯了三点一线的生活。很多人安于平淡，岁月静好。也有人曾经想上天入地，最后在上帝的某一个关卡中趋于平静。一直觉得人之所以区别于人的最大辨别在于，每个人都有自己的特点，都有自己的个性。吸引着我去交往。还记得小学，一个人坐上去上海的大巴，可以和邻座的小女孩聊得天马行空，留下彼此的联系。现在坐车的时候大人把小孩保护的严严实实，不要和陌生人说话。然后每个人手上拿着的不是手机就是ipad。安静的可以听到最后座大叔的呼噜声。 刚开始来到魔都，住的地方距离上班的地方来回四个小时的地铁。每天早早起来，乘坐着小怪兽游荡在这个城市的地下。对于一个之前没做过地铁的我来说，每次听到地铁发出刺耳的轰鸣声，神经都是紧绷的，不知道下一秒会发生什么。环顾四周，似乎只有我还没融入到这坐城市，每个人的神情都是淡然的，疲倦的，专注的看着手机。没有人会和我一样诧异着小怪兽发出的嘶吼声。空气中游荡着一个叫做浮躁的恶灵，开始吞噬社会。在这个城市也快半年了，一直喜欢把地铁形容成小怪兽，游荡在这个城市的身躯中。拥挤的时候，小怪兽胖的像个皮球，而我们就像沙丁鱼，原地随波逐流。现在换了个住处，可以骑着自行车去上班，清晨连汽车的尾气都变得芬芳起来，可能拌着自由的味道。 自由这个东西感觉有时候追逐一生也并不能触其衣角。 以前觉得时间很多，等有钱了就可以去做自己想做的事情，现在上班了才知道，时间很少，属于自己的时间很少。想做的事情等以后有钱也不一定有时间去做，后面有了家庭，时间就更少了，挤一挤出来的有可能只是泡沫。程序员这个工作并不会优于女生，产品要上线了，无论男女都要加班加点完成。很多小伙伴笑话说自从做了程序员头发都比以前少了，对啊，没办法，拿着怎样的工资就要付出怎样的代价。以前在学校的时候，会抽空去周边旅游，会拿着书躺在床上和古人神交，会拿出笔描绘人生。现在回家能按时做完运动已经是感谢自己还爱着自己，别说去旅游了。每次看到新闻上说谁周游世界几国，总是心潮澎湃，那也是我的梦啊。 我也想随梦逐流啊，不是原地踏步。促使我开始规划自己的梦不仅仅是新闻，更多的是我的工作。青春的尾巴在摇摆，在溜走，每天对着电脑发现视力已经下降的五米开外雌雄难辨，十米开外人畜不分，行走的瞎子一个。有时候很想就这样背上我的包，来一场说走就走的旅行，带上我的眼with your eye。 作为一个程序媛，想要靠自己去完成一个又一个的行走，其实是很难得。一个bug就会阻拦前方的路。但是不管怎样，如果连试都不试一下，又怎么去走出上帝设下的另一条路呢。 朋友说我这个人有个优点还不错，就是有想法就会去做，属于行动派。 今年的目标是实现我的毕业旅行。规划的路线包括九寨沟，重庆，深圳，西藏，北京，厦门。想要实现，需要的自然是旅费，老爸老妈会在精神上支持我。然后没然后了，所以我需要靠自己来挣旅费。 于是乎我就设计了一个小project，希望能让我打败boss。这个是我目前的一款初期设计，后期可能做成app或者小程序（因为比较适合我这样的新手做）。附上初期图稿。如果有吐槽的请一定不要憋着。因为可能会给我很大的帮助。如果有什么建议，我在这里给您跪谢啦~ 作为一个四年级看小说到现在的我来说，很喜欢写点东西，也很喜欢听故事。如果你有故事，我有酒，来点小菜，就着时光。也希望我写的小故事你们能喜欢。目前虽然在设计阶段，但是如果你有故事，我很乐意听，并且写下来（当然你愿意的话）。毕竟等以后老了可以回过来看看自己的一生。我这个人记性不好，很多事情过了就忘了。希望十月之前能逐梦而行。灰常感谢你的支持。 感兴趣的可以点开这个看看。使用墨刀设计的一个小东西（最近忙着毕设，做的比较简陋，见谅）。不过设置了一个密码，想看的可以加我或者简信给我。很高兴你来吐槽哟~请小主尽情打击吧。你有故事我有酒【用浏览器或者微信qq打开】]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2F2017%2F01%2F07%2F%E6%97%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记得以前读唐诗的时候，经常会遇到名字叫做无题的诗词，是不是诗人和我一样，想不出起什么名字，但是又想写点什么，就命名为无题。 昨天北京的朋友说他们那里大雨滂沱，傍晚下班的时候放晴的天空给大家一个视野盛宴，被晚霞渲染的天空美的像一幅画，无论是哪一帧都可以拍下来做屏保。朋友圈着实上演了一系列的晚霞瀑布。今天上午，上海的气温渐渐低沉，大约九十点的时候淅淅沥沥的小雨开始飘起来，典型的江南细雨，空气中也开始释放缠绵的气息，一直都觉得这样的天气非常适合睡觉，自然的催眠师。所以我就去睡了一觉，真的是躺下就睡着了，连梦都没做。失策的是最后被饿醒了，应该吃饱了再睡的，雨天另一个失策的是忘记囤粮，用豆豆的话来说就是我们弹尽粮绝了。还好之前买的吐司还有，从床上爬起来到厨房煎了个荷包蛋，配上生菜的火腿肠，撒点沙拉，一顿午饭就搞定了。每次看到全家里面的三明治，都觉得真特么坑，真特么赚钱，劳资也要去卖三明治，当然也只是想想，毕竟没人买。 吃饱了之后躺在床上发现睡饱了，睡意也没了，吃了一大口西瓜，感觉人生满满的幸福感，嘴里回味着三明治和西瓜，开始想着要是有一套自己的房子就好了，这样每天最开心的事肯定就是研究好吃的好玩的，种漂亮的花草，躺在摇椅上读着菜根谭，和作者们开始神交，闲暇之余逗逗猫狗，和我家的狗狗猫咪过着幸福的生活。等天气好的时候牵着狗狗出去溜达，等心情好（心情不好也去）的时候出去旅游，拉着我的小小旅行箱，里面装上美美的裙子和比基尼，去一个美丽的地方拍美美的照片，吃好吃的，看看这个我生活的星球。 我喜欢没事就开始思考人生，有的人说活在当下就好，想那么多干嘛，多累啊，但是人之所以作为人不就因为每个人都有自己的思想，才显得独一无二。之前敲代码的时候，每次遇到bug都会怀疑一会儿人生，解决bug之后再思考会儿人生，感概下劳资真特么机智，自我鉴定之后奔向下一个bug。 刚刚躺在床上，准备翻起床头的书看会儿书，但是不知道从什么时候开始，书架的书由原来的山居笔记，菜根谭，百年孤独，孤独六讲，老子……开始被Javascript权威指南，java编程思想，app研发录，疯狂Android讲义，openGL这些代替，而自己也再没了看散文的心思了，哪怕是工作之余，也只会抱着手机刷微博，水群，聊天，看漫画。 kindle里面下了一部《梦的解析》，这本书在我高中的时候就很想看，记得高中那会儿能捧着厚厚的飘一直一直看，能静下心来摘抄着仓央嘉措的诗词并为之感动着，但是这本《梦的解析》看到现在也就看了百分之十几。看了一点就想玩手机，日子越过越燥，出门散步看到的是一个快餐时代，每个人步伐匆匆，手捧着手机，面色疲倦。有时候感觉自己变成了手机怪，记得大三的时候，为了好好听专业课，每天上课的时候都把手机丢在寝室，不依赖手机的时候感觉不到什么，但是现在手机不见了几分钟就开始方张。不得不说有很大部分原因是现在进入了一直手机时代，买东西，吃饭，坐车可以直接用手机支付，大家已经离不开手机了。但是为什么我在家的时候还是想捧着手机，就像一个上瘾的烟民一样躺在床上盯着屏幕拉都拉不下来，看书的时候三心二意，玩手机的时候一心一意。是我浮躁了还是这个社会太浮躁了？ 每次刷微博，刷新闻，刷朋友圈满屏的标题党，一时间花了眼，放下手机的时候，卧槽，我特么花了一个小时都干了啥？应该滚去睡觉的，却在这里刷着莫名其妙的东西。尤其是现在的新闻已经很多分不清真假了，有时候真的很想自己去设计一款app，里面呈现最真实的，订制自己最想看到的，但是其实也只是想想，因为有时候不得不承认这样的标题党在很多时候还是比较吸引眼球的，况且姐姐这渣渣的技术也不能写出这么精确的筛选算法（嘘！这不是重点）。 窗外的雨声越来越大，竟让我有种春上的感觉，这个时候的你，在想些什么呢？获取授权]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序媛的小乐趣]]></title>
    <url>%2F2016%2F11%2F29%2F%E7%A8%8B%E5%BA%8F%E5%AA%9B%E7%9A%84%E5%B0%8F%E4%B9%90%E8%B6%A3%2F</url>
    <content type="text"><![CDATA[在还没做程序媛之前，我是一个爱玩爱浪的～成为程序媛之后，嗯，依旧放荡不羁。哈哈哈哈。翻看以前的照片，原来自己也是蛮“多才多艺”的嘛，哈哈哈。 记得那时最爱涂鸦了，初中政治书里面全是配图加旁白，哈哈哈。后来上了大学逼格上升，不画书上了。买了个漂亮的本子。 这个男生是我之前喜欢的一个人的头像，我给他画了下来，不过遗憾的是没能在一起。 这是上课随手画的一个蓝胖子，当我画完发了说说之后，哈哈哈，就有个人过来砸场子了，说我画的太丑了，他随笔画的都比我好，汗颜啊，不过忘记存照片了，确实画的比我好多了。 这是情人节那天送给自己的，哈哈哈。谁说单身贵族木有花，我可以自己画呀 大一刚进学校，加入了两个社团，其中就有个书画协会，一直以来对书画很感兴趣，不过写的不咋滴，这是我练了半个月的成果，唉╯﹏╰。以后要多练练，争取达到我们部长的水平。 虽然不咋滴，不过拿了个鼓励奖，哈哈哈 给你们看下我们部长写的春联。棒棒哒 大二下学期接触了LOL,还是不错的，不过每次打一局时间好长，目前玩的一共加起来不到二十次，我果然太懒了，这是我杀的最多的一次了。 感觉自己棒棒哒 下面放一些我的涂鸦，尽情吐槽吧 这个小姑娘还是很温柔哒 蛮喜欢这件外套 这是以前喜欢的一个封面小镇 哈哈哈，练笔 第一次正式写字，乱七八糟 其实我是按照杨洋侧脸来画的，不过没有百分之一 大家觉得像谁呢 萌萌哒 这是小漫画，很可爱有木有 这是手工做的，猜猜用什么做的 这也是我DIY，适合平安夜哟(ღ˘⌣˘ღ) 那时候喜欢言情小说女主，就画下来了 喜欢无脸男。 Zoe 这句话我很喜欢。 我也是个小文艺哟 喜欢枫叶 最喜欢自己做吃的 酸奶苹果沙拉 当然，作为一个正经吃货，自己会烧，很有必要 生菜 有木有和我一样喜欢吃卷心菜的小伙伴啊 卷心菜 好久没烧荤菜了，然后华丽丽歇菜，不过吃起来还是不错的，下次传个卖相好看点的 这个味道不错 茭白肉丝 这道菜我经常吃，蛮喜欢 最擅长下面，因为我喜欢面食～嘎嘎嘎 没事爱臭美，这个姨妈色不错(*๓´╰╯`๓) 这个围脖快织好了才发现线不够，忧桑。本来之前就要送人的，拖到现在 此生放荡不羁爱浪。 s 程序媛的桌面啥样？哈哈，就酱。 当然，我是一个正经吃货 听说爱笑的女生运气不会太差 本文已在版权印备案，如需转载请访问版权印。获取授权]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础知识]]></title>
    <url>%2F2016%2F11%2F29%2Fjava%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1.HashMap和HashTable的区别 HashMap去掉了contains方法 HashTable是同步的(线程安全) HashMap允许空键值 HashMap执行快速失败机制 Fast-fail机制:在使用迭代器的过程中有其它线程修改了集合对象结构或元素数量,都将抛出ConcurrentModifiedException 2.java的线程安全类Vector、Stack、HashTable、ConcurrentHashMap、Properties 3.java集合框架123456789Collection - List - ArrayListCollection - List - LinkedListCollection - List - VectorCollection - List - Vector - StackCollection - Set - HashSetCollection - Set - TreeSetMap - HashMapMap - TreeMapMap - HashTable 3.1 ArrayList的构造函数有三个 无参构造 容量为10 ArrayList(Collections&lt;?extends E&gt; c)构造包含指定collection的元素的列表 ArrayList(int initialCapacity) 指定初始容量 3.2 Iterator支持从源集合安全地删除对象,防止并发修改异常(ConcurrentModifiedException) 4.Java垃圾回收机制4.1 调用system.gc() Runtime.getRuntime.gc() 4.2 垃圾回收:释放那些不在持有任何引用的对象的内存 4.3 怎样判断是否需要收集： 引用计数法：对象没有任何引用与之关联(无法解决循环引用) 对象引用遍历法：对象引用遍历从一组对象开始,沿着对象图的每条链接,递归确定可以到达的对象,如果某对象不能从这些根对象的一个(至少一个)到达,则将它作为垃圾收集。 4.4 垃圾回收方法 标记清除法(Mark-Sweeping):易产生内存碎片 复制回收法(Copying)：为了解决Mark-Sweep法而提出,内存空间减至一半 标记压缩法(Mark-Compact):为了解决Copying法的缺陷,标记后移动到一端再清楚 分代回收法(GenerationalCollection):新生代对象存活周期短,需要大量回收对象,需要复制的少,执行copying算法;老年代对象存活周期相对长,回收少量对象,执行mark-compact算法.新生代划分：较大的eden区 和 2个survivor区 4.5 内存分配 新生代 |Eden Space|From Space|To Space| 对象主要分配在新生代的EdenSpace和FromSpace 如果EdenSapce和FromSpace空间不足,则发起一次GC 若进行GC后,EdenSpace和FromSpace能够容纳该对象,就放在Eden和FromSpace。在GC过程中会将EdenSpace和FromSpace存活的对象移动到ToSpace,然后清理Eden和From。若在清理过程中,ToSpace无法足够容纳该对象,则将该对象移入老年代中。在进行GC后,Eden和From为空,MinorGC完成。From和To标记互换。To区(逻辑上)始终为空。 新生代的回收成为MinorGC,对老年代的回收成为MajorGC又名FullGC 其他 优先在Eden上分配 大对象直接进入老年代 长期存活的对象进入老年代 动态对象年龄判定 suvivor区同年龄对象总和大于suvivor区空间的一半,MinorGC时复制至老年代 空间分配担保 新生代放不下借用老年代,虚拟机检测GC租借的老年代内存是否大于剩余的老年代内存。若大于,MinorGC变为一次FullGC。若小于,查看虚拟机是否允许担保失败,若允许则执行一次MinorGC,否则也要变为一次FullGC 5.一些重要的关键字 volatileJava 语言提供了一种稍弱的同步机制,即volatile变量.用来确保将变量的更新操作通知到其他线程,保证了新值能立即同步到主内存,以及每次使用前立即从主内存刷新。 当把变量声明为volatile类型后,编译器与运行时都会注意到这个变量是共享的。volatile修饰变量,每次被线程访问时强迫其从主内存重读该值,修改后再写回共享内存。保证读取的可见性,对其他线程立即可见。由于不保证原子性,也就不能保证线程安全。由于及时更新，很可能导致另一线程访问最新变量值，无法跳出循环的情况。同时,volatile屏蔽了VM中必要的代码优化,效率上较低。另一个优点：禁止指令重排序 finalfinal修饰的变量是常量，必须进行初始化，可以显示初始化，也可以通过构造进行初始化，如果不初始化编译会报错。 6.多线程 &amp; 并发 &amp; 同步 &amp; 锁6.1 线程的run方法和start方法 start方法用start方法来启动线程,是真正实现了多线程。调用thread类的start方法来启动一个线程,此时线程处于就绪状态,一旦得到cpu时间片,就开始执行run方法。注：此时无需等待run方法执行完毕,即可执行下面的代码,所以run方法并没有实现多线程。 run方法只是thread类的一个普通方法,若直接调用程序中依然只有主线程这一个线程,还要顺序执行,依然要等待run方法体执行完毕才可执行下面的代码。 6.2 ReadWriteLock(读写锁) 写写互斥 读写互斥 读读并发在读多写少的情况下可以提高效率 6.3 resume(继续挂起的线程)和suspend(挂起线程)一起用 6.4 wait与notify、notifyall一起用 6.5 sleep与wait的异同点 sleep是Thread类的静态方法,wait来自object类 sleep不释放锁,wait释放锁 wait,notify,notifyall必须在同步代码块中使用,sleep可以在任何地方使用 都可以抛出InterruptedException 6.6 让一个线程停止执行 异常 - 停止执行休眠 - 停止执行阻塞 - 停止执行 6.7 ThreadLocal相关 ThreadLocal解决了变量并发访问的冲突问题 当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类) 与synchronized同步机制的比较 首先,它们都是为了解决多线程中相同变量访问冲突问题。不过,在同步机制中,要通过对象的锁机制保证同一时间只有一个线程访问该变量。该变量是线程共享的,使用同步机制要求程序缜密地分析什么时候对该变量读写,什么时候需要锁定某个对象,什么时候释放对象锁等复杂的问题,程序设计编写难度较大,是一种“以时间换空间”的方式。而ThreadLocal采用了以“以空间换时间”的方式。 7.接口与抽象类 一个子类只能继承一个抽象类,但能实现多个接口 抽象类可以有构造方法,接口没有构造方法 抽象类可以有普通成员变量,接口没有普通成员变量 抽象类和接口都可有静态成员变量,抽象类中静态成员变量访问类型任意，接口只能public static final(默认) 抽象类可以没有抽象方法,抽象类可以有普通方法,接口中都是抽象方法 抽象类可以有静态方法，接口不能有静态方法 抽象类中的方法可以是public、protected和默认;接口方法只有public 8.Statement接口8.1 Statement是最基本的用法，不传参，采用字符串拼接，存在注入漏洞 PreparedStatement传入参数化的sql语句,同时检查合法性，效率高，可以重用,防止sql注入 CallableStatement接口扩展PreparedStatement，用来调用存储过程 public interface CallableStatement extends PreparedStatement public interface PreparedStatement extends Statement BatchedStatement用于批量操作数据库，BatchedStatement不是标准的Statement类 8.2 Statement与PrepareStatement的区别 创建时的区别 12Statement statement = conn.createStatement();PreparedStatement preStatement = conn.prepareStatement(sql); 执行的时候 12ResultSet rSet = statement.executeQuery(sql);ResultSet pSet = preStatement.executeQuery(); 由上可以看出，PreparedStatement有预编译的过程，已经绑定sql，之后无论执行多少遍，都不会再去进行编译，而 statement 不同，如果执行多遍，则相应的就要编译多少遍sql，所以从这点看，preStatement 的效率会比 Statement要高一些 安全性 preStatement是预编译的，所以可以有效的防止SQL注入等问题 代码的可读性和可维护性 PreparedStatement更胜一筹 9.抽象类和最终类抽象类可以没有抽象方法,最终类可以,没有最终方法 最终类不能被继承,最终方法不能被重写(可以重载) 10.异常10.1 throw、throws、try…catch、finally throws用在方法上,方法内部通过throw抛出异常 try用于检测包住的语句块,若有异常,抛出并执行catch子句 catch捕获try块中抛出的异常并处理 10.2 关于finally finally不管有没有异常都要处理 finally{}比return先执行,多个return执行一个后就不在执行 不管有木有异常抛出,finally在return返回前执行 10.3 受检查异常和运行时异常 粉红色的是受检查的异常(checked exceptions),其必须被try…catch语句块所捕获,或者在方法签名里通过throws子句声明。受检查的异常必须在编译时被捕捉处理,命名为Checked Exception是因为Java编译器要进行检查,Java虚拟机也要进行检查,以确保这个规则得到遵守。 绿色的异常是运行时异常(runtime exceptions),需要程序员自己分析代码决定是否捕获和处理,比如空指针,被0除… 而声明为Error的，则属于严重错误，如系统崩溃、虚拟机错误、动态链接失败等，这些错误无法恢复或者不可能捕捉，将导致应用程序中断，Error不需要捕捉。 11.this &amp; super11.1 super出现在父类的子类中。有三种存在方式 super.xxx(xxx为变量名或对象名)意思是获取父类中xxx的变量或引用 super.xxx(); (xxx为方法名)意思是直接访问并调用父类中的方法 super() 调用父类构造 super只能指代其直接父类 11.2 this() &amp; super()在构造方法中的区别 调用super()必须写在子类构造方法的第一行,否则编译不通过 super从子类调用父类构造,this在同一类中调用其他构造 均需要放在第一行 尽管可以用this调用一个构造器,却不能调用2个 this和super不能出现在同一个构造器中,否则编译不通过 this()、super()都指的对象,不可以在static环境中使用 本质this指向本对象的指针。super是一个关键字 12.修饰符一览12345修饰符 类内部 同一个包 子类 任何地方private yesdefault yes yesprotected yes yes yespublic yes yes yes yes 13.构造内部类对象1234567891011public class Enclosingone &#123; public class Insideone &#123;&#125; public static class Insideone&#123;&#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Enclosingone.Insideone obj1 = new Enclosingone().new Insideone(); Enclosingone.Insideone obj2 = new Enclosingone.Insideone(); &#125;&#125; 14.序列化声明为static和transient类型的数据不能被序列化,序列化的笔记参见[Java-note-序列化.md][5] 15.Java的方法区与堆一样,是线程共享的区域。方法区中存储：被虚拟机加载的类信息，常量，静态变量，编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。 16.正则表达式次数符号12345* 0或多次+ 1或多次？0或1次&#123;n&#125; 恰n次&#123;n,m&#125; 从n到m次 其他符号 符号 等价形式1234567\d [0-9]\D [^0-9] \w [a-zA-Z_0-9]\W [^a-zA-Z_0-9]\s [\t\n\r\f]\S [^\t\n\r\f]. 任何字符 边界匹配器 行开头 ^行结尾 $单词边界 \b 贪婪模式:最大长度匹配 非贪婪模式:匹配到结果就好,最短匹配 环视 1234567891011121314字符 描述 匹配对象. 单个任意字符 [...] 字符组 列出的任意字符[^...] 未列出的任意字符^ caret 行的起始位置$ dollar 行的结束位置\&lt; 单词的起始位置\&gt; 单词的结束位置\b 单词边界\B 非单词边界(?=Expression) 顺序肯定环视 成功,如果右边能够匹配(?!Expression) 顺序否定环视 成功,如果右边不能够匹配(?&lt;=Expression) 逆序肯定环视 成功,如果左边能够匹配(?&lt;!Expression) 逆序否定环视 成功,如果左边不能够匹配 举例:北京市(海定区)(朝阳区)(西城区) Regex: .*(?=\() 模式和匹配器的典型调用次序 把正则表达式编译到模式中Pattern p = Pattern.compile(“a*b”); 创建给定输入与此模式的匹配器Matcher m = p.matcher(“aaab”); 尝试将整个区域与此模式匹配boolean b = m.matches(); 17.Servlet &amp; JSP &amp; Tomcat17.1 Servlet继承实现结构1234Servlet (接口) --&gt; init|service|destroy方法GenericServlet(抽象类) --&gt; 与协议无关的ServletHttpServlet(抽象类) --&gt; 实现了http协议自定义Servlet --&gt; 重写doGet/doPost 17.2 编写Servlet的步骤 继承HttpServlet 重写doGet/doPost方法 在web.xml中注册servlet 17.3 Servlet生命周期 init:仅执行一次,负责装载servlet时初始化servlet对象 service:核心方法,一般get/post两种方式 destroy:停止并卸载servlet,释放资源 17.4 过程 客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若存在调用相应service方法 客户端request请求 -&gt; 服务器检查Servlet实例是否存在 -&gt; 若不存在装载Servlet类并创建实例 -&gt; 调用init初始化 -&gt; 调用service 加载和实例化、初始化、处理请求、服务结束 17.5 doPost方法要抛出的异常:ServletExcception、IOException 17.6 Servlet容器装载Servlet web.xml中配置load-on-startup启动时装载 客户首次向Servlet发送请求 Servlet类文件被更新后,重新装载Servlet 17.7 HttpServlet容器响应web客户请求流程 Web客户向servlet容器发出http请求 servlet容器解析Web客户的http请求 servlet容器创建一个HttpRequest对象,封装http请求信息 servlet容器创建一个HttpResponse对象 servlet容器调用HttpServlet的service方法,把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象 HttpServlet调用httprequest的有关方法,获取http请求信息 httpservlet调用httpresponse的有关方法,生成响应数据 Servlet容器把HttpServlet的响应结果传给web客户 17.8 HttpServletRequest完成的功能 request.getCookie() request.getHeader(String s) request.getContextPath() 17.9 HttpServletResponse完成的功能 设http头 设置Cookie 输出返回数据 17.10 session12HttpSession session = request.getSession(boolean create)返回当前请求的会话 17.11 JSP的前身就是Servlet 17.12 Tomcat容器的等级 Tomcat - Container - Engine - Host - Servlet - 多个Context(一个Context对应一个web工程)-Wrapper 17.13 Servlet与JSP九大内置对象的关系 JSP对象 怎样获得1234567891. out -&gt; response.getWriter2. request -&gt; Service方法中的req参数3. response -&gt; Service方法中的resp参数4. session -&gt; request.getSession5. application -&gt; getServletContext6. exception -&gt; Throwable7. page -&gt; this8. pageContext -&gt; PageContext9. Config -&gt; getServletConfig exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。 18.struts struts可进行文件上传 struts基于MVC模式 struts让流程结构更清晰 struts有许多action类,会增加类文件数目 19.Hibernate的7大鼓励措施 尽量使用many-to-one,避免使用单项one-to-many 灵活使用单项one-to-many 不用一对一,使用多对一代替一对一 配置对象缓存,不使用集合对象 一对多使用bag,多对一使用set 继承使用显示多态 消除大表,使用二级缓存 20.JVM20.1 JVM内存配置参数 -Xmx:最大堆大小 -Xms:初始堆大小(最小内存值) -Xmn:年轻代大小 -XXSurvivorRatio:3 意思是Eden:Survivor=3:2 -Xss栈容量 -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 20.2 JVM内存结构 堆:Eden、Survivor、old 线程共享 方法区(非堆):持久代,代码缓存,线程共享 JVM栈:中间结果,局部变量,线程隔离 本地栈:本地方法(非Java代码) 程序计数器 ：线程私有，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址 注：持久代Java8消失,取代的称为元空间(本地堆内存的一部分) 21.面向对象的五大基本原则(solid) S单一职责SRP:Single-Responsibility Principle一个类,最好只做一件事,只有一个引起它的变化。单一职责原则可以看做是低耦合,高内聚在面向对象原则的引申,将职责定义为引起变化的原因,以提高内聚性减少引起变化的原因。 O开放封闭原则OCP:Open-Closed Principle软件实体应该是可扩展的,而不是可修改的。对扩展开放,对修改封闭 L里氏替换原则LSP:Liskov-Substitution Principle子类必须能够替换其基类。这一思想表现为对继承机制的约束规范,只有子类能够替换其基类时,才能够保证系统在运行期内识别子类,这是保证继承复用的基础。 I接口隔离原则ISP:Interface-Segregation Principle使用多个小的接口,而不是一个大的总接口 D依赖倒置原则DIP:Dependency-Inversion Principle依赖于抽象。具体而言就是高层模块不依赖于底层模块,二者共同依赖于抽象。抽象不依赖于具体,具体依赖于抽象。 面向对象设计原则 封装变化 少用继承 多用组合 针对接口编程 不针对实现编程 为交互对象之间的松耦合设计而努力 类应该对扩展开发 对修改封闭（开闭OCP原则） 依赖抽象，不要依赖于具体类（依赖倒置DIP原则） 密友原则：只和朋友交谈（最少知识原则） 说明：将方法调用保持在界限内，只调用属于以下范围的方法： 该对象本身（本地方法）对象的组件 被当作方法参数传进来的对象 此方法创建或实例化的任何对象 别找我（调用我） 我会找你（调用你）（好莱坞原则） 一个类只有一个引起它变化的原因（单一职责SRP原则） 22.null可以被强制转型为任意类型的对象。23.代码执行次序 多个静态成员变量,静态代码块按顺序执行 单个类中: 静态代码 -&gt; main方法 -&gt; 构造块 -&gt; 构造方法 构造块在每一次创建对象时执行 涉及父类和子类的初始化过程 a.初始化父类中的静态成员变量和静态代码块 b.初始化子类中的静态成员变量和静态代码块 c.初始化父类的普通成员变量和构造代码块(按次序)，再执行父类的构造方法(注意父类构造方法中的子类方法覆盖) d.初始化子类的普通成员变量和构造代码块(按次序)，再执行子类的构造方法 24.红黑树二叉搜索树:(Binary Search Tree又名：二叉查找树,二叉排序树)它或者是一棵空树,或者是具有下列性质的二叉树： 若它的左子树不空,则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空,则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。 红黑树的定义:满足以下五个性质的二叉搜索树 每个结点或是红色的或是黑色的 根结点是黑色的 每个叶结点是黑色的 如果一个结点是红色的,则它的两个子结点是黑色的 对于每个结点,从该结点到其后代叶结点的简单路径上,均包含相同数目的黑色结点 黑高 从某个结点x出发(不含x)到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。红黑树的黑高为其根结点的黑高。 其他 一个具有n个内部结点的红黑树的高度h&lt;=2lg(n+1) 结点的属性(五元组):color key left right p 动态集合操作最坏时间复杂度为O(lgn) 25.排序 稳定排序:插入排序、冒泡排序、归并排序、基数排序 插入排序[稳定]适用于小数组,数组已排好序或接近于排好序速度将会非常快复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 归并排序[稳定]采用分治法复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(n)[平均 - 最好 - 最坏 - 空间复杂度] 冒泡排序[稳定]复杂度：O(n^2) - O(n) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 基数排序 分配+收集[稳定]复杂度： O(d(n+r)) r为基数d为位数 空间复杂度O(n+r) 树排序应用：TreeSet的add方法、TreeMap的put方法不支持相同元素,没有稳定性问题复杂度：平均最差O(nlogn) 堆排序(就地排序)复杂度：O(nlogn) - O(nlgn) - O(nlgn) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 快速排序复杂度：O(nlgn) - O(nlgn) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度]栈空间0(lgn) - O(n) 选择排序复杂度：O(n^2) - O(n^2) - O(n^2) - O(1)[平均 - 最好 - 最坏 - 空间复杂度] 希尔排序复杂度 小于O(n^2) 平均 O(nlgn) 最差O(n^s)[1&lt;s&lt;2] 空间O(1) 26.查找与散列26.1 散列函数设计 直接定址法:1234简单、均匀,不易产生冲突。但需事先知道关键字的分布情况,适合查找表较小且连续的情况,故现实中并不常用* 除留余数法:```f(key) = key mod p (p&lt;=m) p取小于表长的最大质数 m为表长 DJBX33A算法(time33哈希算法hash = hash*33+(unsigned int)str[i]; 平方取中法 折叠法 更多…. 26.2 冲突处理 闭散列(开放地址方法):要求装填因子a较小，闭散列方法把所有记录直接存储在散列表中 线性探测:易产生堆积现象(基地址不同堆积在一起) 二次探测:f(key) = (f(key)+di) % m di=1^2,-1^2,2^2,-2^2…可以消除基本聚集 随机探测:f(key) = (f(key)+di),di采用随机函数得到,可以消除基本聚集 双散列:避免二次聚集 开散列(链地址法):原地处理 同义词记录存储在一个单链表中,散列表中子存储单链表的头指针。 优点:无堆积 事先无需确定表长 删除结点易于实现 装载因子a&gt;=1,缺点:需要额外空间 27.枚举类JDK1.5出现 每个枚举值都需要调用一次构造函数 28.数组复制方法 for逐一复制 System.arraycopy() -&gt; 效率最高native方法 Arrays.arrayOf() -&gt; 本质调用arraycopy clone方法 -&gt; 返回Object[],需要强制类型转换 29.多态 Java通过方法重写和方法重载实现多态 方法重写是指子类重写了父类的同名方法 方法重载是指在同一个类中，方法的名字相同，但是参数列表不同 30.Java文件.java文件可以包含多个类，唯一的限制就是：一个文件中只能有一个public类， 并且此public类必须与文件名相同。而且这些类和写在多个文件中没有区别。 31.Java移位运算符java中有三种移位运算符 &lt;&lt; :左移运算符,x &lt;&lt; 1,相当于x乘以2(不溢出的情况下),低位补0 :带符号右移,x &gt;&gt; 1,相当于x除以2,正数高位补0,负数高位补1 :无符号右移,忽略符号位,空位都以0补齐 32.形参&amp;实参 形式参数可被视为local variable.形参和局部变量一样都不能离开方法。只有在方法中使用，不会在方法外可见。 形式参数只能用final修饰符，其它任何修饰符都会引起编译器错误。但是用这个修饰符也有一定的限制，就是在方法中不能对参数做任何修改。不过一般情况下，一个方法的形参不用final修饰。只有在特殊情况下，那就是：方法内部类。一个方法内的内部类如果使用了这个方法的参数或者局部变量的话，这个参数或局部变量应该是final。 形参的值在调用时根据调用者更改，实参则用自身的值更改形参的值（指针、引用皆在此列），也就是说真正被传递的是实参。 33.IO 34.局部变量为什么要初始化局部变量是指类方法中的变量，必须初始化。局部变量运行时被分配在栈中，量大，生命周期短，如果虚拟机给每个局部变量都初始化一下，是一笔很大的开销，但变量不初始化为默认值就使用是不安全的。出于速度和安全性两个方面的综合考虑，解决方案就是虚拟机不初始化，但要求编写者一定要在使用前给变量赋值。 35.JDK提供的用于并发编程的同步器 Semaphore Java并发库的Semaphore可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 CyclicBarrier 主要的方法就是一个：await()。await()方法每被调用一次，计数便会减少1，并阻塞住当前线程。当计数减至0时，阻塞解除，所有在此CyclicBarrier上面阻塞的线程开始运行。 直译过来就是倒计数(CountDown)门闩(Latch)。倒计数不用说，门闩的意思顾名思义就是阻止前进。在这里就是指 CountDownLatch.await() 方法在倒计数为0之前会阻塞当前线程。 36.Java类加载器一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： Bootstrap ClassLoader(引导类加载器) 负责加载java基础类，主要是 %JRE_HOME/lib/目录下的rt.jar、resources.jar、charsets.jar等 Extension ClassLoader(扩展类加载器) 负责加载java扩展类，主要是 %JRE_HOME/lib/ext目录下的jar等 App ClassLoader(系统类加载器) 负责加载当前java应用的classpath中的所有类。classloader 加载类用的是全盘负责委托机制。 所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。所以，当我们自定义的classloader加载成功了com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。 37.Java语言的鲁棒性Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外，Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。 38.Java语言特性 Java致力于检查程序在编译和运行时的错误 Java虚拟机实现了跨平台接口 类型检查帮助检查出许多开发早期出现的错误 Java自己操纵内存减少了内存出错的可能性 Java还实现了真数组，避免了覆盖数据的可能 39.Hibernate延迟加载 Hibernate2延迟加载实现：a)实体对象 b)集合（Collection） Hibernate3 提供了属性的延迟加载功能当Hibernate在查询数据的时候，数据并没有存在与内存中，当程序真正对数据的操作时，对象才存在与内存中，就实现了延迟加载，他节省了服务器的内存开销，从而提高了服务器的性能。 hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 40.包装类的equals()方法不处理数据转型，必须类型和值都一样才相等。41.子类可以继承父类的静态方法！但是不能覆盖。因为静态方法是在编译时确定了，不能多态，也就是不能运行时绑定。42.Java语法糖 Java7的switch用字符串 - hashcode方法 switch用于enum枚举 伪泛型 - List原始类型 自动装箱拆箱 - Integer.valueOf和Integer.intValue foreach遍历 - Iterator迭代器实现 条件编译 enum枚举类、内部类 可变参数 - 数组 断言语言 try语句中定义和关闭资源 43.JVM工具命令行 jps(jvm processor status)虚拟机进程状况工具 jstat(jvm statistics monitoring)统计信息监视 jinfo(configuration info for java)配置信息工具 jmap(memory map for java)Java内存映射工具 jhat(JVM Heap Analysis Tool)虚拟机堆转储快照分析工具 jstack(Stack Trace for Java)Java堆栈跟踪工具 HSDIS：JIT生成代码反汇编 可视化 JConsole(Java Monitoring and Management Console):Java监视与管理控制台 VisualVM(All-in-one Java Troubleshooting Tool):多合一故障处理工具]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java学习要点]]></title>
    <url>%2F2016%2F11%2F19%2Fjava%E5%AD%A6%E4%B9%A0%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[作为一个程序员,在找工作的过程中,都会遇到笔试,而很多笔试里面都包括java,尤其是作为一个Android开发工程师,java是必备技能之一.所以为了笔试过程中能够有一个不错的成绩,我在网上也找了好多关于java面试的题目.下面是整理的相关资料.参考作者jackfrued（简书作者）hongdada（简书作者）.面向对象的特征有哪些方面–面向对象的特征主要有一下几个方面:抽象,继承,封装,多态下面将一一解释.抽象是将一类对象的共同特征总结出来构造类的过程.包括数据抽象和行为抽象两部分.抽象只关注对象有哪些属性和行为,并不关注这些行为的细节是什么.继承: 继承是从已有类得到继承信息创建新类的过程,提供继承信息的类被称为父类(基类或者超类);得到继承信息的类被称为子类或者派生类.继承让变化中的软件系统有了一定的延续性.同时继承也是封装程序中可变因素的重要手段.(在这里可以参考阎宏博士的《Java与模式》或《设计模式精解》中关于桥梁模式的部分)封装:通常认为封装是把数据和操作数据的方法绑定起来,对数据的访问只能通过已经定义的窗口.面向对象的本质是将现实世界描绘成一系列完全封闭自治的对象. 我们在类中编写的方法就是对实现细节的一种封装. 我们编写一个类就是对数据和数据操作一种封装. 封装是隐藏一切可以隐藏的东西,只向外界提供最简单的编程接口. (就像我们现在使用的很多东西,其实过程很复杂,但是到了我们使用的那一步就是最简单的了,因为把复杂的过程都封装起来了,只给我们最简单的接口.)多态: 多态是指允许不同子类型的对象对同一消息做出不同的响应.可以理解为同样的对象调用了同样的方法但是实现了不同的功能.多态又分为编译时的多态和运行时的多态.如果将对象的方法视为对象向外界提供的服务,那么运行时的多态可以解释为:当A系统访问B系统提供的服务时,B系统有多种提供服务的方式，但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，究竟通过何种方式获得了动力）. 方法重载（overload）实现的是编译时的多态性（也称为前绑定） 方法重写（override） 实现的是运行时的多态性（也称为后绑定）运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：1). 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；2). 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 访问修饰符public,private,protected,以及不写（默认）时的区别 修饰符 当前类 同 包 子 类 其他包 访问权限 public √ √ √ √ 公开(外部类) protected √ √ √ × 受保护的 default √ √ × × 默认的(外部类) private √ × × × 私有的 ##String是最基本的数据类型么?##不是的,java中最基本的数据类型有八种: 数据类型 字节型 短整型 整型 长整型 浮点型 双精度 字符型 布尔型 数据类型 byte short int long float double char boolean 所占内存 8 16 32 64 32 64 16 / 除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）。为什么用枚举实现的单例是最好的方式 枚举写法简单enum Singleton&#123; INSTANCE;；&#125;```1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253- 枚举自己处理序列化在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。----------## String 和 StringBuilder 的区别String 类型和 StringBuffer 类型的主要性能区别其实在于: *String 是不可变的对象*。因此在每次**对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象**，然后将指针指向新的 String 对象，*所以经常改变内容的字符串最好不要用 String* ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM 的 GC 就会开始工作，影响性能，可以考虑使用可变字符序列StringBuilder----------## float f=3.4;正确么? 不正确,因为3.4是双精度,将双精度型（double）赋值给浮点型（float）属于下转型（**down-casting，也称为窄化**）会造成精度损失，因此需要 **强制类型转换** float f =*(float)3.4*; 或者写成float f =*3.4F*;----------## *`short s1 = 1; s1 = s1 + 1;`*有错吗?*`short s1 = 1; s1 += 1;`*有错吗？对于short s1 = 1; s1 = s1 + 1;由于1是int类型，因此s1+1运算结果也是int 型，需要强制转换类型才能赋值给short型。`short s1 = 1;s1= (short)s1 +1;`而short s1 = 1; s1 += 1;可以正确编译，因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。----------## Java 面试问题列表包含的相关主题：- 多线程，并发及线程基础- 数据类型转换的基本原则- 垃圾回收（GC）- Java 集合框架- 数组- 字符串- GOF 设计模式- SOLID （单一功能、开闭原则、里氏替换、接口隔离以及依赖反转）设计原则- 抽象类与接口- Java 基础，如 equals 和 hashcode- 泛型与枚举- Java IO 与 NIO- 常用网络协议- Java 中的数据结构和算法- 正则表达式- JVM 底层- Java 最佳实践- JDBC- Date, Time 与 Calendar- Java 处理 XML- JUnit- 编程----------## 多线程、并发及线程的基础问题1）Java 中能创建 volatile 数组吗？能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。2）volatile 能使得一个非原子操作变成原子操作吗？一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。3）volatile 修饰符的有过什么实践？一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。4）volatile 类型变量提供什么保证？volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。5) 10 个线程和 2 个线程的同步代码，哪个更容易写？从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。6）你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码： java// The standard idiom for using the wait methodsynchronized (obj) {while (condition does not hold)obj.wait(); // (Releases lock, and reacquires on wakeup)… // Perform action appropriate to condition}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123参见 Effective Java 第 69 条，获取更多关于为什么应该在循环中来调用 wait 方法的内容。7）什么是多线程环境下的伪共享（false sharing）？伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行，如下图所示：![这里写图片描述](http://upload-images.jianshu.io/upload_images/3162008-bbb5d23b5b82ec57?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)伪共享问题很难被发现，因为线程可能访问完全不同的全局变量，内存中却碰巧在很相近的位置上。如其他诸多的并发问题，避免伪共享的最基本方式是仔细审查代码，根据缓存行来调整你的数据结构。----------### 有经验程序员的 Java 面试题8）什么是 Busy spin？我们为什么要使用它？Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他CPU上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。9）Java 中怎么获取一份线程 dump 文件？在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java 应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用Tomcat。10）Swing 是线程安全的？不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如 JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing 提供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。你也可以在参考答案中查看和学习到更详细的内容。11）什么是线程局部变量？当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,每个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本,是线程隔离的。线程隔离的秘密在于ThreadLocalMap类(ThreadLocal的静态内部类)线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。ThreadLocal的方法：void set(T value)、T get()以及T initialValue()。#### ThreadLocal是如何为每个线程创建变量的副本的：首先，在每个线程Thread内部有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，这个threadLocals就是用来存储实际的变量副本的，键值为当前ThreadLocal变量，value为变量副本（即T类型的变量）。初始时，在Thread里面，threadLocals为空，当通过ThreadLocal变量调用get()方法或者set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为键值，以ThreadLocal要保存的副本变量为value，存到threadLocals。然后在当前线程里面，如果要使用副本变量，就可以通过get方法在threadLocals里面查找。## 总结：##a.实际的通过ThreadLocal创建的副本是存储在每个线程自己的threadLocals中的b.为何threadLocals的类型ThreadLocalMap的键值为ThreadLocal对象，因为每个线程中可有多个threadLocal变量，就像上面代码中的longLocal和stringLocal；c.在进行get之前，必须先set，否则会报空指针异常；如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法----------12）用 wait-notify 写一段代码来解决生产者-消费者问题？请参考答案中的示例代码。只要记住在同步块中调用 wait() 和 notify()方法，如果阻塞，通过循环来测试等待条件。13) 用 Java 写一个线程安全的单例模式（Singleton）？请参考答案中的示例代码，这里面一步一步教你创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。14）Java 中 sleep 方法和 wait 方法的区别？虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。15）什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer及其它包装类。详情参见答案，一步一步指导你在 Java 中创建一个不可变的类。16）我们能创建一个包含可变对象的不可变对象吗？是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。## 数据类型和 Java 基础面试问题17）Java 中应该使用什么数据类型来代表价格？如果不是特别关心内存和性能的话，使用BigDecimal，否则使用预定义精度的 double 类型。18）怎么将 byte 转换为 String？可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。19）Java 中怎样将 bytes 转换为 long 类型？String接收bytes的构造器转成String，再Long.parseLong20）我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。21）存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为 C 么？如 C = (C) B；可以，向下转型。但是不建议使用，容易出现类型转型异常.22）哪个类包含 clone 方法？是 Cloneable 还是 Object？java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。23）Java 中 ++ 操作符是线程安全的吗？不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。24）a = a + b 与 a += b 的区别+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。```javabyte a = 127;byte b = 127;b = a + b; // error : cannot convert from int to byteb += a; // ok```（因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte 就会编译出错）25）我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。26）3 ×0.1 == 0.3 将会返回什么？true 还是 false？false，因为有些浮点数不能完全精确的表示出来。27）int 和 Integer 哪个会占用更多的内存？Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。28）为什么 Java 中的 String 是不可变的（Immutable）？Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。更详细的内容参见答案。29）我们能在 Switch 中使用 String 吗？从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。30）Java 中的构造器链是什么？当你从一个构造器中调用另一个构造器，就是Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。## JVM 底层 与 GC（Garbage Collection） 的面试问题## 31）64 位 JVM 中，int 的长度是多数？Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在 32 位 和 64 位 的Java 虚拟机中，int 类型的长度是相同的。32）Serial 与 Parallel GC之间的不同之处？Serial 与 Parallel 在GC执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而 parallel 收集器使用多个 GC 线程来执行。33）32 位和 64 位的 JVM，int 类型变量的长度是多数？32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4 个字节。34）Java 中 WeakReference 与 SoftReference的区别？Java中一共有四种类型的引用。StrongReference、 SoftReference、 WeakReference 以及 PhantomReference。StrongReference 是 Java 的默认引用实现, 它会尽可能长时间的存活于 JVM 内，当没有任何对象指向它时将会被GC回收WeakReference，顾名思义, 是一个弱引用, 当所引用的对象在 JVM 内不再有强引用时, 将被GC回收虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而 SoftReference 会尽可能长的保留引用直到 JVM 内存不足时才会被回收(虚拟机保证), 这一特性使得 SoftReference 非常适合缓存应用35）WeakHashMap 是怎么工作的？WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key/value 将会被回收。36）JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从 32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU 缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM 主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过 -XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。37）怎样通过 Java 程序来判断 JVM 是 32 位 还是 64 位？你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。38）32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约 3GB。64 位 JVM允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。39）JRE、JDK、JVM 及 JIT 之间有什么不同？JRE 代表 Java 运行时（Java run-time），是运行 Java 应用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java 编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。![JRE](http://upload-images.jianshu.io/upload_images/3162008-74eb4edd9c3b2724?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)## 3 年工作经验的 Java 面试题40）解释 Java 堆空间及 GC？当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。## JVM 底层面试题及答案 41）你能保证 GC 执行吗？不能，虽然你可以调用 System.gc() 或者 Runtime.getRuntime().gc()，但是没有办法保证 GC 的执行。42）怎么获取 Java 程序使用的内存？堆使用的百分比？可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory() 方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。43）Java 中堆和栈有什么区别？JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。Difference between stack and heap memory in Java## 关于内存的的面试问题和答案 **Java 基本概念面试题**44）“a==b”和”a.equals(b)”有什么区别？如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。45）a.hashCode() 有什么用？与 a.equals(b) 有什么关系？hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。46）final、finalize 和 finally 的不同之处？final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，但是什么时候调用 finalize 没有保证。finally 是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。47）Java 中的编译期常量是什么？使用它又什么风险？公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。## Java 集合框架的面试题这部分也包含数据结构、算法及数组的面试问题48) List、Set、Map 和 Queue 之间的区别(答案)List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。49）poll() 方法和 remove() 方法的区别？poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。50）Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？(答案)PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是 LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。51）ArrayList 与 LinkedList 的不区别？(答案)最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而 LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。更多细节的讨论参见答案。52）用哪两种方式来实现集合的排序？(答案)你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。53）Java 中怎么打印数组？(answer答案)你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println() 方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。54）Java 中的 LinkedList 是单向链表还是双向链表？(答案)是双向链表，你可以检查 JDK 的源码。在 Eclipse，你可以使用快捷键 Ctrl + T，直接在编辑器中打开该类。55）Java 中的 TreeMap 是采用什么树实现的？(答案)Java 中的 TreeMap 是使用红黑树实现的。56) Hashtable 与 HashMap 有什么不同之处？(答案)这两个类有许多不同的地方，下面列出了一部分：a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。更多的不同之处参见答案。57）Java 中的 HashSet，内部是如何工作的？(answer答案)HashSet 的内部采用 HashMap来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的 key，只允许有一个null key，意思就是 HashSet 中只允许存储一个 null 对象。58）写一段代码在遍历 ArrayList 时移除一个元素？(答案)该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的 remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。59）我们能自己写一个容器类，然后使用 for-each 循环吗？可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。60）ArrayList 和 HashMap 的默认大小是多数？(答案)在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段： java// from ArrayList.java JDK 1.7private static final int DEFAULT_CAPACITY = 10;//from HashMap.java JDK 7static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 161234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757661）有没有可能两个不相等的对象有有相同的 hashcode？有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在 hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的hashcode 值，但是没有关于不相等对象的任何规定。62）两个相同的对象会有不同的的 hash code 吗？不能，根据 hash code 的规定，这是不可能的。63）我们可以在 hashcode() 中使用随机数字吗？(答案)不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。64）Java 中，Comparator 与 Comparable 有什么不同？(答案)Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。65）为什么在重写 equals 方法的时候需要重写 hashCode 方法？(答案)因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。----------## Java IO 和 NIO 的面试题IO 是 Java 面试中一个非常重要的点。你应该很好掌握 Java IO，NIO，NIO2 以及与操作系统，磁盘 IO 相关的基础知识。下面是 Java IO 中经常问的问题。66）在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？67）Java 中怎么创建 ByteBuffer？68）Java 中，怎么读写 ByteBuffer ？69）Java 采用的是大端还是小端？70）ByteBuffer 中的字节序是什么？71）Java 中，直接缓冲区与非直接缓冲器有什么区别？(答案)72）Java 中的内存映射缓存区是什么？(answer答案)73）socket 选项 TCP NO DELAY 是指什么？74）TCP 协议与 UDP 协议有什么区别？(answer答案)75）Java 中，ByteBuffer 与 StringBuffer有什么区别？(答案)----------## Java 最佳实践的面试问题包含 Java 中各个部分的最佳实践，如集合，字符串，IO，多线程，错误和异常处理，设计模式等等。76）Java 中，编写多线程程序的时候你会遵循哪些最佳实践？(答案)这是我在写Java 并发程序的时候遵循的一些最佳实践：a）给线程命名，这样可以帮助调试。b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。c）如果可以，更偏向于使用 volatile 而不是 synchronized。d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semeaphore。e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。77）说出几点 Java 中使用 Collections 的最佳实践(答案)这是我在使用 Java 中 Collectionc 类的一些最佳实践：a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是 Vector。b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。c）使用接口代表和访问集合，如使用List存储 ArrayList，使用 Map 存储 HashMap 等等。d）使用迭代器来循环集合。e）使用集合的时候使用泛型。78）说出至少 5 点在 Java 中使用线程的最佳实践。(答案)这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：a）对线程命名b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。c）使用线程池79）说出 5 条 IO 的最佳实践(答案)IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。b）使用 NIO 和 NIO2c）在 finally 块中关闭流，或者使用 try-with-resource（Java7） 语句。d）使用内存映射文件获取更快的 IO。80）列出 5 个应该遵循的 JDBC 最佳实践(答案)有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：a）使用批量的操作来插入和更新数据b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。c）使用数据库连接池d）通过列名来获取结果集，不要使用列的下标来获取。81）说出几条 Java 中方法重载的最佳实践？(答案)下面有几条可以遵循的方法重载的最佳实践来避免造成自动装箱的混乱。a）不要重载这样的方法：一个方法接收 int 参数，而另个方法接收 Integer 参数。b）不要重载参数数量一致，而只是参数顺序不同的方法。c）如果重载的方法参数个数多于 5 个，采用可变参数。----------## Date、Time 及 Calendar 的面试题82）在多线程环境下，SimpleDateFormat 是线程安全的吗？(答案)不是，非常不幸，DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的，因此你不应该在多线程序中使用，除非是在对外线程安全的环境中使用，如 将 SimpleDateFormat 限制在 ThreadLocal 中。如果你不这么做，在解析或者格式化日期的时候，可能会获取到一个不正确的结果。因此，从日期、时间处理的所有实践来说，我强力推荐 joda-time 库。83）Java 中如何格式化一个日期？如格式化为 ddMMyyyy 的形式？(答案)Java 中，可以使用 SimpleDateFormat 类或者 joda-time 库来格式日期。DateFormat 类允许你使用多种流行的格式来格式化日期。参见答案中的示例代码，代码中演示了将日期格式化成不同的格式，如 dd-MM-yyyy 或 ddMMyyyy。84）Java 中，怎么在格式化的日期中显示时区？pattern中加z `yyyy-MM-dd HH:mm:ss.SSS Z`85）Java 中 java.util.Date 与 java.sql.Date 有什么区别？java.sql.Date是针对SQL语句使用的，它只包含日期而没有时间部分,它们都有getTime方法返回毫秒数，自然就可以直接构建。java.util.Date 是 java.sql.Date 的父类，前者是常用的表示时间的类，我们通常格式化或者得到当前时间都是用他，后者之后在读写数据库的时候用他，因为PreparedStament的setDate()的第2参数和ResultSet的getDate()方法的第2个参数都是java.sql.Date。86）Java 中，如何计算两个日期之间的差距？ javapublic static int dateDiff(Date d1, Date d2) throws Exception {long n1 = d1.getTime();long n2 = d2.getTime();long diff = Math.abs(n1 - n2);diff /= 3600 1000 24;return diff;}`87）Java 中，如何将字符串 YYYYMMDD 转换为日期？SimpleDateFormat的parse方法 单元测试 JUnit 面试题89）如何测试静态方法？(答案)可以使用 PowerMock 库来测试静态方法。90）怎么利用 JUnit 来测试一个方法的异常？(答案)91）你使用过哪个单元测试库来测试你的 Java 程序？(答案)92）@Before 和 @BeforeClass 有什么区别？(答案) 编程和代码相关的面试题93）怎么检查一个字符串只包含数字？(解决方案)94）Java 中如何利用泛型写一个 LRU 缓存？(答案)95）写一段 Java 程序将 byte 转换为 long？(答案)96）在不使用 StringBuffer 的前提下，怎么反转一个字符串？(解决方案)97）Java 中，怎么获取一个文件中单词出现的最高频率？(解决方案)98）如何检查出两个给定的字符串是反序的？(解决方案)99）Java 中，怎么打印出一个字符串的所有排列？(解决方案)100）Java 中，怎样才能打印出数组中的重复元素？(解决方案)101）Java 中如何将字符串转换为整数？(解决方案)102）在没有使用临时变量的情况如何交换两个整数变量的值？(解决方案) 关于 OOP 和设计模式的面试题这部分包含 Java 面试过程中关于 SOLID 的设计原则，OOP 基础，如类，对象，接口，继承，多态，封装，抽象以及更高级的一些概念，如组合、聚合及关联。也包含了 GOF 设计模式的问题。103）接口是什么？为什么要使用接口而不是直接使用具体类？接口用于定义 API。它定义了类必须得遵循的规则。同时，它提供了一种抽象，因为客户端只使用接口，这样可以有多重实现，如 List 接口，你可以使用可随机访问的 ArrayList，也可以使用方便插入和删除的 LinkedList。接口中不允许写代码，以此来保证抽象，但是 Java 8 中你可以在接口声明静态的默认方法，这种方法是具体的。104）Java 中，抽象类与接口之间有什么不同？(答案)Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。关于这个问题的讨论请查看答案。105）除了单例模式，你在生产环境中还用过什么设计模式？这需要根据你的经验来回答。一般情况下，你可以说依赖注入，工厂模式，装饰模式或者观察者模式，随意选择你使用过的一种即可。不过你要准备回答接下的基于你选择的模式的问题。106）你能解释一下里氏替换原则吗?(答案)107) 什么情况下会违反迪米特法则？为什么会有这个问题？(答案)迪米特法则建议“只和朋友说话，不要陌生人说话”，以此来减少类之间的耦合。108）适配器模式是什么？什么时候使用？适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。109）什么是“依赖注入”和“控制反转”？为什么有人使用？(答案)110）抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？(答案)111）构造器注入和 setter 依赖注入，那种方式更好？(答案)每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是 setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。112）依赖注入和工厂模式之间有什么不同？(答案)虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。关于这个话题的更详细讨论请参见答案。113）适配器模式和装饰器模式有什么区别？(答案)虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。114）适配器模式和代理模式之前有什么不同？(答案)这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。115）什么是模板方法模式？(答案)模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用 Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。116）什么时候使用访问者模式？(答案)访问者模式用于解决在类的继承层次上增加操作，但是不直接与之关联。这种模式采用双派发的形式来增加中间层。117）什么时候使用组合模式？(答案)组合模式使用树结构来展示部分与整体继承关系。它允许客户端采用统一的形式来对待单个对象和对象容器。当你想要展示对象这种部分与整体的继承关系时采用组合模式。118）继承和组合之间有什么不同？(答案)虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。119）描述 Java 中的重载和重写？(答案)重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。120）Java 中，嵌套公共静态类与顶级类有什么不同？(答案)类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。121) OOP 中的 组合、聚合和关联有什么区别？(答案)如果两个对象彼此有关系，就说他们是彼此相关联的。组合和聚合是面向对象中的两种形式的关联。组合是一种比聚合更强力的关联。组合中，一个对象是另一个的拥有者，而聚合则是指一个对象使用另一个对象。如果对象 A 是由对象 B 组合的，则 A 不存在的话，B一定不存在，但是如果 A 对象聚合了一个对象 B，则即使 A 不存在了，B 也可以单独存在。122）给我一个符合开闭原则的设计模式的例子？(答案)开闭原则要求你的代码对扩展开放，对修改关闭。这个意思就是说，如果你想增加一个新的功能，你可以很容易的在不改变已测试过的代码的前提下增加新的代码。有好几个设计模式是基于开闭原则的，如策略模式，如果你需要一个新的策略，只需要实现接口，增加配置，不需要改变核心逻辑。一个正在工作的例子是 Collections.sort() 方法，这就是基于策略模式，遵循开闭原则的，你不需为新的对象修改 sort() 方法，你需要做的仅仅是实现你自己的 Comparator 接口。123）抽象工厂模式和原型模式之间的区别？(答案)124）什么时候使用享元模式？(答案)享元模式通过共享对象来避免创建太多的对象。为了使用享元模式，你需要确保你的对象是不可变的，这样你才能安全的共享。JDK 中 String 池、Integer 池以及 Long 池都是很好的使用了享元模式的例子。 Java 面试中其他各式各样的问题这部分包含 Java 中关于 XML 的面试题，JDBC 面试题，正则表达式面试题，Java 错误和异常及序列化面试题125）嵌套静态类与顶级类有什么区别？(答案)一个公共的顶级类的源文件名称与类名相同，而嵌套静态类没有这个要求。一个嵌套类位于顶级类内部，需要使用顶级类的名称来引用嵌套静态类，如 HashMap.Entry 是一个嵌套静态类，HashMap 是一个顶级类，Entry是一个嵌套静态类。126）你能写出一个正则表达式来判断一个字符串是否是一个数字吗？(解决方案)一个数字字符串，只能包含数字，如 0 到 9 以及 +、- 开头，通过这个信息，你可以下一个如下的正则表达式来判断给定的字符串是不是数字。127）Java 中，受检查异常 和 不受检查异常的区别？(答案)受检查异常编译器在编译期间检查。对于这种异常，方法强制处理或者通过 throws 子句声明。其中一种情况是 Exception 的子类但不是 RuntimeException 的子类。非受检查是 RuntimeException 的子类，在编译阶段不受编译器的检查。128）Java 中，throw 和 throws 有什么区别？(答案)throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″)而throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。129）Java 中，Serializable 与 Externalizable 的区别？(答案)Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。130）Java 中，DOM 和 SAX 解析器有什么不同？(答案)DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。131）说出 JDK 1.7 中的三个新特性？(答案)虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如 try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。Fork-Join 池某种程度上实现 Java 版的 Map-reduce。允许 Switch 中有 String 变量和文本。菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。132）说出 5 个 JDK 1.8 引入的新特性？(答案)Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：Lambda 表达式，允许像对象一样传递匿名函数Stream API，充分利用现代多核 CPU，可以写出很简洁的代码Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用扩展方法，现在，接口中可以有静态、默认方法。重复注解，现在你可以将相同的注解在同一类型上使用多次。133）Java 中，Maven 和 ANT 有什么区别？(答案)虽然两者都是构建工具，都用于创建 Java 应用，但是 Maven 做的事情更多，在基于“约定优于配置”的概念下，提供标准的Java 项目结构，同时能为应用自动管理依赖（应用中所依赖的 JAR 文件），Maven 与 ANT 工具更多的不同之处请参见答案。这就是所有的面试题，如此之多，是不是？我可以保证，如果你能回答列表中的所有问题，你就可以很轻松的应付任何核心 Java 或者高级 Java 面试。虽然，这里没有涵盖 Servlet、JSP、JSF、JPA，JMS，EJB 及其它 Java EE 技术，也没有包含主流的框架如 Spring MVC，Struts 2.0，Hibernate，也没有包含 SOAP 和 RESTful web service，但是这份列表对做 Java 开发的、准备应聘 Java web 开发职位的人还是同样有用的，因为所有的 Java 面试，开始的问题都是 Java 基础和 JDK API 相关的。如果你认为我这里有任何应该在这份列表中而被我遗漏了的 Java 流行的问题，你可以自由的给我建议。我的目的是从最近的面试中创建一份最新的、最优的 Java 面试问题列表。 Java EE 相关的面试题为了做 Java EE 的朋友，这里列出了一些 web 开发的特定问题，你们可以用来准备 JEE 部分的面试：10 大 Spring 框架面试题及答案(参见)10 个非常好的 XML 面试问题（Java 程序员）(参见)20 个非常好的设计模式面试问题(参见)10个最流行的 Struts 面试题（Java 开发者）(参见)20 个 Tibco Rendezvous 及 EMS 的面试题(更多)10 个最频繁被问到的 Servlet 面试问题及答案(参见)20 个 jQuery 面试问题（Java Web 开发者）(列表)10 个非常好的 Oracle 面试问题（Java 开发者）(参见)10 大 来自 J2EE 面试中的 JSP 问题(更多)12 个很好的 RESTful Web Services 面试问题(参见)10 大 EJB 面试问题及答案(参见)10 大 JMS 及 MQ 系列面试题及答案(列表)10 个非常好 Hibernate 面试问题（Java EE 开发者）(参见)10 个非常好的 JDBC 面试题（Java 开发者）(参见)15 个 Java NIO 和网络面试题及答案(参见)10 大 XSLT 面试题及答案(更多)15 个来自 Java 面试的数据结构和算法问题(参见)10 大 Java 面试难题及答案(参见)40 个核心 Java 移动开发面试题及答案(列表)推荐给 Java 面试者的书籍如果你正为 Java 面试寻找好的准备，你可以看一下下面的书籍，这些书籍包含了理论及编码的相关问题Markham 的 Java 编程面试揭秘(参见)破解编码面试：150 个编程问题及解答(参见)程序面试揭秘：寻找下一份工作的秘密(参见)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[姑娘，你才二十三，怕什么？想要就去闯。]]></title>
    <url>%2F2016%2F11%2F17%2F%E5%A7%91%E5%A8%98%EF%BC%8C%E4%BD%A0%E6%89%8D%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%8C%E6%80%95%E4%BB%80%E4%B9%88%EF%BC%9F%E6%83%B3%E8%A6%81%E5%B0%B1%E5%8E%BB%E9%97%AF%E3%80%82%2F</url>
    <content type="text"><![CDATA[十一月十六号，我拖着行李从一个二线城市转到魔都，虹桥火车站一如既往的拥挤，到处都是人。辗转了两个多小时的地铁到达了住的地方，比大部分人可能幸运的是我父母也在这座城市打工。学校的课已经正式结束，到了我们找实习的时间了，准确说开始找工作了，在学校，经常听人说毕业就失业。那时觉得不可置信，中国这么大，工作岗位那么多，怎么可能没有。晚上和闺蜜包包视频，她问我有没有找到工作，我说还没有，在刷题，过几天投简历打算去面试。包包和我说，咱班出去找工作的人大部分都没找到。我很诧异，感觉有几个学的不错啊，这里插一句，我的专业是移动互联网，说白了就是搞Android,前端，java的。包包说那些出去找的都被打击了，没离校的基本呆在寝室。 晚上我在重新修改简历时发现，现在的我似乎进入了一个工厂化的模式，学校是一个大工厂，而我就是其中一个零件，现在零件上加了材料，可以被送往更大的工厂进行修改。说白了我就像一批货物。我的思想去哪了？我当初的那些理想那些志向去哪了？简历上的我为了迎合工厂开始包装自己，不管真实与否不管欲望与否开始冲。 我不禁想起来才上大学的我，斗志昂扬，想要成就一番事业，不枉此生，可能每个初入大学的学子都怀揣着这样的想法，然后渐渐沉淀。初中时，我看到很多人都有一些小发明，那时候我也有很多想法，想要实现做出自己的作品。可也只是想想，还记得那时有个想法是做直尺规，因为圆规不能直接就量出半径画圆，但是如果在直尺上安装了两只圆规脚就可以画圆还能准确画出半径。收起来还能当直尺，当时有了这个想法后很激动，但是作为一个初中生，也就自己想想玩玩，后来上了高中，想要做出来申请小专利，然后由于某些原因耽搁了，等到申请时才发现在我之前一年已经有人申请了，那一瞬间的心沉下去了。后来我明白如果你有想法，别人也有，你只是想想，别人不仅想了也做了。 所以大二时发现了我觉得还不错的商机，想要创业。创业肯定不是说说想想那么简单。我开始寻找伙伴想要组成一个团队，因为学校也支持大学生自主创业，于是我找到了我的一个盆友小马哥还有一个室友。那是我第一个创业计划，是一个校园里学生图书交换计划。我和小马哥一起制作了策划书PPT等相关材料，但是由于准备不充分，然后这个计划失败。后来学校举办了一个创业大赛，我也报名了，找了一个小伙伴，但也只是打酱油的，大一大二那会儿，大部分人对于学校还不感兴趣，基本心思都在玩上，想要找到志同道合的也很难，然后我单枪匹马，第二个计划是网络实地联盟。就是将实体店和网络联合起来，这个想法来源于女生逛街，因为很多时候逛街容易迷路，找不到想要的店，我就想如果有这样一款app里面就像一个虚拟现实世界那样，把周边的店按照地图分类显示，那么逛街时就可以不用担心找不到地方了，而且这些店类似网店，点开就能看到内部，女生逛街就可以省去很多麻烦还可以货比三家。我把策划书和PPT做好后去参加比赛，后来发现自己太单纯了。连初赛都没过。原以为是自己想法不够好，别人的可能更好一些。后来才知道原来只有学长学姐或者一些社长机会多。第二个创业计划也被扼杀。 后来过完暑假的我来到学校，看到人山人海的报名现场，想到我去年大一才来时的茫然无知，脑海中又想到一个idea.回到寝室之后，我把想法告诉了室友，室友们都说很好，然而没有人和我一起做。势单力薄。简单说下我这个小想法吧，估计也有小伙伴和我想到一块去了。每个大学刚开学人特多，而且新生大部分都对学校或者这个城市不熟悉，会被坑。好吧，我刚开学就被坑了。那时我还没接触Android这块，所以我想着制作一本小册子，里面内容大概就是学校简介，院系介绍，社团介绍，还有一些坑啥的，然后在新生到来时可以拿去卖。我还设计了版图，准备找小伙伴一起做，因为我上网查了，小册子制作费用不高，如果能找到广告上或许可以拉到投资，但是室友都说你想法不错，但是估计没人买吧，而且多麻烦啊，还要找人做。大家都不想做。我找了很多人，大家并不看好，后来这个计划也就不了了之。大二下学期，我开始学习一些语言，接触到更多的知识。后来我想要把这个想法做成一个APP.那时候我们还没学安卓，我也不知道我们会有这门课，但是我是一个比较执着的，我想要把这个想法做出来。于是我开始构思，开始搭建这个框架，那时候甚至没有电脑，都是在纸上画，写的。我把我的想法记在我的一本本子里。日积月累，构思涂涂改改。时间到了大三，我们开始学习专业课了，那时我想要自学Android.做出我想要的app,所以暑假我打了一个多月工终于买了我自己的电脑。大三开学，带我们的新老师姓蒋，我很喜欢她，感觉她懂得很多，于是某一天我就去她的办公室找她，把我的想法告诉了她，并问她有没有什么建议？蒋老师觉得我的想法很棒，说可以通过app实现。同时她也告诉我过一段时间我们也要上Android的课了，那时候我的心情是很棒的，然后在老师的建议下开始走向了摸索Android的路。 有人估计好奇，那你这个app做出来了么，只能说还在做，因为技术不够，光有想法实现不了。尤其是在我一个学期的重新构思之后，感觉自己心有力而气不足。这是我第三个创业计划，参加了校园互联网+，获得了一等奖，可是并没有任何用，没有成功，也不算太失败吧。 可是，看看现在的我，热情渐渐退缩，似乎快成了批发市场的商品了，越长大越后退，前怕狼后怕虎，今年暑假还在为自己的创业拉投资，打电话，到处推销。但是离开了校园，真正开始奋斗了，应该很兴奋，终于可以大干一场了，却开始退缩。姑娘，你才23，你怕什么？你想要，就去闯。失败了，再来。不疯狂一把，你还没青春过。 这两天经常听到朋友说担心找不到工作，烦心找工作，我想说，怕什么，你才23,学什么都不晚。当你的才华配上雄心。你不会后悔的。想要得到什么，就要付出相应的代价和努力。脚踏实地，总会留下自己的脚印。获取授权]]></content>
      <categories>
        <category>物语</category>
      </categories>
      <tags>
        <tag>物语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缠绵]]></title>
    <url>%2F2016%2F11%2F07%2F%E7%BC%A0%E7%BB%B5%2F</url>
    <content type="text"><![CDATA[时雨不休，侧耳倾听，淅淅沥沥如沙砾。常梦依旧，枕乐独思，断断续续似雨声。 想风越大，抚背撑夜，摇摇摆摆上九霄。 你若静好，岁月不老，简简单单听珠华。 获取授权]]></content>
      <categories>
        <category>为你写诗</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄远在天国的你]]></title>
    <url>%2F2016%2F11%2F07%2F%E5%AF%84%E8%BF%9C%E5%9C%A8%E5%A4%A9%E5%9B%BD%E7%9A%84%E4%BD%A0%2F</url>
    <content type="text"><![CDATA[缅怀逝去的奶奶 我不知道，这一天来得如此仓促还来不及收拾心情就要送你离开 我不知道，这一天你以如此决绝的方式离开不留一点希望黑暗骤然降临 我不知道，这一天是你期待多久才盼来的曾经的五十年只剩下零星的记忆 我不知道，这一天你回顾的最后一眼是否在寻找我的身影因为我的心在那刻缩紧 我所知道的这一天我学会了离别最后隔土的那一面是你冰冷的脸庞我所知道的这一天 要换来多少天的沉寂漫天的细丝点点的不舍 我所知道的是今年的除夕远在天国的你不会回来给我红包 我所知道的是冬天来了再没有人为我纳鞋了再没了忙碌的身影 如果知道，这一天来得如此早年幼的我也不会许下不能实现的美好 如果知道，这一天让我至今还在欺骗自己的心我就不会在梦里遇见你 如果你也想我这一年在除夕夜回来我们的梦里……想你的孙女]]></content>
      <categories>
        <category>为你写诗</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冬雨]]></title>
    <url>%2F2014%2F02%2F03%2F%E5%86%AC%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[如梦令红粉簌簌铺尘斜风细雨茵莱岁月悄无然今宵沉梦何处冬雨，冬雨]]></content>
      <categories>
        <category>为你写诗</category>
      </categories>
      <tags>
        <tag>诗</tag>
      </tags>
  </entry>
</search>
