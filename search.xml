<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自由软件]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6%E8%AE%B8%E5%8F%AF%E8%AF%81GPL%2F</url>
    <content type="text"><![CDATA[所谓“自由软件”就是让你可以自由使用的正版软件，典型代表就是使用GPL许可证的软件，只要软件的许可证是GPL，那么就是自由软件。 1980年，一个叫Richard Stallman的美国程序员，由于无法忍受软件私有化造成的代码封闭，而创立了GPL许可证。 “我试图从总体改变人们接触知识和信息的方式，我认为，个人占有知识，控制人们使用知识或是阻止人们共享知识的企图都是一种蓄意破坏行为。这是一种只有利于这样做的个别人，而代价趋却是使全社会贫困化的行为。” GPL许可证，允许任何人观看、修改，并散播程序软件里的原始程序码，唯一条件是如果你要发布修改后的版本就要连源代码一起公布。 &quot; 大多数软件许可证决意剥夺你的共享和修改软件的自由。对比之下，GNU通用公共许可证GPL力图保证你的共享和修改自由软件的自由。----保证自由软件对所有用户是自由的。GPL适用于大多数自由软件基金会的软件，以及由使用这些软件而承担义务的作者所开发的软件。（自由软件基金会的其他一些软件受GNU库通用许可证的保护）。你也可以将它用到你的程序中。当我们谈到自由软件（free software）时，我们指的是自由而不是价格。&quot; GUN通用公共许可协议]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php中时间戳等相关小概念笔记]]></title>
    <url>%2F2018%2F09%2F25%2Fphp%E4%B8%AD%E6%97%B6%E9%97%B4%E6%88%B3%E7%AD%89%E7%9B%B8%E5%85%B3%E5%B0%8F%E6%A6%82%E5%BF%B5%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[首先说下时间戳吧,因为工作需要,对接接口时要用到各种类型的时间戳,所以抽个时间把这些时间戳整理了下.如果想看看返回的时间戳对不对,这里有个在线转换工具,可以试试时间戳在线转换 获取当前的时间戳是最简单的格式如下:$test = time();它返回当前的 Unix 时间戳.这是返回的结果1487839316 获取当前日期下的零时零点零分的时间戳格式如下:$tmp1 = date(&quot;Y-m-d H:i:s&quot;, mktime(0, 0, 0, date(&quot;m&quot;), date(&#39;d&#39;), date(&quot;Y&quot;)));这个获取的是当前日期下的零时零点零分的时间.打印如下结果:2017-02-23 00:00:00但是这里直接使用strtotime获取的并不是这个时间,他实际返回的是2017-02-23 07:00:00.这个结果和mktime(0, 0, 0, date(&quot;m&quot;), date(&#39;d&#39;), date(&quot;Y&quot;))是一样的.如果想要得到当前日期下的零时零点零分的时间戳,需要这样12345$tmp = mktime(0, 0, 0, date(&quot;m&quot;), date(&apos;d&apos;), date(&quot;Y&quot;));$tmp1 = date(&quot;Y-m-d H:i:s&quot;, mktime(0, 0, 0, date(&quot;m&quot;), date(&apos;d&apos;), date(&quot;Y&quot;)));//显示$tmp2 = strtotime($tmp1)-25200;$tmp3 = $tmp - 25200;//等价于$tmp2print_r($tmp3); 获取前一天(后一天)的零时零点零分的时间戳这个就是对上面的mktime里面的参数进行修改类似这样$day = date(&#39;d&#39;) + 1;顺便说下mktime(时,分,秒,月,日,年),它是取得一个日期的 Unix 时间戳. 获取身份证中出生日期的时间戳首先说下如何从身份证中获取出生日期,当然,在这之前,要知道身份证有15位的和18位的,所以如果是15位的要转换成18位的,方便计算.代码如下:123456789101112131415161718public function getIDCard($idCard) &#123; // 若是15位，则转换成18位；否则直接返回ID if (15 == strlen ( $idCard )) &#123; $W = array (7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2,1 ); $A = array (&quot;1&quot;,&quot;0&quot;,&quot;X&quot;,&quot;9&quot;,&quot;8&quot;,&quot;7&quot;,&quot;6&quot;,&quot;5&quot;,&quot;4&quot;,&quot;3&quot;,&quot;2&quot; ); $s = 0; $idCard18 = substr ( $idCard, 0, 6 ) . &quot;19&quot; . substr ( $idCard, 6 ); $idCard18_len = strlen ( $idCard18 ); for($i = 0; $i &lt; $idCard18_len; $i ++) &#123; $s = $s + substr ( $idCard18, $i, 1 ) * $W [$i]; &#125; $idCard18 .= $A [$s % 11]; // print_r($idCard18);exit(); return $idCard18; &#125; else &#123; return $idCard; &#125; &#125; 然后提取出生日期:12345678910111213141516public function getAgeByID($id) &#123; $length = strlen($id); if(empty($id))&#123; return &quot;&quot;; &#125; if ($length == 18)&#123; $date = strtotime(substr($id, 6, 8)); print_r($date);exit(); return $date; &#125;elseif($length == 15)&#123; $id = $this-&gt;getIDCard($id); $date = strtotime(substr($id, 6, 8)); return $date; &#125; &#125; 后面就可以直接使用这个函数了. json_encode编码有乱码怎么办json_encode($arr, JSON_UNESCAPED_UNICODE) 返回结果处理成数组1234567891011/* * 返回参数处理，对象转化为数组 */ public function object_array($obj) &#123; $_arr = is_object ( $obj ) ? get_object_vars ( $obj ) : $obj; foreach ( $_arr as $key =&gt; $val ) &#123; $val = (is_array ( $val ) || is_object ( $val )) ? $this-&gt;object_array ( $val ) : $val; $arr [$key] = $val; &#125; return $arr; &#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>时间戳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp中的M,D,C,A,I,S方法]]></title>
    <url>%2F2018%2F09%2F25%2Ftp%E4%B8%AD%E7%9A%84M-D-C-A-I-S%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[才开始接触tp，对里面的大写字母方法不是很理解。现在清晰多了。 D方法实例化模型类的时候通常是实例化某个具体的模型类,如果仅仅是对数据表进行基本的ＣＵＲＤ操作的话，可以使用Ｍ方法．由于不要加载具体的模型类，所以性能会更好．如果D方法没有找到定义的模型类，则会自动调用M方法. M方法12345//使用M方法实例化$User = M(&apos;User&apos;);//和用法$User = new \Think\Model (&apos;User&apos;);等效//执行其他的数据操作$User-&gt;select(); M 方法也支持垮库操作.1234//使用M方法实例化,操作db_name中的ot_user表$User = M(&apos;db_name.User&apos;,&apos;ot_&apos;);//执行其他的数据库操作$User-&gt;select(); M方法的参数和\Think\Model的参数是一样的,所以我们可以这样操作:12$New = M(&apos;new&apos;,&apos;think_&apos;,$connection);//等效于$New = new \Think\Model(&apos;new&apos;,&apos;think_&apos;,$connection); M方法实例化的时候.默认的是直接实例化\Think\Model类,如果要实例化其他的公共模型类,可以使用下面:12$User = M(&apos;\Home\Model\CommonModel:User&apos;,&apos;think_&apos;,&apos;db_config&apos;);相当于$User = new \Home\Model\CommonModel(&apos;User&apos;,&apos;think_&apos;,&apos;db_config&apos;); 实例化基础模型类(Model)在没有定义任何模型的时候,可以使用下面的操作.这种方法简单高效,但是缺点就是没有自定义的模型类,无法写入相关的业务逻辑.只能完成基本的CURD操作.如果你的模型类中有自己的业务逻辑,是无法使用M方法的.123456//实例化User模型$User = new Model(&apos;User&apos;);//或者使用M()快捷方法实例化，和上面的方法是等效的$User = M(&apos;User&apos;);//执行其他的数据操作$User-&gt;select(); 实例化其他模型类 第一种因为没有模型类的定义,很难封装一些额外的逻辑方法.如果只是需要扩展一些通用的逻辑,可以尝试下面方法 1$User = new CommonModel(&apos;User&apos;); 模型的实例化方法有三个参数,第一个参数是模型名称,第二个参数用于设置数据表的前缀(留空则取当前项目配置的表前缀),第三个参数用于设置当前使用的数据库连接信息(留空则取当前项目配置的数据库连接信息). 1$User = new CommonModel(&apos;User&apos;,&apos;think_&apos;,&apos;db_config&apos;); 第三个使用M方法 1$User = M(&apos;CommonModel:User&apos;,&apos;think_&apos;,&apos;db_config&apos;); Ｍ方法默认是实例化ｍｏｄｅｌ类 D方法123456&lt;?php//实例化模型$User = D(&apos;User&apos;);//相当于$User = new \Home\Model\UserModel();//执行操作$User -&gt; select(); 如果Home\Model\UserModel不存在的话,就会尝试实例化公共模型下的\Common\Model\UserModel类.D方法的参数就是实例的名称.并且和模型类的大小写定义是一致的. 参数 实例化的模型文件（假设当前模块为Home） User 对应的模型类文件的 \Home\Model\UserModel.class.php UserType 对应的模型类文件的 \Home\Model\UserTypeModel.class.php 如果在Liunx下,要注意大小写 D方法可以自动检测模型类,如果存在自定义的模型类,则实例化自定义模型类,如果不存在，则会实例化系统的\Think\Model基类，同时对于已实例化过的模型，不会重复去实例化。12345//D方法还可以跨模块调用,需要使用//实例化Admin的User模型D(&apos;Admin/User&apos;);//实例化Extend扩展命名空间下的Info模型D(&apos;Extend://Editor/Info&apos;): 注意：跨模块实例化模型类的时候，不支持自动加载公共模块的模型类。 C方法 定义了配置文件之后,可以使用系统提供的C方法来读取已有额配置. 获取已经设置的参数值:C(‘参数名称’)1$model = C(&apos;URL_MODEL&apos;);//不区分大小写=url_model but 大写是比较规范的.注意:配置参数名称中不能含有”.”和特殊字符如果URL_MODEL尚未存在设置,则返回NULL.123//如果是3.2.1版本的话,支持设置默认值.such asC(&apos;my_config&apos;,&apos;null&apos;,&apos;default_config&apos;);//如果my_config没有设置的话,则返回default_config C方法ue可以用于读取二维配置:12//获取用户配置中的用户类型设置C(&apos;USER_CONFIG.USER_TYPE&apos;); 因为配置参数是全局有效的,因此C方法可以在任何地方读取任何配置,即使某个设置参数以及生效过期了 A方法如果需要跨控制机调用的话,可以单独实例化1234//实例化Home模块的User控制器$User = new \Home\Controller\UserController();//实例化Admin模块的blog控制器$Blog = new \Admin\Controller\BlogController(); 上面的代码是不是很多,这里提供了一个快捷调用方法A简化后如下123//假设当前模块是Home模块$User = A(&apos;User&apos;);$Blog = A(&apos;Admin/Blog&apos;); 默认情况下,A方法实例化的是默认控制器(Controller),如果你要实例化其他的分层控制器的话,可以使用1234//假设当前模块是Home//实例化Event控制器$User = A(&apos;User&apos;);// 等效于new \Home\Event\UserEvent();$Blog = A(&apos;Admin/Blog&apos;,&apos;Event&apos;);// 等效于new \Admin\Event\BlogEvent(); I方法在web开发过程中,我们经常要获取系统变量或者用户提交的数据.这些数据处理不好就会引起安全隐患,所以tp给我们提供了一个变量获取功能.我们先看下传统获取方式:12345$id = $_GET[&apos;id&apos;]; // 获取get变量$name = $_POST[&apos;name&apos;]; // 获取post变量$value = $_SESSION[&apos;var&apos;]; // 获取session变量$name = $_COOKIE[&apos;name&apos;]; // 获取cookie变量$file = $_SERVER[&apos;PHP_SELF&apos;]; // 获取server变量 传统获取方法没有统一的安全机制,后期调整比较麻烦,更好的方式是在框架中统一使用I函数进行变量获取和过滤。I方法是ThinkPHP用于更加方便和安全的获取系统输入变量，可以用于任何地方，用法格式如下：1I(&apos;变量类型.变量名/修饰符&apos;,[&apos;默认值&apos;],[&apos;过滤方法或正则&apos;],[&apos;额外数据源&apos;]) 变量类型是指请求方式或者输入类型 变量类型 含义 get 获取GET参数 post 获取POST参数 param 自动判断请求类型获取GET、POST或者PUT参数 request 获取REQUEST 参数 put 获取PUT 参数 session 获取 $_SESSION 参数 cookie 获取 $_COOKIE 参数 server 获取 $_SERVER 参数 globals 获取 $GLOBALS参数 path 获取 PATHINFO模式的URL参数 data 获取 其他类型的参数，需要配合额外数据源参数 注意：变量类型不区分大小写，变量名则严格区分大小写。 默认值和过滤方法均属于可选参数。下面是I方法的范例使用12echo I(&apos;get.id&apos;); // 相当于 $_GET[&apos;id&apos;]echo I(&apos;get.name&apos;); // 相当于 $_GET[&apos;name&apos;] 支持默认值:12echo I(&apos;get.id&apos;,0); // 如果不存在$_GET[&apos;id&apos;] 则返回0echo I(&apos;get.name&apos;,&apos;&apos;); // 如果不存在$_GET[&apos;name&apos;] 则返回空字符串 采用方法过滤:12// 采用htmlspecialchars方法对$_GET[&apos;name&apos;] 进行过滤，如果不存在则返回空字符串echo I(&apos;get.name&apos;,&apos;&apos;,&apos;htmlspecialchars&apos;); 支持直接获取整个变量值12// 获取整个$_GET 数组I(&apos;get.&apos;); 用同样的方式，我们可以获取post或者其他输入类型的变量12345678I(&apos;post.name&apos;,&apos;&apos;,&apos;htmlspecialchars&apos;); // 采用htmlspecialchars方法对$_POST[&apos;name&apos;] 进行过滤，如果不存在则返回空字符串I(&apos;session.user_id&apos;,0); // 获取$_SESSION[&apos;user_id&apos;] 如果不存在则默认为0I(&apos;cookie.&apos;); // 获取整个 $_COOKIE 数组I(&apos;server.REQUEST_METHOD&apos;); // 获取 $_SERVER[&apos;REQUEST_METHOD&apos;] param变量类型是框架特有的支持自动判断当前请求类型的变量获取方式，例如：1echo I(&apos;param.id&apos;); 如果当前请求类型是GET，那么等效于 $_GET[‘id’]，如果当前请求类型是POST或者PUT，那么相当于获取 $_POST[‘id’] 或者 PUT参数id。由于param类型是I函数默认获取的变量类型，因此事实上param变量类型的写法可以简化为：1234I(&apos;id&apos;); // 等同于 I(&apos;param.id&apos;)I(&apos;name&apos;); // 等同于 I(&apos;param.name&apos;) path类型变量可以用于获取URL参数（必须是PATHINFO模式参数有效，无论是GET还是POST方式都有效），例如： 当前访问URL地址是 http://serverName/index.php/New/2013/06/01123456echo I(&apos;path.1&apos;); // 输出2013echo I(&apos;path.2&apos;); // 输出06echo I(&apos;path.3&apos;); // 输出01 data类型变量可以用于获取不支持的变量类型的读取，例如：1I(&apos;data.file1&apos;,&apos;&apos;,&apos;&apos;,$_FILES); 变量过滤如果你没有在调用I函数的时候指定过滤方法的话，系统会采用默认的过滤机制（由DEFAULT_FILTER配置），事实上，该参数的默认设置是：12// 系统默认的变量过滤机制&apos;DEFAULT_FILTER&apos; =&gt; &apos;htmlspecialchars&apos; 也就说，I方法的所有获取变量如果没有设置过滤方法的话都会进行htmlspecialchars过滤，那么：12// 等同于 htmlspecialchars($_GET[&apos;name&apos;])I(&apos;get.name&apos;); 同样，该参数也可以设置支持多个过滤，例如：1&apos;DEFAULT_FILTER&apos; =&gt; &apos;strip_tags,htmlspecialchars&apos; 设置后，我们在使用：12// 等同于 htmlspecialchars(strip_tags($_GET[&apos;name&apos;]))I(&apos;get.name&apos;); 如果我们在使用I方法的时候 指定了过滤方法，那么就会忽略DEFAULT_FILTER的设置，例如:12// 等同于 strip_tags($_GET[&apos;name&apos;])echo I(&apos;get.name&apos;,&apos;&apos;,&apos;strip_tags&apos;); I方法的第三个参数如果传入函数名，则表示调用该函数对变量进行过滤并返回（在变量是数组的情况下自动使用array_map进行过滤处理），否则会调用PHP内置的filter_var方法进行过滤处理，例如：1I(&apos;post.email&apos;,&apos;&apos;,FILTER_VALIDATE_EMAIL); 表示 会对$_POST[‘email’] 进行 格式验证，如果不符合要求的话，返回空字符串。 （关于更多的验证格式，可以参考 官方手册的filter_var用法。） 或者可以用下面的字符标识方式：1I(&apos;post.email&apos;,&apos;&apos;,&apos;email&apos;); 可以支持的过滤名称必须是filter_list方法中的有效值（不同的服务器环境可能有所不同），可能支持的包括：123456789101112131415161718intbooleanfloatvalidate_regexpvalidate_urlvalidate_emailvalidate_ipstringstrippedencodedspecial_charsunsafe_rawemailurlnumber_intnumber_floatmagic_quotescallback 还可以支持进行正则匹配过滤，例如：123// 采用正则表达式进行变量过滤I(&apos;get.name&apos;,&apos;&apos;,&apos;/^[A-Za-z]+$/&apos;);I(&apos;get.id&apos;,0,&apos;/^\d+$/&apos;); 如果正则匹配不通过的话，则返回默认值。在有些特殊的情况下，我们不希望进行任何过滤，即使DEFAULT_FILTER已经有所设置，可以使用：123// 下面两种方式都不采用任何过滤方法I(&apos;get.name&apos;,&apos;&apos;,&apos;&apos;);I(&apos;get.id&apos;,&apos;&apos;,false); 一旦过滤参数设置为空字符串或者false，即表示不再进行任何的过滤。最新版本的I函数支持对变量使用修饰符功能，可以更方便的通过类型过滤变量。1I(&apos;变量类型.变量名/修饰符&apos;) 123456I(&apos;get.id/d&apos;); // 强制变量转换为整型I(&apos;post.name/s&apos;); // 强制转换变量为字符串类型I(&apos;post.ids/a&apos;); // 强制变量转换为数组类型 可以使用的修饰符包括： 修饰符 作用 s 强制转换为字符串类型 d 强制转换为整型类型 b 强制转换为布尔类型 a 强制转换为数组类型 f 强制转换为浮点类型]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[路由,模块化设计,命名空间]]></title>
    <url>%2F2018%2F09%2F25%2F%E8%B7%AF%E7%94%B1-%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[ThinkPHP采用模块化的架构思想,可以支持多模块应用的创建,让应用的扩展更加方便.先简单说下路由规则: 什么是路由?系统从url参数中分析当前请求的分组(平台),控制器和操作方法的过程就是路由.tp框架路由共有四种形式 基本get形式http://网址/index.php?m=分组&amp;c=控制器&amp;a=操作方法该方式是最底层的get形式、传统的参数传递方式，不时尚、不安全。 PATHINFO路径形式(默认方式)http://网址/index.php/分组/控制器/操作方法比如:http://网址/index.php/Home/Index/advert rewrite重写形式(伪静态技术)省略index.php入口文件(URL模式不可用)http://网址/分组/控制器/操作方法http://网址/Home/Index/index 兼容形式http://网址/index.php?s=/分组/控制器/操作方法http://网址/index.php?s=/Home/Index/advert注意不要忘了加接口文件自动生成模块目录如果我们需要生成一个Admin模块用于后台应用，在应用入口文件中定义如下：1234// 绑定Admin模块到当前入口文件define(&apos;BIND_MODULE&apos;,&apos;Admin&apos;);define(&apos;APP_PATH&apos;,&apos;./Application/&apos;);require &apos;./ThinkPHP/ThinkPHP.php&apos;;/ /可不要 如果需要生成更多的控制器类，可以定义BUILD_CONTROLLER_LIST常量.12345// 绑定Admin模块到当前入口文件define(&apos;BIND_MODULE&apos;,&apos;Admin&apos;);define(&apos;BUILD_CONTROLLER_LIST&apos;,&apos;Index,User,Menu&apos;);define(&apos;APP_PATH&apos;,&apos;./Application/&apos;);require &apos;./ThinkPHP/ThinkPHP.php&apos;; 注意：默认生成的控制器类都是继承Think\Controller，如果需要继承其他的公共类需要另外调整。 如果在应用的公共配置文件中设置关闭了 APP_USE_NAMESPACE的话，生成的控制器类则不会采用命名空间定义。 命名空间 什么是命名空间?在php程序语言里边，语法规则要求同名称的函数、类名、常量在一个请求里边不允许出现多次。如果有的应用程序不得已必须出现多个同名的 函数、类名、常量，那么我们就可以把它们放到不同的空间里边做请求。这个不同的空间就称作“命名空间”。同一个请求里边定义两个同名的函数getInfo()，右图由于有使用命名空间，使得程序可以正常执行。同名称的两个函数在同一个空间进行访问系统要报错.同名称的两个函数放到不同空间做访问，就不会报错 使用命名空间通过namespace关键字声明命名空间。namespace 空间名称;(空间名称 按照php正确的命名方式定义即可)命名空间针对 函数、类名、const常量 三部分起作用，并统称为“元素”。常量的声明：123define(名称，值); //(在类外部声明常量)与命名空间没有关系//同名称常量只能define一次const 名称=值; //与命名空间有关系 ① const可以在类的内部声明常量信息(类常量)② const也可以在类外部声明常量(正常常量)使用命名空间的时候const可以放到类外部声明常量。同名称的多个常量，可以分别定义到不同的“命名空间”里边const和define的区别：前者针对命名空间发生影响，后者不发生影响。const可以声明多个同名称的常量define对同名称常量只能声明一个空间元素的访问(当前空间、其他空间)：子级(多级)空间 命名空间可以让我们存放许多元素(函数、类、常量)，有的时候元素比较多，为了管理方便，可以对元素进行分门别类地存储。也就是说命名空间可以设置为多级空间。多级空间的最后一级空间就称为“子级空间”多级空间的声明及空间元素的访问：空间元素访问的三种形式① 非限定名称1234echo Animal::$name; 就近访问上边与其挨着最近空间的Animal元素(类似php引入文件：include “common.php”; //相对路径引入当前目录下的common.php文件) ② 限定名称12echo beijing\Animal::$name; // 把当前空间 和 beijing空间联合获得Animal元素(类似php引入文件：include “Common/Conf/config.php”; 相对路径) ③ 完全限定名称 echo \beijing\Animal::$name; //访问beijing空间的Animal元素 (类似php引入文件：include “d:/web/1121/Conf/common.php”; 绝对路径引入文件) 访问空间元素的两种方式：限定名称访问元素：限定名称访问元素的特殊情况，linken被巧合访问到：引入机制命名空间可以声明为多级空间，这个多级空间元素在其他空间内部访问的时候，不得已需要通过 完全限定名称 方式，这个完全限定名称不方便开发、维护，为了降低代码的复杂度，可以在当前的空间把指定的空间给引入进来，进而可以方便地通过“限定名称”的方便的形式使用其他空间的元素。空间引入use 空间;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的公钥和私钥]]></title>
    <url>%2F2018%2F09%2F25%2Fphp%E4%B8%AD%E7%9A%84%E5%85%AC%E9%92%A5%E5%92%8C%E7%A7%81%E9%92%A5%2F</url>
    <content type="text"><![CDATA[最近公司业务需要用到公钥和私钥,之前接触的很少,不是很了解,刚刚上网了解了下.发现很多地方都要用到加密.有对称加密算法（ DES,AES）[加密和解密都使用一个密钥]和不对称加密算法(RSA).这里说的是RSA（非对称加密算法）.RSA就涉及到公钥和私钥.要记住的就是:公钥加密,私钥解密.私钥加密,公钥解密. RSA加密:SHA-1(杀one)中的RSA算法核心特点:有一个公钥,有一个私钥,二者是一套,且每一套都是独一无二的.再无第二套一模一样的.公钥可以随便给人,但私钥确是不可外传的.公钥私钥都可以进行加密解密,哪个加的密,就必须用这一套的另外一个钥进行解密.钥的加密实际就是一个规则 什么是公钥加密?假设一下，两个字母，一个是a，一个是b。我喜欢b这个数字，就保留起来，不告诉你们(私钥），然后我告诉大家，a是我的公钥。我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道b就是解密的私钥啊，所以他解不开，只有我可以用数字b，就是我的私钥，来解密。这样我就可以保护数据了。某人用我的公钥a加密了字符hello，加密后成了xxxxx，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道b就是我的私钥，只有我才能解密，解密后就得到hello。这样，我们就可以传送加密的数据了。 私钥签名如果我用私钥加密一段数据（当然只有我可以用私钥加密，因为只有我知道b是我的私钥），结果所有的人都看到我的内容了，因为他们都知道我的公钥是a，那么这种加密有什么用处呢？某人说有人冒充我给他发信。怎么办呢？我把我要发的信，内容是c，用我的私钥b，加密，加密后的内容是d，发给某人，再告诉他解密看是不是c。他用我的公钥a解密，发现果然是c。这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。这样我们就能确认发送方身份了。这个过程叫做数字签名。当然具体的过程要稍微复杂一些。用私钥来加密数据，用途就是数字签名。公钥和私钥是成对的，它们互相解密。公钥加密，私钥解密。私钥数字签名，公钥验证。 下面贴上php中使用公钥私钥加密解密的代码以及其中需要注意的地方:首先公钥和私钥存放的方式有文件和字符串的形式.不过作为小白要注意的是,公钥私钥无论是放在文件中还是字符串里面,千万要记得分行.我刚开始一直不分行,然后就是老是出错,后来才知道要分行.而且不要忘了前后的注释行.—–BEGIN PUBLIC KEY—–下面这段是错误的123-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADxdfxfgcghCBiQKBgQCIgm80UzfD9lQ/tnASRCapNNaoTcodUfDzNYLWAxEMp8EtWkD4eZmWbMdaWKyShIOGS48NKdVGsAB+F4usW1VFtrbqOfKgBUxMJKz1YcciBiV3kvhHZI4/jq94E0qy1jxTNdralRhe+0/JklopEM9QWZScpBT4IXBfbMJ3JD5doQIDAQAB-----END PUBLIC KEY----- 这段代码形式才是正确的123456-----BEGIN PUBLIC KEY-----MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCIgm80UzfD9lQ/tnASRCapNNaoTcodUfDzNYLWAxEMp8EtWkD4eZmWbMdaWKyShIOGS48NKdVGsAB+F4usW1VFtrbqOfKgBUxMJKz1YcciBiV3kvhHZI4/jq94E0qy1jxTNdralRhe+0/JklopEM9QWZScpBT4IXBfbMJ3JD5doQIDAQAB-----END PUBLIC KEY----- 解决的公钥私钥的存放,然后就是代码中需要用到的加密解密了,加签解签了.其中用到的函数可以直接在php手册加密中查看http://php.net/manual/zh/refs.crypto.php首先是公钥加密:这里用到的函数是openssl_public_encrypt(http://php.net/manual/zh/function.openssl-public-encrypt.php)123456789101112131415public function encrypt($data,$key_path)&#123; $key = file_get_contents($key_path); $encryptedList = array(); $step = 117; $encryptedData = &apos;&apos;; $len = strlen($data); for ($i = 0; $i &lt; $len; $i += $step) &#123; $tmpData = substr($data, $i, $step); $encrypted = &apos;&apos;; openssl_public_encrypt($tmpData, $encrypted, $key,OPENSSL_PKCS1_PADDING); $encryptedList[] = ($encrypted); &#125; $encryptedData = base64_encode(join(&apos;&apos;, $encryptedList)); return $encryptedData;&#125; 用私钥解密(用到的函数openssl_private_decrypt)123456789101112131415private function decrypt($encryptedData)&#123; if (empty($encryptedData)) &#123; return &apos;&apos;; &#125; $encryptedData = base64_decode($encryptedData); $decryptedList = array(); $step = 128; $len = strlen($encryptedData); for ($i = 0; $i &lt; $len; $i += $step) &#123; $data = substr($encryptedData, $i, $step); $decrypted = &apos;&apos;; openssl_private_decrypt($data, $decrypted, file_get_contents($this-&gt;_key_pri), OPENSSL_PKCS1_PADDING); $decryptedList[] = $decrypted; &#125; return join(&apos;&apos;, $decryptedList); 用私钥加签,用到的函数(openssl_get_privatekey)1234567private function rsa_sign($data)&#123; //私钥加签 $res = openssl_get_privatekey(file_get_contents($this-&gt;_key_priva_mime)); openssl_sign($data, $sign, $res, OPENSSL_ALGO_SHA1); openssl_free_key($res); $sign = base64_encode($sign); return $sign; 公钥验签(openssl_get_publickey)1234567private function _rsaCheckSign($data, $sign)&#123; $pubKey = file_get_contents($this-&gt;_key_pub_mime); $res = openssl_get_publickey($pubKey); $result = (bool)openssl_verify($data, base64_decode($sign), $res); openssl_free_key($res); return $result; &#125; ps:如果是文件形式的公私钥,需要使用file_get_contents,括号中可以是地址.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>公钥</tag>
        <tag>私钥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tp中遇到的相关方法]]></title>
    <url>%2F2018%2F09%2F25%2Ftp%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[getDbFields这个方法在tp手册的字段定义中通常每个模型类是操作某个数据表，在大多数情况下，系统会自动获取当前数据表的字段信息。系统会在模型首次实例化的时候自动获取数据表的字段信息（而且只需要一次，以后会永久缓存字段信息，除非设置不缓存或者删除），如果是调试模式则不会生成字段缓存文件，则表示每次都会重新获取数据表字段信息。字段缓存保存在Runtime/Data/_fields/ 目录下面，缓存机制是每个模型对应一个字段缓存文件（注意：并非每个数据表对应一个字段缓存文件），命名格式是：数据库名.数据表前缀+模型名（小写）.php12demo.think_user.php // User模型生成的字段缓存文件demo.top_article.php // Article模型生成的字段缓存文件 字段缓存包括数据表的字段信息、主键字段和是否自动增长，如果开启字段类型验证的话还包括字段类型信息等等，无论是用M方法还是D方法，或者用原生的实例化模型类一般情况下只要是不开启调试模式都会生成字段缓存（字段缓存可以单独设置关闭）。可以通过设置DB_FIELDS_CACHE 参数来关闭字段自动缓存，如果在开发的时候经常变动数据库的结构，而不希望进行数据表的字段缓存，可以在项目配置文件中增加如下配置：12// 关闭字段缓存&apos;DB_FIELDS_CACHE&apos;=&gt;false 注意：调试模式下面由于考虑到数据结构可能会经常变动，所以默认是关闭字段缓存的。如果需要显式获取当前数据表的字段信息，可以使用模型类的getDbFields方法来获取当前数据对象的全部字段信息，例如：12$User = M(&apos;User&apos;);$fields = $User-&gt;getDbFields(); 如果你在部署模式下面修改了数据表的字段信息，可能需要清空Data/_fields目录下面的缓存文件，让系统重新获取更新的数据表字段信息，否则会发生新增的字段无法写入数据库的问题。 如果不希望依赖字段缓存或者想提高性能，也可以在模型类里面手动定义数据表字段的名称，可以避免IO加载的效率开销，例如：12345678namespace Home\Model;use Think\Model;class UserModel extends Model &#123; protected $fields = array(&apos;id&apos;, &apos;username&apos;, &apos;email&apos;, &apos;age&apos;); protected $pk = &apos;id&apos;;//pk属性定义当前数据表的主键名，默认值就是id，因此如果是id的话可以无需定义&#125; 如果你的数据表使用了复合主键，可以这样定义：123456namespace Home\Model;use Think\Model;class ScoreModel extends Model &#123; protected $fields = array(&apos;user_id&apos;, &apos;lession_id&apos;,&apos;score&apos;); protected $pk = array(&apos;user_id&apos;,&apos;lession_id&apos;);&#125; 除了可以设置数据表的字段之外，我们还可以定义字段的类型，用于某些验证环节。例如：12345namespace Home\Model;use Think\Model;class UserModel extends Model &#123; protected $fields = array(&apos;id&apos;, &apos;username&apos;, &apos;email&apos;, &apos;age&apos;, &apos;_type&apos;=&gt;array(&apos;id&apos;=&gt;&apos;bigint&apos;,&apos;username&apos;=&gt;&apos;varchar&apos;,&apos;email&apos;=&gt;&apos;varchar&apos;,&apos;age&apos;=&gt;&apos;int&apos;) );&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>tp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器和解释器]]></title>
    <url>%2F2018%2F09%2F25%2F%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[Q &amp; A编译器和解释器之间的区别是什么？编译器相对于解释器的优点是什么？解释器相对于编译器的优点是什么？在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？把一种高级语言翻译成另一种高级语言的编译器成为源到源（source-to-source）的翻译器。编译器使用C语言作为目标语言有什么好处？描述一下汇编器所要完成的一些任务。 编译器和解释器之间的区别是什么？什么是编译器A compiler is a computer program that transforms code written in a high-level programming language into the machine code. It is a program which translates the human-readable code to a language a computer processor understands (binary 1 and 0 bits). The computer processes the machine code to perform the corresponding tasks.A compiler should comply with the syntax rule of that programming language in which it is written. However, the compiler is only a program and cannot fix errors found in that program. So, if you make a mistake, you need to make changes in the syntax of your program. Otherwise, it will not compile. 编译器是一种计算机程序，它将用高级编程语言编写的代码转换为机器代码。它是一个程序，它将人类可读的代码翻译成计算机处理器理解的语言（二进制1和0位）。计算机处理机器代码以执行相应的任务。 编译器应遵循编写它的编程语言的语法规则。但是，编译器只是一个程序，无法修复该程序中发现的错误。因此，如果犯了错误，则需要更改程序的语法。否则，它将无法编译。 什么是解释器？An interpreter is a computer program, which coverts each high-level program statement into the machine code. This includes source code, pre-compiled code, and scripts. Both compiler and interpreters do the same job which is converting higher level programming language to machine code. However, a compiler will convert the code into machine code (create an exe) before program run. Interpreters convert code into machine code when the program is run. 解释器是一种计算机程序，它将每个高级程序语句转换为机器代码。这包括源代码，预编译代码和脚本。编译器和解释器都执行相同的工作，即将更高级别的编程语言转换为机器代码。但是，编译器会在程序运行之前将代码转换为机器代码（创建exe）。解释程序在程序运行时将代码转换为机器代码。 比较点 编译器 解释器 编程步骤 创建程序-&gt;编译器会分析是否正确，如果有问题提就抛出来，没有-&gt;将源代码转化成机器代码-&gt;它将不同的代码文件链接到一个可运行的程序-&gt;执行 创建程序-&gt;不链接文件或者生成机器代码-&gt;在执行期间逐行执行源语句 优势 这段程序以及被翻译成机器代码，代码执行时间更少 解释器更加方便使用，尤其是对新手来说 劣势 改变程序必须返回到源代码修改 解释程序必须在具有相应解释器的计算机上运行。 机器编码 将机器语言存储为磁盘上的机器代码 根本不保存机器代码 运行时间 编译代码运行得更快 解释的代码运行速度较慢 模型 它基于语言翻译链接加载模型。 它基于解释方法。 编码生成 生成输出程序（以exe的形式），可以独立于原始程序运行。 不生成输出程序。因此，他们在执行期间每次都会评估源程序。 运行 程序执行与编译分开。它仅在编译完整个输出程序后执行。 程序执行是解释过程的一部分，因此它是逐行执行的。 内存要求 目标程序是独立执行的，不需要内存中的编译器。 解释器在解释期间存在于解释器中。 最适合 限制在特定的目标机器上，无法移植。 C和C ++是最流行的一种使用编译模型的编程语言 对于Web环境，加载时间很重要。由于所有详尽的分析都已完成，编译需要相对较长的时间来编译甚至可能无法多次运行的小代码。在这种情况下，解释器会更好。 代码优化 编译器可以预先查看整个代码。因此，它们执行大量优化，使代码运行得更快 解释器逐行查看代码，因此优化不如编译器强大 动态打印 难以实现，因为编译器无法预测转折时会发生什么。 解释语言支持动态打字 环境 它最适合生产环境 它最适合程序和开发环境。 错误执行 编译器在编译时显示所有错误和警告。因此，无法在不修复错误的情况下运行程序 解释器读取单个语句并显示错误（如果有）。您必须更正错误以解释下一行。 输入 它需要一个完整的程序 它需要一行代码。 输出 编译器生成中间机器代码。 解释器不生成中间机器代码。 错误 同时显示编译后的所有错误。 逐个显示每行的所有错误 语言 C,C++,C#,Scala,Java all use compiler PHP,Perl,Ruby uses an interpreter]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP多表查询]]></title>
    <url>%2F2018%2F09%2F25%2FThinkPHP%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[这里有两张关联的表(table1,table2),想要通过其中一张表(table1)查询另外一张表(table2)的详细信息.在tp框架中该如何实现呢?(table1) id uid tid 1 66 25 2 67 26 3 68 27 4 68 28 5 70 29 (table2) id name gender 25 张三 男 26 李四 男 27 小花 女 28 小草 女 29 可乐 男 注意,其中uid相同代表是在同一个uid下显示信息. 123456789101112131415161718192021if (I(&apos;post.uid&apos;)) &#123; $map[&apos;uid&apos;] = &apos;68&apos;; $table1 = M(&apos;table1&apos;); if($orderData = $table1-&gt;where($map)-&gt;select())&#123; $data = array(); $table2 = M(&apos;table2&apos;); foreach ($orderData as $v) &#123; $news_map[&apos;id&apos;] = $v[&apos;tid&apos;]; if($myClient = $table2-&gt;where($news_map)-&gt;find())&#123; array_push($data, $myClient); &#125; &#125; $msg[&apos;status&apos;] = 1; $msg[&apos;data&apos;] = $data; $this-&gt;ajaxReturn($msg); &#125; else &#123; $msg[&apos;status&apos;] = 0; $msg[&apos;msg&apos;] = &apos;没有信息！&apos;; $this-&gt;ajaxReturn($msg); &#125; &#125; 返回的json数据如下: 123456789101112131415&#123; &quot;status&quot;: 1, &quot;data&quot;: [ &#123; &quot;id&quot;: &quot;27&quot;, &quot;name&quot;: &quot;小花&quot;, &quot;sex&quot;: &quot;女&quot; &#125;, &#123; &quot;id&quot;: &quot;28&quot;, &quot;name&quot;: &quot;小草&quot;, &quot;sex&quot;: &quot;女&quot; &#125; ]&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>多表查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$this、self和static]]></title>
    <url>%2F2018%2F09%2F25%2F%24this%E3%80%81self%E5%92%8Cstatic%2F</url>
    <content type="text"><![CDATA[$this 只有在类产生实例之后才会存在，我们只是设置一个属性，此时不存在 $this,下图会产生语法错误。 记得这种情况不要使用[0]，[1] 这种写法，全都用常量代替，还有获取一个 pubblic static 属性不需要 new一个实例，app(classA) 这个方式 == new classA 修改如下： 关于类属性、方法调用有3个$this、self、static$this-&gt;foo();selff::foo();static::foo(); $this指向当前对象，用来访问当前对象的非静态变量和非静态方法。123456789101112131415&lt;?phpclass Person &#123; public $name; public function getName() &#123; echo $this-&gt;name; &#125;&#125;$p = new Person();$p2 = new Person();$p-&gt;name = &quot;小红&quot;;$p2-&gt;name = &quot;小明&quot;;$p-&gt;getName(); // 小红$p2-&gt;getName(); // 小明 上面 new 了两个对象，并分别设置对象的 name 属性，getName() 中使用了 this 访问当前对象的 name 属性，所以分别输出了 name 的值。所以说，this 就是指向当前对象，不指向其他对象或类。 self::指向类，一般用来访问当前类的静态变量和静态方法，运行之前已经确定指向哪个类。12345678910111213141516&lt;?phpclass Person &#123; public static $name = &quot;小红&quot;; public static function getName() &#123; echo self::$name; &#125;&#125;$p = new Person();$p2 = new Person();$p::getName(); // 小红$p2::getName(); // 小红$p::$name = &quot;小明&quot;;$p::getName(); // 小明$p2::getName(); // 小明 self 和 this 不同，它指向类本身，不指向任何实例化对象，一般用来访问类中的静态变量和静态方法；上例中 new 了两个对象，并修改了其中一个对象的 name 属性，另一个对象的 name 属性值也改变了，所以说，self 是指向当前类的，和对象无关，所有的对象共用一个值。 static指向类，一般用来访问当前类的静态变量和静态方法，但是又不限于静态的调用，运行时才确定指向哪个类。static 和 self 一样，都是指向类，一般都用来访问类中的静态变量和静态方法，但是又有一些不一样，具体来讲：self 写在哪个类里，实际调用的就是这个类；static 则是写在父类里，然后通过子类用到了这个 static，这个 static 指向的是这个子类，官方称之为 后期静态绑定 。12345678910111213141516171819202122232425&lt;?phpclass A &#123; public function say() &#123; echo &quot;Hello&quot;; &#125; public function saySelf() &#123; self::say(); &#125; public function sayStatic() &#123; static::say(); &#125;&#125;class B extends A &#123; public function say() &#123; echo &quot;World&quot;; &#125;&#125;$b = new B();$b-&gt;say(); // World$b-&gt;saySelf(); // Hello$b-&gt;sayStatic(); // World 上例中可以看到，self 写在 A 类里，调用时就指向了 A 类，static 同样写在 A 类里，但是用 A 类的子类 B 类的对象去调用时，却指向了 B 类，在使用时，static 才确定指向哪个类，这就是 后期静态绑定 。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>self</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json & jsonp]]></title>
    <url>%2F2018%2F09%2F25%2Fjson%20%26%20jsonp%2F</url>
    <content type="text"><![CDATA[对于JSON和JSONP，应该都不陌生，咳咳，不过最初对JSONP有点误解，以为是JSON的另外一个别名，其实二者风马牛不相及。 谈到Json和jsonp就不可避免要提到跨域这个话题了，以前对跨域的理解都是比较模糊的，还以为域名不同就是跨域了，那太狭隘了。非同源请求，均为跨域。 不过为什么会出现跨域？出于浏览器的同源策略限制，浏览器会拒绝跨域请求。严格的说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。浏览器的同源限制策略是这样执行的： 通常浏览器允许进行跨域写操作（Cross-origin writes），如链接，重定向； 通常浏览器允许跨域资源嵌入（Cross-origin embedding），如 img、script 标签（主要是有src）； 通常浏览器不允许跨域读操作（Cross-origin reads）。* 等等，上面咋又来了个同源策略，本是同根生，相煎何太急啊。 大家互相开开心心的走亲访友多好。哼，谁知道你是我亲戚还是坏人，万一你来我家是想偷小鱼干的呢？还开开心心，本喵不得哭死啊。 同源策略 (Same-Origin Policy) 最早由 Netscape 公司提出, 所谓同源就是要求, 域名, 协议, 端口相同. 非同源的脚本不能访问或者操作其他域的页面对象(如DOM等). 作为著名的安全策略, 虽然它只是一个规范, 并不强制要求, 但现在所有支持 javaScript 的浏览器都会使用这个策略. 以至于该策略成为浏览器最核心最基本的安全功能, 如果缺少了同源策略, web的安全将无从谈起.（这段文字是cv的） 这下好了，同源策略下的web世界, 域的壁垒高筑, 保证各个网页相互独立, 互相之间不能直接访问, iframe, ajax 均受其限制, 而script标签不受此限制. 注: 如非特别说明, 均指非CORS的, 普通跨域请求. 咳咳，我们讲json呢，扯远了，快回来 哎，哎，相公，别敲我脑袋瓜子啊，疼，敲笨了你就只能有个笨媳妇。人家这不是麻溜的回来了嘛，你倒是给我说说json和惊悚有啥不同。 “你知道啥是json么？” “本大喵当然知道，json是一种数据格式” “手写一段给本汪瞅瞅” 12345678// 描述一个人var person = &#123; &quot;Name&quot;: &quot;大宝&quot;, &quot;Age&quot;: 1, &quot;Company&quot;: &quot;IBM&quot;, &quot;Engineer&quot;: true&#125; “算你上次没逃课，那你给我说说，这个json有啥要注意的地方？” “咦，json不就简单的数据格式吗，有啥要注意？” “就知道你上次没认真听，肯定开小差了，今晚回去小鱼干没了。” “喵呜～～～人家错了，你再说一遍吧？嘤嘤嘤” “记得下次考你，看仔细了” ■ ■■■■ 这会儿带你认识认识jsonp了，看会儿惊悚片 “喵喵，你知道ajax么？” “听过，但是不太了解” “推荐一个blog，你去看看，下次讲给我听听，答的好有小鱼干吃哟” “猴！得令” Ajax直接请求普通文件存在跨域无权限访问的问题，无论是静态页面还是动态页面，web服务，WCF（喵呜，这是啥？），但是在web页面上调用js文件时不受到跨域的影响（凡是拥有src属性的都有跨域的神奇能力），所以可以通过在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理，而处理这些数据的格式可以是json，而且json还被原生js支持，很完美了。 方案如下： Web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件，客户端在对json文件成功调用之后，获得了自己所需的数据，这就是jsonp，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住json数据，这样客户端就可以随意定制函数来自动处理返回数据。 具体实现示例： 喵喵：远程服务器。cat.com 汪汪：本地服务器.dag.com 1 miaomiao.js是cat.com根目录下的一个js文件。 代码如下1&lt;pre style=&quot;margin: 0.5em 0px; padding: 0.4em 0.6em; border-radius: 8px; background: rgb(248, 248, 248); box-sizing: border-box;&quot;&gt;alert(‘喵呜，我是喵喵’);&lt;/pre&gt; Jsonp.html是dag.com下的一个页面： 这里会弹出弹窗，现实跨域成功。 2 在jsonp.html页面定义一个函数。然后在远程文件miaomiao.js中传入数据进行调用。 miaomiao.js: 1localHandler(&#123;&quot;result&quot;:&quot;我是远程猫js带来的数据&quot;&#125;); 运行之后，显示本地调用成功，并且获取数据。但是如何让miaomiao知道它调用的dog函数叫什么呢？毕竟附近的dog太多了。 3 喵喵和汪汪想了一个办法，如果汪汪想要调用喵喵，就在返回的骨头上加一个标志，说我想调用XXX函数的js代码，你丫别给我传错了啊。于是喵喵就按照骨头上的需求来生成js脚本并且给汪汪一个响应“拿好你的骨头，别搞丢了” 汪汪的jsonp.html 上面实现的是编码动态查询，也是jsonp客户端实现的核心。 下面是如何完成jsonp调用的全过程。 上面url中的code参数表示dog告诉cat我要查询附近猪骨的信息，并且把一个叫callback的骨头给cat，说这是我们的暗号（boneHandler），别和其他狗子搞混了，你把结果都放到这块骨头的这个暗号中给我传过来。 于是这个叫做boneResult.aspx的页面生成了一段这样的代码提供给jsonp.html 12345boneHandler(&#123; &quot;code&quot;: &quot;pig&quot;, &quot;price&quot;: 170, &quot;nums&quot;: 5&#125;); 4 如何用jquery实现？ Attention:jquery在处理jsonp类型的ajax时（虽然jquery也把jsonp归入了ajax，但其实它们真的不是一回事儿），自动帮你生成回调函数并把数据取出来供success属性方法来调用 1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext(?)等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加标签来调用服务器提供的js脚本。 3、其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 总而言之，jsonp不是ajax的一个特例，哪怕jquery等巨头把jsonp封装进了ajax，也不能改变着一点！ “傻喵，听懂了么？” 参考资料： 路易斯的blog（推荐看看他的blog，内容满赞的，尤其那个关于mac上使用alfred的技巧，很清晰） 阮一峰的日志 我的博客即将搬运同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=1eteae3c4sdc0]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>jsop</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
</search>
